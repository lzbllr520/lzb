r@assertionscodecustomTransformCachedependenciesidmetamoduleSideEffectsoriginalCodeoriginalSourcemapresolvedIdssourcemapChainsyntheticNamedExportstransformDependenciestransformFilescacheAstrAC$import { doUpdate } from '../class/updater.class';
import { gaugeConfig } from '../config/gauge';
import { getCircleRadianPoint } from '../cRender/plugin/util';
import { deepMerge, initNeedSeries, radianToAngle } from '../util';
import { getFormatterVal } from '../util/common';
import { getRgbaValue } from '../util/color';
let callbackSendable = null;
export function gauge(chart, option) {
    callbackSendable = chart.sendableTestClass || {};
    let { series } = option;
    if (!series)
        series = [];
    let gauges = initNeedSeries(series, gaugeConfig, 'gauge');
    gauges = calcGaugesCenter(gauges, chart);
    gauges = calcGaugesRadius(gauges, chart);
    gauges = calcGaugesDataRadiusAndLineWidth(gauges, chart);
    gauges = calcGaugesDataAngles(gauges, chart);
    gauges = calcGaugesDataGradient(gauges, chart);
    gauges = calcGaugesAxisTickPosition(gauges, chart);
    gauges = calcGaugesLabelPositionAndAlign(gauges, chart);
    gauges = calcGaugesLabelData(gauges, chart);
    gauges = calcGaugesDetailsPosition(gauges, chart);
    gauges = calcGaugesDetailsContent(gauges, chart);
    doUpdate({
        chart,
        series: gauges,
        key: 'gaugeAxisTick',
        getGraphConfig: getAxisTickConfig
    });
    doUpdate({
        chart,
        series: gauges,
        key: 'gaugeAxisLabel',
        getGraphConfig: getAxisLabelConfig
    });
    doUpdate({
        chart,
        series: gauges,
        key: 'gaugeBackgroundArc',
        getGraphConfig: getBackgroundArcConfig,
        // getStartGraphConfig: getStartBackgroundArcConfig
    });
    doUpdate({
        chart,
        series: gauges,
        key: 'gaugeArc',
        getGraphConfig: getArcConfig,
        getStartGraphConfig: getStartArcConfig,
        beforeChange: beforeChangeArc
    });
    doUpdate({
        chart,
        series: gauges,
        key: 'gaugePointer',
        getGraphConfig: getPointerConfig,
        getStartGraphConfig: getStartPointerConfig
    });
    doUpdate({
        chart,
        series: gauges,
        key: 'gaugeDetails',
        getGraphConfig: getDetailsConfig
    });
}
function calcGaugesCenter(gauges, chart) {
    const { area } = chart.render;
    gauges.forEach(gaugeItem => {
        let { center } = gaugeItem;
        center = center.map((pos, i) => {
            if (typeof pos === 'number')
                return pos;
            return parseInt(pos) / 100 * area[i];
        });
        gaugeItem.center = center;
    });
    return gauges;
}
function calcGaugesRadius(gauges, chart) {
    const { area } = chart.render;
    const maxRadius = Math.min(...area) / 2;
    gauges.forEach(gaugeItem => {
        let { radius } = gaugeItem;
        if (typeof radius !== 'number') {
            radius = parseInt(radius) / 100 * maxRadius;
        }
        gaugeItem.radius = radius;
    });
    return gauges;
}
function calcGaugesDataRadiusAndLineWidth(gauges, chart) {
    const { area } = chart.render;
    const maxRadius = Math.min(...area) / 2;
    gauges.forEach(gaugeItem => {
        const { radius, data, dataItemStyle: { arcLineWidth } } = gaugeItem;
        data.forEach(item => {
            let { radius: arcRadius, lineWidth } = item;
            if (!arcRadius)
                arcRadius = radius;
            if (typeof arcRadius !== 'number')
                arcRadius = parseInt(arcRadius) / 100 * maxRadius;
            item.radius = arcRadius;
            if (!lineWidth)
                lineWidth = arcLineWidth;
            item.lineWidth = lineWidth;
        });
    });
    return gauges;
}
function calculateArcAngles(startAngle, endAngle, totalValue, currentValue) {
    // 计算总角度
    const totalAngle = endAngle - startAngle;
    // 每单位值对应的角度 (弧度)
    const anglePerUnit = totalAngle / totalValue;
    // 当前值对应的角度
    const angleForCurrentValue = currentValue * anglePerUnit;
    // 计算当前值对应的开始和结束角度
    const currentStartAngle = startAngle;
    const currentEndAngle = startAngle + angleForCurrentValue;
    return {
        startAngle: currentStartAngle,
        endAngle: currentEndAngle
    };
}
function calcGaugesDataAngles(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { startAngle, endAngle, data, min, max } = gaugeItem;
        const angleMinus = endAngle - startAngle;
        const valueMinus = max - min;
        data.forEach(item => {
            const { value } = item;
            // const itemAngle = Math.abs((value - min) / valueMinus * angleMinus)
            const itemAngle = calculateArcAngles(startAngle, endAngle, max - min, value);
            item.startAngle = itemAngle.startAngle;
            item.endAngle = itemAngle.endAngle;
        });
    });
    return gauges;
}
function calcGaugesDataGradient(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { data } = gaugeItem;
        data.forEach(item => {
            let { color, gradient } = item;
            if (!gradient || !gradient.length)
                gradient = color;
            if (!(gradient instanceof Array))
                gradient = [gradient];
            item.gradient = gradient;
        });
    });
    return gauges;
}
function calcGaugesAxisTickPosition(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { startAngle, endAngle, splitNum, center, radius, dataItemStyle: { arcLineWidth }, axisTick } = gaugeItem;
        const { tickLength, style: { width: lineWidth } } = axisTick;
        const angles = endAngle - startAngle;
        const outerRadius = radius - (arcLineWidth / 2);
        const innerRadius = outerRadius - tickLength;
        const angleGap = angles / (splitNum - 1);
        const arcLength = 2 * Math.PI * radius * angles / (Math.PI * 2);
        const offset = Math.ceil(lineWidth / 2) / arcLength * angles;
        gaugeItem.tickAngles = [];
        gaugeItem.tickInnerRadius = [];
        gaugeItem.tickPosition = new Array(splitNum).fill(0)
            .map((foo, i) => {
            let angle = startAngle + angleGap * i;
            // if (i === 0) angle += offset
            // if (i === splitNum - 1) angle -= offset
            gaugeItem.tickAngles[i] = angle;
            gaugeItem.tickInnerRadius[i] = innerRadius;
            return [
                getCircleRadianPoint(center[0], center[1], outerRadius, angle),
                getCircleRadianPoint(center[0], center[1], innerRadius, angle)
            ];
        });
    });
    return gauges;
}
function calcGaugesLabelPositionAndAlign(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { center, tickInnerRadius, tickAngles, axisLabel: { labelGap } } = gaugeItem;
        const position = tickAngles.map((angle, i) => getCircleRadianPoint(center[0], center[1], tickInnerRadius[i] - labelGap, tickAngles[i]));
        const align = position.map(([x, y]) => ({
            textAlign: x == center[0] ? 'center' : x > center[0] ? 'right' : 'left',
            textBaseline: y > center[1] ? 'bottom' : 'top'
        }));
        gaugeItem.labelPosition = position;
        gaugeItem.labelAlign = align;
    });
    return gauges;
}
function calcGaugesLabelData(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { axisLabel, min, max, splitNum } = gaugeItem;
        let { data, formatter } = axisLabel;
        const valueGap = (max - min) / (splitNum - 1);
        const value = new Array(splitNum).fill(0).map((foo, i) => parseInt(min + valueGap * i));
        const formatterType = typeof formatter;
        data = deepMerge(value, data).map((v, i) => {
            let label = v;
            if (formatterType === 'string') {
                label = getFormatterVal(callbackSendable, formatter, v, i);
            }
            if (formatterType === 'function') {
                label = formatter(v, i);
            }
            return label;
        });
        axisLabel.data = data;
    });
    return gauges;
}
function calcGaugesDetailsPosition(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { data, details, center } = gaugeItem;
        const { position, offset } = details;
        const detailsPosition = data.map(({ startAngle, endAngle, radius }) => {
            let point = null;
            if (position === 'center') {
                point = center;
            }
            else if (position === 'start') {
                point = getCircleRadianPoint(center[0], center[1], radius, startAngle);
            }
            else if (position === 'end') {
                point = getCircleRadianPoint(center[0], center[1], radius, endAngle);
            }
            return getOffsetedPoint(point, offset);
        });
        gaugeItem.detailsPosition = detailsPosition;
    });
    return gauges;
}
function calcGaugesDetailsContent(gauges, chart) {
    gauges.forEach(gaugeItem => {
        const { data, details } = gaugeItem;
        const { formatter } = details;
        const formatterType = typeof formatter;
        const contents = data.map((dataItem, index) => {
            let content = dataItem.value;
            if (formatterType === 'string') {
                content = getFormatterVal(callbackSendable, formatter, dataItem, index);
            }
            if (formatterType === 'function')
                content = formatter(dataItem, index);
            return content.toString();
        });
        gaugeItem.detailsContent = contents;
    });
    return gauges;
}
function getOffsetedPoint([x, y], [ox, oy]) {
    return [x + ox, y + oy];
}
function getAxisTickConfig(gaugeItem) {
    const { tickPosition, animationCurve, animationFrame, rLevel } = gaugeItem;
    return tickPosition.map((foo, i) => ({
        name: 'polyline',
        index: rLevel,
        visible: gaugeItem.axisTick.show,
        animationCurve,
        animationFrame,
        shape: getAxisTickShape(gaugeItem, i),
        style: getAxisTickStyle(gaugeItem, i)
    }));
}
function getAxisTickShape(gaugeItem, i) {
    const { tickPosition } = gaugeItem;
    return { points: tickPosition[i] };
}
function getAxisTickStyle(gaugeItem, i) {
    const { axisTick: { style } } = gaugeItem;
    return {
        stroke: style.color,
        lineWidth: style.width
    };
}
function getAxisLabelConfig(gaugeItem) {
    const { labelPosition, animationCurve, animationFrame, rLevel } = gaugeItem;
    return labelPosition.map((foo, i) => ({
        name: 'text',
        index: rLevel,
        visible: gaugeItem.axisLabel.show,
        animationCurve,
        animationFrame,
        shape: getAxisLabelShape(gaugeItem, i),
        style: getAxisLabelStyle(gaugeItem, i)
    }));
}
function getAxisLabelShape(gaugeItem, i) {
    const { labelPosition, axisLabel: { data } } = gaugeItem;
    return {
        content: data[i].toString(),
        position: labelPosition[i]
    };
}
function getAxisLabelStyle(gaugeItem, i) {
    const { labelAlign, axisLabel } = gaugeItem;
    const { style } = axisLabel;
    return deepMerge({ ...labelAlign[i] }, {
        fill: style.color,
        fontSize: style.fontSize,
    });
}
function getBackgroundArcConfig(gaugeItem) {
    const { animationCurve, animationFrame, rLevel } = gaugeItem;
    return [{
            name: 'arc',
            index: rLevel,
            visible: gaugeItem.backgroundArc.show,
            animationCurve,
            animationFrame,
            shape: getGaugeBackgroundArcShape(gaugeItem),
            style: getGaugeBackgroundArcStyle(gaugeItem)
        }];
}
function getGaugeBackgroundArcShape(gaugeItem) {
    let { startAngle, endAngle, center, radius } = gaugeItem;
    return {
        rx: center[0],
        ry: center[1],
        r: radius,
        startAngle,
        endAngle
    };
}
function getGaugeBackgroundArcStyle(gaugeItem) {
    const { backgroundArc, dataItemStyle: { arcLineWidth } } = gaugeItem;
    const { style } = backgroundArc;
    return deepMerge({ lineWidth: arcLineWidth }, {
        stroke: style.color
    });
}
function getStartBackgroundArcConfig(gaugeItem) {
    const config = getBackgroundArcConfig(gaugeItem)[0];
    const shape = { ...config.shape };
    shape.endAngle = config.shape.startAngle;
    config.shape = shape;
    return [config];
}
function getArcConfig(gaugeItem) {
    const { data, animationCurve, animationFrame, rLevel } = gaugeItem;
    return data.map((foo, i) => ({
        name: 'agArc',
        index: rLevel,
        animationCurve,
        animationFrame,
        shape: getGaugeArcShape(gaugeItem, i),
        style: getGaugeArcStyle(gaugeItem, i)
    }));
}
function getGaugeArcShape(gaugeItem, i) {
    let { data, center, endAngle: gradientEndAngle } = gaugeItem;
    const { radius, startAngle, endAngle, localGradient } = data[i];
    if (localGradient)
        gradientEndAngle = endAngle;
    return {
        rx: center[0],
        ry: center[1],
        r: radius,
        startAngle,
        endAngle,
        gradientEndAngle
    };
}
function getGaugeArcStyle(gaugeItem, i) {
    const { data, dataItemStyle, color } = gaugeItem;
    let { lineWidth, gradient } = data[i];
    gradient = gradient.map(c => getRgbaValue(c));
    if (!gradient.length) {
        gradient.push(getRgbaValue(dataItemStyle.color || color));
    }
    return deepMerge({ lineWidth, gradient }, {
        fill: dataItemStyle.color || color,
        lineCap: dataItemStyle.lineCap
    });
}
function getStartArcConfig(gaugeItem) {
    const configs = getArcConfig(gaugeItem);
    configs.map(config => {
        const shape = { ...config.shape };
        shape.endAngle = config.shape.startAngle;
        config.shape = shape;
    });
    return configs;
}
function beforeChangeArc(graph, config) {
    const graphGradient = graph.style.gradient;
    const cacheNum = graphGradient.length;
    const needNum = config.style.gradient.length;
    if (cacheNum > needNum) {
        graphGradient.splice(needNum);
    }
    else {
        const last = graphGradient.slice(-1)[0];
        graphGradient.push(...new Array(needNum - cacheNum).fill(0).map(foo => [...last]));
    }
}
function getPointerConfig(gaugeItem) {
    const { animationCurve, animationFrame, center, rLevel } = gaugeItem;
    return [{
            name: 'polyline',
            index: rLevel,
            visible: gaugeItem.pointer.show,
            animationCurve,
            animationFrame,
            shape: getPointerShape(gaugeItem),
            style: getPointerStyle(gaugeItem),
            setGraphCenter(foo, graph) { graph.style.graphCenter = center; }
        }];
}
function getPointerShape(gaugeItem) {
    const { center } = gaugeItem;
    return {
        points: getPointerPoints(center),
        close: true
    };
}
function getPointerStyle(gaugeItem) {
    const { startAngle, endAngle, min, max, data, pointer, center } = gaugeItem;
    const { valueIndex, style } = pointer;
    let value = data[valueIndex] ? data[valueIndex].value : 0;
    const angle = (value - min) / (max - min) * (endAngle - startAngle) + startAngle + Math.PI / 2;
    return deepMerge({ rotate: radianToAngle(angle), scale: [1, 1], graphCenter: center }, {
        scale: style.scale,
        fill: style.color
    });
}
function getPointerPoints([x, y]) {
    const point1 = [x, y - 40];
    const point2 = [x + 5, y];
    const point3 = [x, y + 10];
    const point4 = [x - 5, y];
    return [point1, point2, point3, point4];
}
function getStartPointerConfig(gaugeItem) {
    const { startAngle } = gaugeItem;
    const config = getPointerConfig(gaugeItem)[0];
    config.style.rotate = radianToAngle(startAngle + Math.PI / 2);
    return [config];
}
function getDetailsConfig(gaugeItem) {
    const { detailsPosition, animationCurve, animationFrame, rLevel } = gaugeItem;
    const visible = gaugeItem.details.show;
    return detailsPosition.map((foo, i) => ({
        name: 'numberText',
        index: rLevel,
        visible,
        animationCurve,
        animationFrame,
        shape: getDetailsShape(gaugeItem, i),
        style: getDetailsStyle(gaugeItem, i)
    }));
}
function getDetailsShape(gaugeItem, i) {
    const { detailsPosition, detailsContent, data, details } = gaugeItem;
    const position = detailsPosition[i];
    const content = detailsContent[i];
    const dataValue = data[i].value;
    const toFixed = details.valueToFixed;
    return {
        number: [],
        content,
        position,
        toFixed
    };
}
function getDetailsStyle(gaugeItem, i) {
    const { details, data } = gaugeItem;
    const { style } = details;
    let color = data[i].gradient.length ? data[i].gradient[0] : (style.color || data[i].color);
    delete style.color;
    return deepMerge({ fill: color }, style);
}
//# sourceMappingURL=gauge.js.mapمD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\class\updater.class.ts~D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\config\gauge.tsمD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\cRender\plugin\util.ts|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\index.ts}D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\common.ts|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\color.ts|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\core\gauge.tsrBisLocalDependencyisNodeEntryFilepkgPathpkgNamepkgVersionbelongProjectPathdependencyPkgInfoshouldEmitJsZD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts@mcui/mccharts2.8.9D:\apps\deveco\tzb2025jbgsrCpkgNamepkgVersion@mcui/mccharts2.8.9;Uimport { doUpdate } from '../class/updater.class'

import { gaugeConfig } from '../config/gauge'

import { getCircleRadianPoint } from '../cRender/plugin/util'

import { deepMerge, initNeedSeries, radianToAngle } from '../util'

import { getFormatterVal } from '../util/common'

import { getRgbaValue } from '../util/color'

let callbackSendable = null

export function gauge (chart, option) {
  callbackSendable = chart.sendableTestClass || {}

  let { series } = option

  if (!series) series = []

  let gauges = initNeedSeries(series, gaugeConfig, 'gauge')

  gauges = calcGaugesCenter(gauges, chart)

  gauges = calcGaugesRadius(gauges, chart)

  gauges = calcGaugesDataRadiusAndLineWidth(gauges, chart)

  gauges = calcGaugesDataAngles(gauges, chart)

  gauges = calcGaugesDataGradient(gauges, chart)

  gauges = calcGaugesAxisTickPosition(gauges, chart)

  gauges = calcGaugesLabelPositionAndAlign(gauges, chart)

  gauges = calcGaugesLabelData(gauges, chart)

  gauges = calcGaugesDetailsPosition(gauges, chart)

  gauges = calcGaugesDetailsContent(gauges, chart)

  doUpdate({
    chart,
    series: gauges,
    key: 'gaugeAxisTick',
    getGraphConfig: getAxisTickConfig
  })

  doUpdate({
    chart,
    series: gauges,
    key: 'gaugeAxisLabel',
    getGraphConfig: getAxisLabelConfig
  })

  doUpdate({
    chart,
    series: gauges,
    key: 'gaugeBackgroundArc',
    getGraphConfig: getBackgroundArcConfig,
    // getStartGraphConfig: getStartBackgroundArcConfig
  })

  doUpdate({
    chart,
    series: gauges,
    key: 'gaugeArc',
    getGraphConfig: getArcConfig,
    getStartGraphConfig: getStartArcConfig,
    beforeChange: beforeChangeArc
  })

  doUpdate({
    chart,
    series: gauges,
    key: 'gaugePointer',
    getGraphConfig: getPointerConfig,
    getStartGraphConfig: getStartPointerConfig
  })

  doUpdate({
    chart,
    series: gauges,
    key: 'gaugeDetails',
    getGraphConfig: getDetailsConfig
  })
}

function calcGaugesCenter (gauges, chart) {
  const { area } = chart.render

  gauges.forEach(gaugeItem => {
    let { center } = gaugeItem

    center = center.map((pos, i) => {
      if (typeof pos === 'number') return pos

      return parseInt(pos) / 100 * area[i]
    })

    gaugeItem.center = center
  })

  return gauges
}

function calcGaugesRadius (gauges, chart) {
  const { area } = chart.render

  const maxRadius = Math.min(...area) / 2

  gauges.forEach(gaugeItem => {
    let { radius } = gaugeItem

    if (typeof radius !== 'number') {
      radius = parseInt(radius) / 100 * maxRadius
    }

    gaugeItem.radius = radius
  })

  return gauges
}

function calcGaugesDataRadiusAndLineWidth (gauges, chart) {
  const { area } = chart.render

  const maxRadius = Math.min(...area) / 2

  gauges.forEach(gaugeItem => {
    const { radius, data, dataItemStyle: { arcLineWidth } } = gaugeItem

    data.forEach(item => {
      let { radius: arcRadius, lineWidth } = item

      if (!arcRadius) arcRadius = radius

      if (typeof arcRadius !== 'number') arcRadius = parseInt(arcRadius) / 100 * maxRadius

      item.radius = arcRadius

      if (!lineWidth) lineWidth = arcLineWidth

      item.lineWidth = lineWidth
    })
  })

  return gauges
}

function calculateArcAngles(startAngle, endAngle, totalValue, currentValue) {
  // 计算总角度
  const totalAngle = endAngle - startAngle;

  // 每单位值对应的角度 (弧度)
  const anglePerUnit = totalAngle / totalValue;

  // 当前值对应的角度
  const angleForCurrentValue = currentValue * anglePerUnit;

  // 计算当前值对应的开始和结束角度
  const currentStartAngle = startAngle;
  const currentEndAngle = startAngle + angleForCurrentValue;

  return {
    startAngle: currentStartAngle,
    endAngle: currentEndAngle
  };
}

function calcGaugesDataAngles (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { startAngle, endAngle, data, min, max } = gaugeItem
    
    const angleMinus = endAngle - startAngle
    const valueMinus = max - min

    data.forEach(item => {
      const { value } = item

      // const itemAngle = Math.abs((value - min) / valueMinus * angleMinus)
      const itemAngle = calculateArcAngles(startAngle, endAngle, max - min, value)

      item.startAngle = itemAngle.startAngle
      item.endAngle = itemAngle.endAngle
    })
  })

  return gauges
}

function calcGaugesDataGradient (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { data } = gaugeItem

    data.forEach(item => {
      let { color, gradient } = item

      if (!gradient || !gradient.length) gradient = color

      if (!(gradient instanceof Array)) gradient = [gradient]

      item.gradient = gradient
    })
  })

  return gauges
}

function calcGaugesAxisTickPosition (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { startAngle, endAngle, splitNum, center, radius, dataItemStyle: { arcLineWidth }, axisTick } = gaugeItem

    const { tickLength, style: { width: lineWidth } } = axisTick

    const angles = endAngle - startAngle

    const outerRadius = radius - (arcLineWidth / 2)
    const innerRadius = outerRadius - tickLength

    const angleGap = angles / (splitNum - 1)

    const arcLength = 2 * Math.PI * radius * angles / (Math.PI * 2)

    const offset = Math.ceil(lineWidth / 2) / arcLength * angles

    gaugeItem.tickAngles = []
    gaugeItem.tickInnerRadius = []

    gaugeItem.tickPosition = new Array(splitNum).fill(0)
      .map((foo, i) => {
        let angle = startAngle + angleGap * i

        // if (i === 0) angle += offset
        // if (i === splitNum - 1) angle -= offset

        gaugeItem.tickAngles[i] = angle
        gaugeItem.tickInnerRadius[i] = innerRadius

        return [
          getCircleRadianPoint(center[0], center[1], outerRadius, angle),
          getCircleRadianPoint(center[0], center[1], innerRadius, angle)
        ]
      })
  })

  return gauges
}

function calcGaugesLabelPositionAndAlign (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { center, tickInnerRadius, tickAngles, axisLabel: { labelGap } } = gaugeItem

    const position = tickAngles.map((angle, i) => getCircleRadianPoint(
      center[0], center[1],
      tickInnerRadius[i] - labelGap,
      tickAngles[i]
    ))

    const align = position.map(([x, y]) => ({
      textAlign: x == center[0] ? 'center'  : x > center[0] ? 'right' : 'left',
      textBaseline: y > center[1] ? 'bottom' : 'top'
    }))

    gaugeItem.labelPosition = position
    gaugeItem.labelAlign = align
  })

  return gauges
}

function calcGaugesLabelData (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { axisLabel, min, max, splitNum } = gaugeItem

    let { data, formatter } = axisLabel

    const valueGap = (max - min) / (splitNum - 1)

    const value = new Array(splitNum).fill(0).map((foo, i) => parseInt(min + valueGap * i))

    const formatterType = typeof formatter

    data = deepMerge(value, data).map((v, i) => {
      let label = v

      if (formatterType === 'string') {
        label = getFormatterVal(callbackSendable, formatter, v, i)
      }

      if (formatterType === 'function') {
        label = formatter(v, i)
      }

      return label
    })

    axisLabel.data = data
  })

  return gauges
}

function calcGaugesDetailsPosition (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { data, details, center } = gaugeItem

    const { position, offset } = details

    const detailsPosition = data.map(({ startAngle, endAngle, radius }) => {
      let point = null

      if (position === 'center') {
        point = center
      } else if (position === 'start') {
        point = getCircleRadianPoint(center[0], center[1], radius, startAngle)
      } else if (position === 'end') {
        point = getCircleRadianPoint(center[0], center[1], radius, endAngle)
      }

      return getOffsetedPoint(point, offset)
    })

    gaugeItem.detailsPosition = detailsPosition
  })

  return gauges
}

function calcGaugesDetailsContent (gauges, chart) {
  gauges.forEach(gaugeItem => {
    const { data, details } = gaugeItem

    const { formatter } = details

    const formatterType = typeof formatter

    const contents = data.map((dataItem, index) => {
      let content = dataItem.value

      if (formatterType === 'string') {
        content = getFormatterVal(callbackSendable, formatter, dataItem, index)
      }

      if (formatterType === 'function') content = formatter(dataItem, index)

      return content.toString()
    })

    gaugeItem.detailsContent = contents
  })

  return gauges
}

function getOffsetedPoint ([x, y], [ox, oy]) {
  return [x + ox, y + oy]
}

function getAxisTickConfig (gaugeItem) {
  const { tickPosition, animationCurve, animationFrame, rLevel } = gaugeItem

  return tickPosition.map((foo, i) => ({
    name: 'polyline',
    index: rLevel,
    visible: gaugeItem.axisTick.show,
    animationCurve,
    animationFrame,
    shape: getAxisTickShape(gaugeItem, i),
    style: getAxisTickStyle(gaugeItem, i)
  }))
}

function getAxisTickShape (gaugeItem, i) {
  const { tickPosition } = gaugeItem

  return { points: tickPosition[i] }
}

function getAxisTickStyle (gaugeItem, i) {
  const { axisTick: { style } } = gaugeItem

  return {
    stroke: style.color,
    lineWidth: style.width
  }
}

function getAxisLabelConfig (gaugeItem) {
  const { labelPosition, animationCurve, animationFrame, rLevel } = gaugeItem

  return labelPosition.map((foo, i) => ({
    name: 'text',
    index: rLevel,
    visible: gaugeItem.axisLabel.show,
    animationCurve,
    animationFrame,
    shape: getAxisLabelShape(gaugeItem, i),
    style: getAxisLabelStyle(gaugeItem, i)
  }))
}

function getAxisLabelShape (gaugeItem, i) {
  const { labelPosition, axisLabel: { data } } = gaugeItem

  return {
    content: data[i].toString(),
    position: labelPosition[i]
  }
}

function getAxisLabelStyle (gaugeItem, i) {
  const { labelAlign, axisLabel } = gaugeItem

  const { style } = axisLabel

  return deepMerge({ ...labelAlign[i] }, {
    fill: style.color,
    fontSize: style.fontSize,
  })
}

function getBackgroundArcConfig (gaugeItem) {
  const { animationCurve, animationFrame, rLevel } = gaugeItem

  return [{
    name: 'arc',
    index: rLevel,
    visible: gaugeItem.backgroundArc.show,
    animationCurve,
    animationFrame,
    shape: getGaugeBackgroundArcShape(gaugeItem),
    style: getGaugeBackgroundArcStyle(gaugeItem)
  }]
}

function getGaugeBackgroundArcShape (gaugeItem) {
  let { startAngle, endAngle, center, radius } = gaugeItem

  return {
    rx: center[0],
    ry: center[1],
    r: radius,
    startAngle,
    endAngle
  }
}

function getGaugeBackgroundArcStyle (gaugeItem) {
  const { backgroundArc, dataItemStyle: { arcLineWidth } } = gaugeItem

  const { style } = backgroundArc

  return deepMerge({ lineWidth: arcLineWidth }, {
    stroke: style.color
  })
}

function getStartBackgroundArcConfig (gaugeItem) {
  const config = getBackgroundArcConfig(gaugeItem)[0]

  const shape = { ...config.shape }

  shape.endAngle = config.shape.startAngle

  config.shape = shape

  return [config]
}

function getArcConfig (gaugeItem) {
  const { data, animationCurve, animationFrame, rLevel } = gaugeItem

  return data.map((foo, i) => ({
    name: 'agArc',
    index: rLevel,
    animationCurve,
    animationFrame,
    shape: getGaugeArcShape(gaugeItem, i),
    style: getGaugeArcStyle(gaugeItem, i)
  }))
}

function getGaugeArcShape (gaugeItem, i) {
  let { data, center, endAngle: gradientEndAngle } = gaugeItem

  const { radius, startAngle, endAngle, localGradient } = data[i]

  if (localGradient) gradientEndAngle = endAngle

  return {
    rx: center[0],
    ry: center[1],
    r: radius,
    startAngle,
    endAngle,
    gradientEndAngle
  }
}

function getGaugeArcStyle (gaugeItem, i) {
  const { data, dataItemStyle, color } = gaugeItem

  let { lineWidth, gradient } = data[i]

  gradient = gradient.map(c => getRgbaValue(c))

  if (!gradient.length) {
    gradient.push(getRgbaValue(dataItemStyle.color || color))
  }

  return deepMerge({ lineWidth, gradient }, {
    fill: dataItemStyle.color || color,
    lineCap: dataItemStyle.lineCap
  })
}

function getStartArcConfig (gaugeItem) {
  const configs = getArcConfig(gaugeItem)

  configs.map(config => {
    const shape = { ...config.shape }

    shape.endAngle = config.shape.startAngle

    config.shape = shape
  })

  return configs
}

function beforeChangeArc (graph, config) {
  const graphGradient = graph.style.gradient

  const cacheNum = graphGradient.length
  const needNum = config.style.gradient.length

  if (cacheNum > needNum) {
    graphGradient.splice(needNum)
  } else {
    const last = graphGradient.slice(-1)[0]

    graphGradient.push(...new Array(needNum - cacheNum).fill(0).map(foo => [...last]))
  }
}

function getPointerConfig (gaugeItem) {
  const { animationCurve, animationFrame, center, rLevel } = gaugeItem

  return [{
    name: 'polyline',
    index: rLevel,
    visible: gaugeItem.pointer.show,
    animationCurve,
    animationFrame,
    shape: getPointerShape(gaugeItem),
    style: getPointerStyle(gaugeItem),
    setGraphCenter (foo, graph) { graph.style.graphCenter = center }
  }]
}

function getPointerShape (gaugeItem) {
  const { center } = gaugeItem

  return {
    points: getPointerPoints(center),
    close: true
  }
}

function getPointerStyle (gaugeItem) {
  const { startAngle, endAngle, min, max, data, pointer, center } = gaugeItem

  const { valueIndex, style } = pointer

  let value = data[valueIndex] ? data[valueIndex].value : 0

  const angle = (value - min) / (max - min) * (endAngle - startAngle) + startAngle + Math.PI / 2

  return deepMerge({ rotate: radianToAngle(angle), scale: [1, 1], graphCenter: center }, {
    scale: style.scale,
    fill: style.color
  })
}

function getPointerPoints ([x, y]) {
  const point1 = [x, y - 40]
  const point2 = [x + 5, y]
  const point3 = [x, y + 10]
  const point4 = [x - 5, y]

  return [point1, point2, point3, point4]
}

function getStartPointerConfig (gaugeItem) {
  const { startAngle } = gaugeItem

  const config = getPointerConfig(gaugeItem)[0]

  config.style.rotate = radianToAngle(startAngle + Math.PI / 2)

  return [config]
}

function getDetailsConfig (gaugeItem) {
  const { detailsPosition, animationCurve, animationFrame, rLevel } = gaugeItem

  const visible = gaugeItem.details.show

  return detailsPosition.map((foo, i) => ({
    name: 'numberText',
    index: rLevel,
    visible,
    animationCurve,
    animationFrame,
    shape: getDetailsShape(gaugeItem, i),
    style: getDetailsStyle(gaugeItem, i)
  }))
}

function getDetailsShape (gaugeItem, i) {
  const { detailsPosition, detailsContent, data, details } = gaugeItem

  const position = detailsPosition[i]
  const content = detailsContent[i]

  const dataValue = data[i].value

  const toFixed = details.valueToFixed

  return {
    number: [],
    content,
    position,
    toFixed
  }
}

function getDetailsStyle (gaugeItem, i) {
  const { details, data } = gaugeItem

  const { style } = details

  let color = data[i].gradient.length ? data[i].gradient[0] : (style.color || data[i].color)

  delete style.color

  return deepMerge({ fill: color }, style)
}rD../class/updater.class../cRender/plugin/util../config/gauge../util../util/common../util/colorrEassertionsexternalidmetamoduleSideEffectsresolvedBysyntheticNamedExportsAمD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\class\updater.class.tsAêoh-resolveEAمD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\cRender\plugin\util.tsAêoh-resolveEA~D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\config\gauge.tsAêoh-resolveEA|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\index.tsAêoh-resolveEA}D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\common.tsAêoh-resolveEA|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\color.tsAêoh-resolverFversionfilesourceRootsourcesnamesmappingsgauge.jsgauge.tsۘ      	  	      1  12  1    	 	   - -. -    	 	  % %= => =    	 	  " "$ $1 13 39 9B BC B    	 	     0 01 0  
  
	 
	 
 
 
, 
,- 
,                 # $     . ,2 04 25 2  
        	              & $( &3 15 3< := ;> ; 
    $ "& $+ ), *- * 
    $ "& $+ ), *- * 
  - +. ,4 26 4; 9< := : 
  ! "  ( &* (/ -0 .1 . 
  # !$ "* (, *1 /2 03 0 !
 ! !' !%( !&. !,0 !.5 !36 !47 !4 #
 # #, #*- #+3 #15 #3: #8; #9< #9 %
 % %  %! %' %%) %'. %,/ %-0 %- '
 ' '& '$' '%- '+/ '-4 '25 '36 '3 )
 ) )% )#& )$, )*. ),3 )14 )25 )2 + +
 + , ,	 - -
 - - . . .	 . / / /) /% 0 0 0 2 2
 2 3 3	 4 4
 4 4 5 5 5	 5 6 6 6* 6& 7 7 7 9 9
 9 : :	 ; ;
 ; ; < < <	! < = = =. =* >; >7 ? ? ? A A
 A B B	 C C
 C C D D D	 D E E E$ E  F F F. F* G G G% G! H H H J J
 J K K	 L L
 L L M M M	 M N N N( N$ O O O2 O. P P P R R
 R S S	 T T
 T T U U U	 U V V V( V$ W W W  X  X  Z 	 Z	 Z Z  Z!" Z#' Z( [
 [ [
 [ [ [ [ [! [" [ ]
 ] ]	 ] ] ] ] ] ^ ^ ^
 ^ ^ ^" ^# ^ ` `
 ` ` ` ` ` `  `" `# `% `!' `# a a
 a a a' a! a# a* a- a- c c c c c  c# c& c ) c#- c'. c(/ c)0 c*1 c* d	 d
 d d f f f f f! f" f g g g g i i	 i i  j  j  l 	 l	 l l  l!" l#' l( m
 m m
 m m m m m! m" m o
 o o o o o o o" o & o$' o%* o(+ o), o) q
 q q	 q q q q q r r r
 r r r" r# r t t t t t& t"( t$ u u u u u$ u% u( u"+ u%. u(7 u18 u1	 v x x x x x! x" x y y y y { {	 { {  |  |  ~ 	 ~	) ~)* ~+0 ~12 ~37 ~8 
  
     ! "  ́
 ́ ́ ́ ́ ́ ́ ́" ́ & ́$' ́%* ́(+ ́), ́) ̃
 ̃ ̃	 ̃ ̃ ̃ ̃ ̃  ̄ ̄
 ̄ ̄ ̄ ̄ ̄+ ̄'- ̄)/ ̄+; ̄7= ̄9? ̄;B ̄>K ̄GL ̄G ̆ ̆ ̆	 ̆ ̆ ̆ ̆ ̆ ̇ ̇
 ̇ ̇ ̇# ̇% ̇. ̇(0 ̇*3 ̇-7 ̇18 ̇1 ̉ ̉
 ̉ ̉ ̉ ̉ ̉"" ̉(# ̉( ̋ ̋
 ̋  ̋% ̋- ̋' ̋) ̋2 ̋5$ ̋=% ̋>. ̋G/ ̋H2 ̋K5 ̋N8 ̋QA ̋ZB ̋Z ̍ ̍
 ̍ ̍ ̍# ̍$ ̍ ̏ ̏
 ̏ ̏ ̏ ̏ ̏"( ̏.) ̏. ̑ ̑
 ̑ ̑ ̑& ̑ ' ̑  ̒	 ̒
 ̒ ̒ ̓ ̓ ̓ ̓ ̕ ̕	 ̕ ̕  ̖  ̖  ̘ 	 ̘	 ̘ ̘& ̘&( ̘(0 ̘02 ̘2< ̘<> ̘>J ̘J ̙ ̙
 ̚
 ̚ ̚ ̚ ̚" ̚ , ̚*- ̚+ ̜ ̜ ̝
 ̝ ̝ ̝# ̝!& ̝$0 ̝.1 ̝/ ̟ ̟ ̠
 ̠ ̠! ̠- ̠+0 ̠.< ̠:= ̠; ̢ ̢ ̣
 ̣ ̣ ̣( ̣&) ̣' ̤
 ̤ ̤ ̤& ̤$) ̤'= ̤;> ̤< ̦ ̦	 ̧ ̧ ̧% ̧! ̨ ̨ ̨! ̨ ̩ ̩  ̪  ̪  ̬ 	 ̬	 ̬ ̬$ ̬%& ̬'+ ̬, ̭
 ̭ ̭	 ̭ ̭ ̭ ̭ ̭  ̮ ̮
 ̮ ̮ ̮$ ̮ & ̮"* ̮&, ̮(/ ̮+1 ̮-4 ̮06 ̮29 ̮5B ̮>C ̮> ̰ ̰
 ̰ ̰# ̰& ̰"0 ̰,1 ̰, ̱ ̱
 ̱ ̱ ̱! ̱$ ̱ % ̱  ̳ ̳ ̳	 ̳ ̳ ̳ ̳ ̳ ̴ ̴ ̴ ̴ ̴ ̴" ̴# ̴ ̶R ̶L  ̷ ̷ ̷ ̷0 ̷*1 ̷+; ̷5= ̷7E ̷?G ̷AJ ̷DM ̷GP ̷JR ̷LW ̷QX ̷RY ̷R ̹ ̹
 ̹ ̹ ̹' ̹!( ̹"2 ̹,3 ̹, ̺ ̺
 ̺ ̺ ̺% ̺& ̺ . ̺(/ ̺( ̻	 ̻
 ̻ ̻ ̼ ̼ ̼ ̼ ̾ ̾	 ̾ ̾  ̿  ̿   	 	   !& '( )- . 
  	       
    " #    	       
   ! # &  * $+ $  
    &  ' !- ' ) 1 4  9! 9  
   &  + %, & ( 0 3 4$ <% =& =  
   $ %  	 
        	         	 	# #$ %* +, -1 2 
  	        
   $  & ". *0 ,6 28 4> :@ <M IO KQ M] Y_ [a ]i ek gn jw sx s   
   ! # % !* &, (5 17 39 5< 8D @E @  
   " , (- (  
  " % !& "2 .5 16 27 38 3  
  ' #* &4 05 0  
   " # + '. */ +0 ,1 ,   
    " # % !( $. *1 -7 3: 6; 7? ;@ <B >E AF BG CH C   
      ! * &- ). */ +2 .; 7> :D @E @     ! "    ! $  & "' "    ! % !* &+ '3 /4 05 19 5: 6; 7< 8  
           " % !- )0 ,1 -2 - + ' 6 2     ! " # & "+ ', '   % !& "' #( $+ '6 27 2    
$ % + %, &- '. (0 *6 07 18 29 3; 5F @H BM GN H  
$ % + %, &- '. (0 *6 07 18 29 3; 5F @H BM GN H 	 	 	 
        	         	 	( () */ 01 26 7 
  	        
   ' #) %3 /5 1> :@ <B >J FL HN JQ MZ V[ V )  
  # $  ' #( $) %. *0 ,1 -3 /5 16 2J FK  Q  R  S  T  V  \  ]  ^  _  a p q r s v ~ #̀ ̊ ̋ ̌ ̍ ̎ ̏ ̐    
    " # $  % !& "( $) %* &, (. */ +0 ,      " # $ % &  ' !( "0 *1 ,2 -3 .4 /7 2= 8> 9? :@ ;A <B =C >J EK FL GM HS N      $ % &  ' !( ") #* $2 ,3 -4 .5 /: 4	 
    
 
 
 
" 
* 
&+ 
&     $  %        	         	 	  # $% &* + 
  	       
      # % !- )/ +2 .; 7< 7   
    " + ', '   
      # $  ' #( $0 ,3 /4 05 16 1 "  
      ( $) %* &. */ +0 ,1 -2 .5 16 27 3: 6< 8= 9? ;A =B >J FK GN JQ MY U\ X] Y^ Z_ [` [  
  % !. */ *         $  % !& ") %* &+ ', (. */ +1 -3 /  
        
  "  *  $,  & ! ! !' !( ! 8 !0: !2C !;E !=F !>H !@I !AJ !BK !B " $ $
 $" $, $&. $( % % %! %" %# %% %& %' %( % & ( ( ( ( )	 )
 ) ) + + + + + + + , , , , . .	 . .  /  /  1 	 1	" 1"# 1$) 1*+ 1,0 11 2
 2 2	 2 2 2 2 2 3 3
 3 3 3 3 3% 3!' 3#* 3&3 3/4 3/ 5 5
 5 5 5  5" 5% 5!, 5(- 5(  7 7
 7  7$ 7 % 7!( 7$) 7%* 7&, 7(6 728 74@ 7<B 7>H 7DJ 7FL 7HN 7J 8 8
 8 8 8 8 : :
 : :% :' :! ; ; ; ; ; < < < <" <) <%+ <'  = = =, =$- =%3 =+4 =,5 =-6 =.8 =0> =6? =7@ =8A =9C =;I =AK =CU =MV =NW =N > > > >" >' >#) >%  ? ? ?, ?$- ?%3 ?+4 ?,5 ?-6 ?.8 ?0> ?6? ?7@ ?8A ?9C ?;I ?AK ?CS ?KT ?LU ?L @ B B# B$ B) B#+ B%1 B+2 B,3 B, C	 C
 C C E E E! E$ E 3 E/4 E/ F F F F H H	 H H  I  I  K 	 K	! K!" K#( K)* K+/ K0 L
 L L	 L L L L L M M
 M M M M M" M+ M', M' O O
 O O O O% O!& O! Q Q
 Q Q% Q!. Q*/ Q* S S
 S S S S! S" S# S+ S'- S)2 S.4 S06 S2 T T
 T T" T# T( T") T" V V
 V" V* V$, V& W W W) W!* W": W2< W4E W=G W?O WGQ WIV WNW WOX WO X Z Z
 Z" Z, Z& Z( Z/ Z2# Z;$ Z<, ZD. ZF3 ZK4 ZL5 ZL \ \ \ \# \% \& \ ]	 ]
 ] ] _ _ _  _# _+ _', _' ` ` ` ` b b	 b b  c  c  e 	 e	 e e e e e e   e!" e## e$% e&' e() e** e+ f f	 f
 f f f f f f f f f  g  g  i 	 i	 i i$ i% j
 j j
 j j( j&* j(8 j6: j8@ j>B j@E jCN jLO jL l l	 l l l l l  l" l # l!% l#' l%( l&) l' m m m
 m n n	 n n o o o o o# o$ o ( o$ p p q q r r	 r r  r) r%+ r', r(- r) s s	 s s  s) s%+ s', s(- s) t t t t  u  u  w 	 w	 w w# w$% w&& w' x
 x x
 x x x& x$' x$ z z	 z z z! z" z # z!$ z"& z$' z$  {  {  } 	 }	 } }# }$% }&& }' ~
 ~ ~
 ~ ~ ~ ~ ~! ~$ ~"- ~+. ~+  	  
                   	 	  % & 
  
  ) '+ )9 7; 9A ?C AF DO MP M  	     ! # !$ "& $( &) '* (   
   	       $  % !) %      	   ! * &, (- ). *  	   ! * &, (- ). *           	 	  $ %& '' ( 
  
  $ "& $( &, *. ,0 .3 1< := :  	        ! #       ! "          	 	  $ %& '' ( 
  
  ! # !& $/ -0 - 
  
        	    $ "% #& $' %) '+ )   
                    	 	   !) * 
  
  * (, *2 04 27 5@ >A >  	 
   
   	       , $- %1 )      	 - %. &7 /8 0  	 - %. &7 /8 0	 
         	 	# #$ %- .  
      & $( &. ,0 .3 1< := :  	 
       
       	                	 	# #$ %- . 
  
  ( &* (, *8 6: 8< :? =H FI F 
  
   # !$ !  	     "  . ,0 .2 0  
              	 	$ $% &. / 
   ) '* (3 14 25 36 47 58 5 
       # !% #& # 	 
     ! "  , *- * 
  	      	 
          	 	     
  
    "  0 .2 08 6: 8= ;F DG D  	            !    
   	        	    ) %+ ', (- )  	    ) %+ ', (- )           	 	  # $% && '  
       "  2 04 27 5@ >A >  
  
     ( &* (7 59 7< :@ >A ?B @C AD A     % (# 0$ 0  	 
       
       	                  	 	  # $% && ' 
  
   ! & $( &+ )4 25 2  
     "  & $' %( &) '* '   
         ! - +. ,/ -0 .1 /2 /  	          " # 0 ,1 -6 2: 6? ;@ <A =B =   	     "  * (, *. ,   
  ! % !* &     & "          	 	  $ % 
     ! * (+ ), ) 
 
	 

 
 
 
 
 
  
    ! " ' #) %* %  	 
     % !& "0 ,1 ,  
           	         	 	     !& ' 
      % #& $. ,/ , 
   "  # !) '* ' 
       ! ) '* (0 .1 .           $  % !& ! 	 	  
  " # ( $) %* &+ ', (- ). */ +0 +              "  '  #(  $/  +2  .:  6;  7<  8@  <A  =B  >C  ?D  @G  CH  DK  GL  HN  JO  KP  LS  OW  SX  TY  UZ  V[  V !  "  "  $ 	 $	 $ $# $$ %
 % %
 % %* %(, %*2 %04 %2: %8< %:? %=H %FI %F ' '	 '
 ( ( (
 ( ) )	 ) ) * * * * *& *' *+ *# + + , , - -	 -" -# -, -$- -% . .	 ." .# ., .$- .%  / / / /  /% /) /". /'/ /(4 /-5 /.@ /9C /<I /BJ /BK /CL /D	 0
 0 0  1  1  3 	 3	 3 3" 3# 4
 4 4
 4 4 4  4! 4 6 6	 7 7
 7  7! 7' 7#( 7$ 8 8	 8 8 9 9  :  :  < 	 <	 < <" <#  =
 = =
 = =  =" = % =#' =%* =(, =*0 =.2 =09 =7; =9A =?C =AF =DO =MP =M ?
 ? ?
 ? ? ? ?" ? ) ?'* ?'  A A A A A A A  A! A" A # A!' A%( A&2 A03 A14 A29 A7: A8; A9< A:= A;> A;  C
 C C C C C C C C" C # C!& C$) C', C*- C+0 C.1 C/9 C7< C:F CDG CEJ CHT CRW CU[ CY\ CZ^ C\a C_b C`c C`  E E	 E E E E E, E*- E+2 E03 E15 E3: E8< E:= E;> E<@ E>A E?B E@D EBO EMQ EOW EUY EW[ EY F F	 F F F F G G G
 G G G H H H  I  I  K 	 K	 K K K K K K   K! L
 L L L L L L L L L L L M
 M M M M M M M M M M M N
 N N N N N N N N N N N O
 O O O O O O O O O O O Q Q	 Q
 Q Q Q Q" Q $ Q"* Q(+ Q), Q)  R  R  T 	 T	 T T ( T) U
 U U
 U U U$ U"% U" W
 W W W# W!$ W"- W+. W,/ W-0 W.1 W/2 W/  Y
 Y Y	 Y Y Y Y' Y%( Y&2 Y05 Y39 Y7: Y8< Y:? Y=@ Y>A Y?B Y? [ [	 [
 [ [ [  \  \  ^ 	 ^	 ^ ^# ^$ _
 _ _
 _ _+ _)- _+; _9= _;C _AE _CH _FQ _OR _O a
 a a a a a% a#& a$* a(+ a( c c	 c c c c  c# c!% c#& c$( c&* c(+ c), c* d d d
 d e e	 e e f f g g h h i i	 i i i( i$* i&+ i', i( j j	 j j j( j$* j&+ j', j( k k k k  l  l  n 	 n	 n n" n#$ n%% n& o
 o o
 o o+ o)- o+1 o/3 o1: o8< o:? o=H oFI oF q
 q q q$ q"% q#& q$' q%( q% r
 r r r" r # r!$ r"% r#& r# t
 t t t t t t t t# t!$ t! v
 v v v v v( v&) v& x x	 y y
 y y z z { { | | } }  ~  ~   	 	  " #$ %% & 
  
     ' %( % 
  
      (           ! ' %( &) '* (. ,/ -0 .1 /2 0: 8; 9< := ;> <? =@ >A ?F DG EL JP NT RU SV TW UX V] [^ \_ \  	      	     "  $ "& $+ ), *- *    rGversionfilesourcessourcesContentnamesmappingsܑ                              	   
                                                                      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~      ̀   ́   ̂   ̃   ̄   ̅   ̆   ̇   ̈   ̉   ̊   ̋   ̌   ̍   ̎   ̏   ̐   ̑   ̒   ̓   ̔   ̕   ̖   ̗   ̘   ̙   ̚   ̛   ̜   ̝   ̞   ̟   ̠   ̡   ̢   ̣   ̤   ̥   ̦   ̧   ̨   ̩   ̪   ̫   ̬   ̭   ̮   ̯   ̰   ̱   ̲   ̳   ̴   ̵   ̶   ̷   ̸   ̹   ̺   ̻   ̼   ̽   ̾   ̿                                                                                                                                                                                                                               	   
                                                                      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~                                                                                                                                                                                                                                                                                        rHmissingpluginægenAbc  rIdynamicImportCacheexportAllDeclarationCacheexportNamedDeclarationCacheimportCacherJtypestartenddeclarationspecifierssourceExportNamedDeclarationi~rKtypestartendidexpressiongeneratorasyncparamsbodyFunctionDeclarationp~rLtypestartendnameIdentifiery~gaugeLIdentifierchartLIdentifieroptionrMtypestartendbodyBlockStatement~ rNtypestartendexpressionExpressionStatementrOtypestartendoperatorleftrightAssignmentExpressionš=LIdentifiercallbackSendablerPtypestartendleftoperatorrightLogicalExpressionrQtypestartendobjectpropertycomputedoptionalMemberExpressionLIdentifierchartLIdentifiersendableTestClass¢||rRtypestartendpropertiesObjectExpressionŐrStypestartenddeclarationskindVariableDeclarationrTtypestartendidinitVariableDeclaratorRObjectPatternڑrUtypestartendmethodshorthandcomputedkeykindvaluePropertyLIdentifierئseriesinitLIdentifierئseriesLIdentifieroptionletrVtypestartendtestconsequentalternateIfStatementrWtypestartendoperatorprefixargumentUnaryExpression!LIdentifierseriesNExpressionStatement OAssignmentExpression =LIdentifier seriesrXtypestartendelementsArrayExpression	SVariableDeclarationLTVariableDeclaratorKLIdentifiergaugesrYtypestartendcalleeargumentsoptionalCallExpressionKLIdentifier-initNeedSeriesLIdentifier.4seriesLIdentifier6AgaugeConfigrZtypestartendvaluerawLiteralCJgauge'gauge'£letNExpressionStatementR{OAssignmentExpressionRz=LIdentifierRXgaugesYCallExpression[zLIdentifier[kcalcGaugesCenterLIdentifierlrgaugesLIdentifiertychartNExpressionStatementOAssignmentExpression=LIdentifiergaugesYCallExpressionLIdentifiercalcGaugesRadiusLIdentifiergaugesLIdentifierchartNExpressionStatementOAssignmentExpression=LIdentifiergaugesYCallExpressionLIdentifier calcGaugesDataRadiusAndLineWidthLIdentifiergaugesLIdentifierchartNExpressionStatementOAssignmentExpression=LIdentifiergaugesYCallExpressionLIdentifiercalcGaugesDataAnglesLIdentifiergaugesLIdentifierchartNExpressionStatement"QOAssignmentExpression"P=LIdentifier"(gaugesYCallExpression+PLIdentifier+AcalcGaugesDataGradientLIdentifierBHgaugesLIdentifierJOchartNExpressionStatementWOAssignmentExpressionW=LIdentifierW]gaugesYCallExpression`LIdentifier`zcalcGaugesAxisTickPositionLIdentifier{gaugesLIdentifierchartNExpressionStatementOAssignmentExpressionǡ=LIdentifiergaugesYCallExpressionLIdentifiercalcGaugesLabelPositionAndAlignLIdentifiergaugesLIdentifierƥchartNExpressionStatementOAssignmentExpression=LIdentifierԦgaugesYCallExpressionLIdentifiercalcGaugesLabelDataLIdentifiergaugesLIdentifierchartNExpressionStatement 2OAssignmentExpression 1=LIdentifier gaugesYCallExpression	1LIdentifier	"calcGaugesDetailsPositionLIdentifier#)gaugesLIdentifier+0chartNExpressionStatement8iOAssignmentExpression8h=LIdentifier8>gaugesYCallExpressionAhLIdentifierAYcalcGaugesDetailsContentLIdentifierZ`gaugesLIdentifierbgchartNExpressionStatementoYCallExpressionoLIdentifierowdoUpdateRObjectExpressionxUPropertyLIdentifierchartinitLIdentifierchartr[typestartendmethodshorthandcomputedkeyvaluekindPropertyLIdentifierseriesLIdentifiergaugesinit[PropertyLIdentifierkeyZLiteralgaugeAxisTick'gaugeAxisTick'init[PropertyLIdentifierٮgetGraphConfigLIdentifiergetAxisTickConfiginitNExpressionStatementYCallExpressionLIdentifierdoUpdateRObjectExpressionUPropertyLIdentifierchartinitLIdentifierchart[Property-LIdentifier%seriesLIdentifier'-gaugesinit[Property8MLIdentifier8;keyZLiteral=MgaugeAxisLabel'gaugeAxisLabel'init[PropertyXzLIdentifierXfgetGraphConfigLIdentifierhzgetAxisLabelConfiginitNExpressionStatementWYCallExpressionVLIdentifierdoUpdateRObjectExpressionUUPropertyLIdentifierchartinitLIdentifierchart[PropertyLIdentifierseriesLIdentifiergaugesinit[PropertyLIdentifierɣkeyZLiteral߲gaugeBackgroundArc'gaugeBackgroundArc'init[PropertyLIdentifiergetGraphConfigLIdentifiergetBackgroundArcConfiginitNExpressionStatement]2YCallExpression]1LIdentifier]edoUpdateRObjectExpressionf0UPropertyqvLIdentifierqvchartinitLIdentifierqvchart[PropertyLIdentifierseriesLIdentifiergaugesinit[PropertyLIdentifierkeyZLiteralgaugeArc'gaugeArc'init[PropertyLIdentifier®getGraphConfigLIdentifierЬgetArcConfiginit[PropertyLIdentifiergetStartGraphConfigLIdentifiergetStartArcConfiginit[Property)LIdentifierbeforeChangeLIdentifier)beforeChangeArcinitNExpressionStatement8YCallExpression8LIdentifier8@doUpdateRObjectExpressionAUPropertyLQLIdentifierLQchartinitLIdentifierLQchart[Property\jLIdentifier\bseriesLIdentifierdjgaugesinit[PropertyuLIdentifieruxkeyZLiteralzgaugePointer'gaugePointer'init[PropertyLIdentifiergetGraphConfigLIdentifiergetPointerConfiginit[PropertyLIdentifierѳgetStartGraphConfigLIdentifiergetStartPointerConfiginitNExpressionStatement{YCallExpressionzLIdentifierdoUpdateRObjectExpression yUPropertyLIdentifierchartinitLIdentifierchart[Property)LIdentifier!seriesLIdentifier#)gaugesinit[Property4GLIdentifier47keyZLiteral9GgaugeDetails'gaugeDetails'init[PropertyRrLIdentifierR`getGraphConfigLIdentifierbrgetDetailsConfiginitr\typestartendspecifierssourceImportDeclaration 2r]typestartendimportedlocalImportSpecifier	LIdentifier	doUpdateLIdentifier	doUpdateZLiteral1../class/updater.class'../class/updater.class'\ImportDeclaration4b]ImportSpecifier=HLIdentifier=HgaugeConfigLIdentifier=HgaugeConfigZLiteralPa../config/gauge'../config/gauge'\ImportDeclarationd̢]ImportSpecifierḿLIdentifierḿgetCircleRadianPointLIdentifierḿgetCircleRadianPointZLiteral̡̉../cRender/plugin/util'../cRender/plugin/util'\ImportDeclaration̤]ImportSpecifier̶̭LIdentifier̶̭deepMergeLIdentifier̶̭deepMerge]ImportSpecifier̸LIdentifier̸ƮinitNeedSeriesLIdentifier̸ƮinitNeedSeries]ImportSpecifierLIdentifierխradianToAngleLIdentifierխradianToAngleZLiteral../util'../util'\ImportDeclaration]ImportSpecifierLIdentifiergetFormatterValLIdentifiergetFormatterValZLiteral	../util/common'../util/common'\ImportDeclarationI]ImportSpecifier%1LIdentifier%1getRgbaValueLIdentifier%1getRgbaValueZLiteral9H../util/color'../util/color'