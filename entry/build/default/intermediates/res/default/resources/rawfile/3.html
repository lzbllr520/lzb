<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ROS 实时视图 (Chart.js 版)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; box-sizing: border-box; background-color: #f0f2f5; }
        h1 { color: #1e3a5f; text-shadow: 1px 1px 2px #ccc; }
        #status-panel { width: 95vmin; max-width: 800px; background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); margin-bottom: 20px; border: 1px solid #ddd; box-sizing: border-box; }
        #status-panel p { margin: 5px 0; font-size: 14px; }
        #status-panel #connection-status { font-weight: bold; }
        .status-connected { color: #28a745; }
        .status-disconnected { color: #dc3545; }
        .status-connecting { color: #fd7e14; }
        #chart-container { width: 95vmin; height: 95vmin; max-width: 800px; max-height: 800px; background-color: #5E6E6C; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); padding: 15px; box-sizing: border-box; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>ROS 实时综合视图</h1>

    <div id="status-panel">
        <p><b>连接状态:</b> <span id="connection-status" class="status-disconnected">未连接</span></p>
        <p><b>里程计 (/odom):</b> <span id="odom-data">等待数据...</span></p>
        <p><b>地图 (/map):</b> <span id="map-data">等待数据...</span></p>
        <p><b>激光雷达 (/scan):</b> <span id="scan-data">等待数据...</span></p>
    </div>

    <div id="chart-container">
        <canvas id="mainChartCanvas"></canvas>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- 1. 统一配置 ---
    const config = {
        websocketUrl: 'ws://192.168.2.19:9090', // <-- 修改为你的 rosbridge WebSocket 地址
        viewRange: 15, // 视图范围 (米), 视图总宽度为 viewRange * 2
        trajectoryMaxLength: 200, // 轨迹最大长度
        topics: {
            // **新增了 odom 话题**
            map: { name: '/map', type: 'nav_msgs/OccupancyGrid' },
            odom: { name: '/odom', type: 'nav_msgs/Odometry' },
            scan: { name: '/scan', type: 'sensor_msgs/LaserScan' }
        }
    };

    // --- 获取DOM元素 ---
    const connectionStatusEl = document.getElementById('connection-status');
    const odomDataEl = document.getElementById('odom-data');
    const mapDataEl = document.getElementById('map-data');
    const scanDataEl = document.getElementById('scan-data');
    const ctx = document.getElementById('mainChartCanvas').getContext('2d');

    // --- 全局状态变量 ---
    let rosSocket = null;
    let mainChart = null;
    let mapImage = null; // 用于存储地图位图
    let mapInfo = {};   // 存储地图元数据
    let currentOdom = null; // **用于存储最新的机器人位姿**
    
    // --- 2. 统一的 WebSocket 连接函数 (来自第一个文件) ---
    function connect() {
        rosSocket = new WebSocket(config.websocketUrl);

        rosSocket.onopen = () => {
            console.log('成功连接到 rosbridge server。');
            connectionStatusEl.textContent = '已连接';
            connectionStatusEl.className = 'status-connected';
            subscribeToTopics();
        };

        rosSocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (!data.op || data.op !== 'publish' || !data.msg) return;

            let needsChartUpdate = false;
            switch (data.topic) {
                case config.topics.map.name:
                    handleMapData(data.msg);
                    break;
                case config.topics.odom.name:
                    handleOdomData(data.msg);
                    needsChartUpdate = true;
                    break;
                case config.topics.scan.name:
                    handleScanData(data.msg);
                    needsChartUpdate = true;
                    break;
            }
            // 收到 odom 或 scan 数据后，统一更新图表
            if (needsChartUpdate && mainChart) {
                mainChart.update('none'); // 'none' 表示无动画，性能更好
            }
        };

        rosSocket.onclose = () => {
            console.log('与 rosbridge server 的连接已断开。将在5秒后重试...');
            connectionStatusEl.textContent = '已断开 (5秒后重试)';
            connectionStatusEl.className = 'status-disconnected';
            currentOdom = null; // 断开连接时清空位姿
            setTimeout(connect, 5000);
        };

        rosSocket.onerror = (error) => {
            console.error('WebSocket 错误:', error);
            connectionStatusEl.textContent = '连接错误';
            connectionStatusEl.className = 'status-disconnected';
            rosSocket.close();
        };
        
        connectionStatusEl.textContent = '正在连接...';
        connectionStatusEl.className = 'status-connecting';
    }

    function subscribeToTopics() {
        Object.values(config.topics).forEach(topic => {
            const subscribeMsg = { op: 'subscribe', topic: topic.name, type: topic.type };
            rosSocket.send(JSON.stringify(subscribeMsg));
            console.log(`已订阅话题: ${topic.name}`);
        });
    }

    // --- 3. 数据处理函数 ---

    // 地图处理 (来自第二个文件，使用更高效的 createImageBitmap)
    function handleMapData(msg) {
        const info = msg.info;
        const mapData = msg.data;
        if (!info || !mapData || mapData.length !== info.width * info.height) return;
        
        mapInfo = info; // 保存地图信息
        mapDataEl.textContent = `已接收 ${info.width}x${info.height} 地图, 分辨率 ${info.resolution.toFixed(3)} m/pixel`;

        const offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = info.width;
        offscreenCanvas.height = info.height;
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const imageData = offscreenCtx.createImageData(info.width, info.height);
        
        for (let i = 0; i < mapData.length; i++) {
            const pixelIndex = i * 4;
            let r, g, b;
            if (mapData[i] === 0) { r = g = b = 255; } // Free
            else if (mapData[i] === 100) { r = g = b = 0; } // Occupied
            else { r = 94; g = 110; b = 108; } // Unknown
            imageData.data.set([r, g, b, 255], pixelIndex);
        }
        offscreenCtx.putImageData(imageData, 0, 0);

        createImageBitmap(offscreenCanvas).then(img => {
            mapImage = img;
            if (mainChart) mainChart.update('none'); // 地图加载后立即更新一次
        });
    }

    // **新增: 里程计数据处理**
    function handleOdomData(msg) {
        const pose = msg.pose.pose;
        // 从四元数计算偏航角 (yaw)
        const yaw = Math.atan2(2 * (pose.orientation.w * pose.orientation.z + pose.orientation.x * pose.orientation.y), 1 - 2 * (pose.orientation.y * pose.orientation.y + pose.orientation.z * pose.orientation.z));
        
        currentOdom = { x: pose.position.x, y: pose.position.y, yaw: yaw };

        odomDataEl.textContent = `X: ${currentOdom.x.toFixed(2)}m, Y: ${currentOdom.y.toFixed(2)}m, Yaw: ${(yaw * 180 / Math.PI).toFixed(1)}°`;

        if (!mainChart) return;

        // 更新机器人位置和朝向
        mainChart.data.datasets[1].data = [{ x: currentOdom.x, y: currentOdom.y }];
        mainChart.data.datasets[1].rotation = yaw * 180 / Math.PI + 90; // Chart.js三角形默认朝上，+90度校正

        // 更新轨迹
        const trajectoryData = mainChart.data.datasets[2].data;
        trajectoryData.push({ x: currentOdom.x, y: currentOdom.y });
        if (trajectoryData.length > config.trajectoryMaxLength) trajectoryData.shift();

        // **核心: 更新图表视图，使其以机器人为中心**
        mainChart.options.scales.x.min = currentOdom.x - config.viewRange;
        mainChart.options.scales.x.max = currentOdom.x + config.viewRange;
        mainChart.options.scales.y.min = currentOdom.y - config.viewRange;
        mainChart.options.scales.y.max = currentOdom.y + config.viewRange;
    }

    // **修改: 激光雷达数据处理，增加坐标转换**
    function handleScanData(msg) {
        scanDataEl.textContent = `接收到 ${msg.ranges.length} 个点, 距离范围 [${msg.range_min.toFixed(1)}m, ${msg.range_max.toFixed(2)}m]`;

        // 如果还没有里程计数据，无法转换坐标，直接返回
        if (!mainChart || !currentOdom) return;

        const points = [];
        const { ranges, angle_min, angle_increment, range_min, range_max } = msg;
        const { x: robotX, y: robotY, yaw: robotYaw } = currentOdom;

        for (let i = 0; i < ranges.length; i++) {
            const range = ranges[i];
            if (range >= range_min && range <= range_max) {
                // **核心: 将激光点的局部坐标转换为全局坐标**
                const localAngle = angle_min + i * angle_increment;
                const worldAngle = robotYaw + localAngle; // 全局角度 = 机器人朝向 + 激光点相对角度
                
                const pointX = robotX + range * Math.cos(worldAngle);
                const pointY = robotY + range * Math.sin(worldAngle);
                points.push({ x: pointX, y: pointY });
            }
        }
        mainChart.data.datasets[0].data = points;
    }
    
    // --- 4. 图表和插件 ---

    // 地图背景插件 (来自第二个文件)
    const mapBackgroundPlugin = {
        id: 'mapBackground',
        beforeDraw: (chart) => {
            if (mapImage && mapInfo.resolution) {
                const { ctx, scales } = chart;
                const { x: xScale, y: yScale } = scales;
                const mapOriginX = mapInfo.origin.position.x;
                const mapOriginY = mapInfo.origin.position.y;
                const mapWidthMeters = mapInfo.width * mapInfo.resolution;
                const mapHeightMeters = mapInfo.height * mapInfo.resolution;

                const mapLeftPx = xScale.getPixelForValue(mapOriginX);
                const mapTopPx = yScale.getPixelForValue(mapOriginY + mapHeightMeters);
                const mapWidthPx = xScale.getPixelForValue(mapOriginX + mapWidthMeters) - mapLeftPx;
                const mapHeightPx = yScale.getPixelForValue(mapOriginY) - mapTopPx;

                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(mapImage, mapLeftPx, mapTopPx, mapWidthPx, mapHeightPx);
                ctx.restore();
            }
        }
    };

    // 图表初始化
    function initializeChart() {
        mainChart = new Chart(ctx, {
            type: 'scatter',
            plugins: [mapBackgroundPlugin], // 启用地图背景插件
            data: {
                datasets: [
                    // 数据集0: LIDAR Scan
                    {
                        label: 'LIDAR Scan',
                        data: [],
                        backgroundColor: 'rgba(255, 20, 20, 0.7)',
                        pointRadius: 2,
                        showLine: false,
                        order: 1 // 绘制顺序
                    },
                    // **数据集1: Robot Position (修改后)**
                    {
                        label: 'Robot Position',
                        data: [], // 初始为空，由 aodom 更新
                        backgroundColor: 'rgba(0, 128, 255, 1)',
                        pointRadius: 8,
                        pointStyle: 'triangle', // 使用三角形表示方向
                        rotation: 0, // 初始旋转角度
                        order: 3 // 最后绘制，显示在最上层
                    },
                    // **数据集2: Trajectory (新增)**
                    {
                        label: 'Trajectory',
                        data: [],
                        borderColor: 'rgba(0, 123, 255, 0.7)',
                        borderWidth: 2,
                        pointRadius: 0, // 不显示轨迹点
                        showLine: true,
                        type: 'line', // 明确指定为线图类型
                        order: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                aspectRatio: 1,
                animation: false, // 关闭动画以提高实时性
                events: [], // 禁用鼠标事件
                plugins: {
                    legend: { display: false }
                },
                scales: {
                    x: {
                        min: -config.viewRange,
                        max: config.viewRange,
                        grid: { color: 'rgba(255, 255, 255, 0.2)' },
                        ticks: { display: false }
                    },
                    y: {
                        min: -config.viewRange,
                        max: config.viewRange,
                        grid: { color: 'rgba(255, 255, 255, 0.2)' },
                        ticks: { display: false }
                    }
                }
            }
        });
    }

    // --- 5. 启动程序 ---
    initializeChart();
    connect();
});
</script>

</body>
</html>