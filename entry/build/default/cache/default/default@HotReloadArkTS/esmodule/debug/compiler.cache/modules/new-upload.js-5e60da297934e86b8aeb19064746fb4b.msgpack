Ôr@Ÿªassertions¤code´customTransformCache¬dependencies¢id¤meta±moduleSideEffects¬originalCode±originalSourcemap«resolvedIds®sourcemapChainµsyntheticNamedExportsµtransformDependencies®transformFiles¨cacheAstÔrAÚ$h/*
 * The MIT License (MIT)
 * Copyright (C) 2023 Huawei Device Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */

'use strict';

import buildURL from '../../../lib/helpers/buildURL.js';
import settle from '../../../lib/core/settle';
import AxiosError from '../../../lib/core/AxiosError';
import buffer from '@ohos.buffer';
import util from '@ohos.util';
import { setOptions, judgeMaxContentLength } from './index';

const part = '/data/storage/';

/**
 * æ ¹æ®å·²çŸ¥æ–‡ä»¶è·¯å¾„ï¼Œè·å–æ–‡ä»¶åã€‚ä¾‹å¦‚è¾“å…¥: internal://cache/temp.jpg, è¾“å‡º: temp.jpg
 * path: æ–‡ä»¶è·¯å¾„
 */
function getFileNameByPath(path) {
    let index = path.lastIndexOf('/');
    return path.substr(index + 1);
}

/**
 * è·å– fileï¼š  nameã€contentTypeã€remoteFileNameã€dataã€ filePath
 * 1.å¦‚æœæ˜¯uriï¼ŒfilePath ç›´æ¥èµ‹å€¼
 * 2.å¦‚æœæ˜¯ArrayBufferï¼Œdata ç›´æ¥èµ‹å€¼ï¼Œè‹¥æœ‰optionç»™remoteFileNameèµ‹å€¼
 * 3.å¦‚æœæ˜¯å­—ç¬¦ï¼Œ å­˜å…¥ä¸´æ—¶å˜é‡data[]ï¼Œç„¶åç»™remoteFileName èµ‹å€¼
 * @param requestData
 * @param reject
 */
function getFileList(requestData, reject, cacheDir) {
    let files = [];
    requestData.forEach((value, key, option) => {
        if (typeof value === 'string') {
            let file = handleString(value, key, option, cacheDir);
            if (file) {
                files.push(file);
            }
        } else if (value instanceof ArrayBuffer) {
            files.push(handleArrayBuffer(value, key, option));
        } else {
            files.push({
                name: key,
                contentType: '',
                remoteFileName: '',
                data: value,
                filePath: ''
            });
        }
    });

    return { files: files, data: [] };
}

function handleString(value, key, option, cacheDir) {
    let isInternalUri = value.indexOf('internal://') === 0;
    let isPartPath = value.indexOf(part) === 0;

    if (isInternalUri || isPartPath) {
        let filename = option?.filename ?? getFileNameByPath(value);
        let type = option?.type ?? getType(filename);
        let filePath = isInternalUri
            ? `${cacheDir.split('/cache')[0]}/${value.split('internal://')[1]}`
            : value;

        return {
            name: key,
            contentType: type,
            remoteFileName: filename,
            data: '',
            filePath: filePath
        };
    }

    return {
        name: key,
        contentType: '',
        remoteFileName: '',
        data: value,
        filePath: ''
    };
}

function handleArrayBuffer(value, key, option) {
    let filename = option?.filename ?? (typeof option === 'string' ? option : `default${Date.now()}`);
    let type = option?.type ?? getType(filename);

    return {
        name: key,
        contentType: type,
        remoteFileName: filename,
        data: value,
        filePath: ''
    };
}

/**
 * æ ¹æ®å·²çŸ¥æ–‡ä»¶è·¯å¾„ï¼Œè·å–åç¼€å
 * path: æ–‡ä»¶è·¯å¾„
 */
function getType(filename) {
    let index = filename && filename.lastIndexOf('.');
    return index > -1 ? filename.substr(index) : '';
}

/**
 * htmlString: å­—ç¬¦ä¸²
 */
function isHTMLTag(htmlString) {
    // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…HTMLæ ‡ç­¾
    const tagPattern = /<[^>]+>/g; // åŒ¹é…ä»»ä½•ä¸åŒ…å«é—­åˆæ ‡ç­¾çš„æ ‡ç­¾
    // ä½¿ç”¨testæ–¹æ³•æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…
    return tagPattern.test(htmlString);
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºjsonå­—ä¸²
 */
function isValidJson(str) {
    // JSONå­—ç¬¦ä¸²å¿…é¡»ä»¥ {, [ æˆ– " å¼€å§‹ï¼Œä»¥ }, ], æˆ– " ç»“æŸï¼Œä¸”ä¸èƒ½åŒ…å«æœªé—­åˆçš„å¼•å·
    var jsonPattern = /^[\\],:{}\\s]*$/;
    // å¿½ç•¥ç©ºå­—ç¬¦ä¸²å’Œéå­—ç¬¦ä¸²
    if (str === '' || typeof str !== 'string') {
        return false;
    }
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æŸ¥
    return jsonPattern.test(str);
}

/**
 * ä¸Šä¼ 
 * @param config é…ç½®é¡¹
 * @param resolve
 * @param reject
 */
async function upload(httpConfig, resolve, reject) {
    const { httpRequest, fullPath, config } = httpConfig;
    let cacheDir = config.context?.cacheDir || '';
    let list = getFileList(config.data, reject, cacheDir);
    let options = setOptions(config, options => {
        options.multiFormDataList = list.files;
    });
    // å‘é€uploadè¯·æ±‚
    try {
        let responseHeader = {};
        let dataFul = [];
        let resultData = null;
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶äº‹ä»¶
        httpRequest.on('headersReceive', onHeadersReceive(responseHeader, config, reject, httpRequest));
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶è¿›åº¦äº‹ä»¶
        httpRequest.on('dataSendProgress', onDataSendProgress(config));
        httpRequest.on('dataReceive', onDataReceive(dataFul));
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶å®Œæ¯•äº‹ä»¶
        httpRequest.on('dataEnd', () => {
            removeEvent(httpRequest);
        });
        // å¡«å†™httpè¯·æ±‚çš„urlåœ°å€ï¼Œå¯ä»¥å¸¦å‚æ•°ä¹Ÿå¯ä»¥ä¸å¸¦å‚æ•°ã€‚URLåœ°å€éœ€è¦å¼€å‘è€…è‡ªå®šä¹‰ã€‚GETè¯·æ±‚çš„å‚æ•°å¯ä»¥åœ¨extraDataä¸­æŒ‡å®š
        let url = buildURL(fullPath, config.params, config.paramsSerializer);
        httpRequest.requestInStream(url, options, handleUploadRequest(options, responseHeader, config, reject, resolve, httpRequest, dataFul, resultData));
    } catch (err) {
        reject(new AxiosError(err, AxiosError.ERR_BAD_OPTION_VALUE, config, null, null));
    }
}

function onHeadersReceive(responseHeader, config, reject, httpRequest) {
    return (header) => {
        responseHeader.header = header;
        const totalSize = Number(header['content-length']);
        if (totalSize) {
            judgeMaxContentLength(totalSize, config, reject, httpRequest, validErrorCallback());
        }
    };
}

function validErrorCallback() {
    return (valid) => {
        // æ ¡éªŒå¤±è´¥ï¼Œç§»é™¤ç›‘å¬
        if (!valid) {
            removeEvent(httpRequest);
        }
    };
}

function onDataSendProgress(config) {
    return ({sendSize, totalSize}) => {
        if (typeof config.onUploadProgress === 'function') {
            config.onUploadProgress({
                loaded: sendSize,
                total: totalSize
            });
        }
    };
}

function onDataReceive(dataFul) {
    return (arrayBuffer) => {
        let data = buffer.from(arrayBuffer);
        dataFul.push(data);
    };
}

function handleUploadRequest(options, responseHeader, config, reject, resolve, httpRequest, dataFul, resultData) {
    return (err, data) => {
        if (responseHeader.header) {
            let fullBuffer = buffer.concat(dataFul);
            if (responseHeader.header['content-type'] === 'gzip' || responseHeader.header['content-type'] === 'application/octet-stream') {
                resultData = fullBuffer.buffer;
            } else if (options.expectDataType === 0) { // string
                resultData = fullBuffer.toString('utf8');
            } else if (options.expectDataType === 2) { // arraybuffer
                resultData = fullBuffer.buffer;
            } else { // object æˆ–è€… é»˜è®¤æ— 
                let textDecoder = util.TextDecoder.create('utf-8', { ignoreBOM: true });
                let dest = new Uint8Array(fullBuffer.buffer);
                let resStr = textDecoder.decodeWithStream(dest);
                resultData = isValidJson(resStr) ? JSON.parse(resStr) : resStr;
            }
            resultData = responseHeader.header.body ? responseHeader.header.body : resultData ? resultData : 'upload success!';
        }
        if (!err) {
            let response = {
                data: resultData,
                status: data,
                statusText: '',
                headers: responseHeader.header,
                config: config,
                request: httpRequest
            };
            settle(function _resolve(value) {
                resolve(value);
            }, function _reject(error) {
                reject(error);
            }, response);
        } else {
            removeEvent(httpRequest);
            let {message, code} = err;
            reject(new AxiosError(message || '', code || 0, config, null, null));
        }
    };
}

// ç§»é™¤ç›‘å¬
const removeEvent = (httpRequest) => {
    httpRequest.off('headersReceive');
    // å–æ¶ˆè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶äº‹ä»¶
    httpRequest.off('dataReceive');
    // å–æ¶ˆè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶è¿›åº¦äº‹ä»¶
    httpRequest.off('dataSendProgress');
    httpRequest.off('dataEnd');
    // å½“è¯¥è¯·æ±‚ä½¿ç”¨å®Œæ¯•æ—¶ï¼Œè°ƒç”¨destroyæ–¹æ³•ä¸»åŠ¨é”€æ¯
    httpRequest.destroy();
}

export default uploadÂ–Ù„D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\helpers\buildURL.jsÙD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\core\settle.jsÙƒD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\core\AxiosError.jsÙ| hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.buffer.d.tsÙz hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.util.d.tsÙ‡D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\adapters\ohos\index.jsÙˆD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\adapters\ohos\upload.jsÔrB˜±isLocalDependency¯isNodeEntryFile§pkgPath§pkgNameªpkgVersion±belongProjectPath±dependencyPkgInfo¨commonjsÂÂÙTD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios«@ohos/axios¥2.2.6ºD:\apps\deveco\tzb2025jbgsÔrC’§pkgNameªpkgVersion«@ohos/axios¥2.2.6ÔrD’°hasDefaultExportªisCommonJSÃÂÃÚ$h/*
 * The MIT License (MIT)
 * Copyright (C) 2023 Huawei Device Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */

'use strict';

import buildURL from '../../../lib/helpers/buildURL.js';
import settle from '../../../lib/core/settle';
import AxiosError from '../../../lib/core/AxiosError';
import buffer from '@ohos.buffer';
import util from '@ohos.util';
import { setOptions, judgeMaxContentLength } from './index';

const part = '/data/storage/';

/**
 * æ ¹æ®å·²çŸ¥æ–‡ä»¶è·¯å¾„ï¼Œè·å–æ–‡ä»¶åã€‚ä¾‹å¦‚è¾“å…¥: internal://cache/temp.jpg, è¾“å‡º: temp.jpg
 * path: æ–‡ä»¶è·¯å¾„
 */
function getFileNameByPath(path) {
    let index = path.lastIndexOf('/');
    return path.substr(index + 1);
}

/**
 * è·å– fileï¼š  nameã€contentTypeã€remoteFileNameã€dataã€ filePath
 * 1.å¦‚æœæ˜¯uriï¼ŒfilePath ç›´æ¥èµ‹å€¼
 * 2.å¦‚æœæ˜¯ArrayBufferï¼Œdata ç›´æ¥èµ‹å€¼ï¼Œè‹¥æœ‰optionç»™remoteFileNameèµ‹å€¼
 * 3.å¦‚æœæ˜¯å­—ç¬¦ï¼Œ å­˜å…¥ä¸´æ—¶å˜é‡data[]ï¼Œç„¶åç»™remoteFileName èµ‹å€¼
 * @param requestData
 * @param reject
 */
function getFileList(requestData, reject, cacheDir) {
    let files = [];
    requestData.forEach((value, key, option) => {
        if (typeof value === 'string') {
            let file = handleString(value, key, option, cacheDir);
            if (file) {
                files.push(file);
            }
        } else if (value instanceof ArrayBuffer) {
            files.push(handleArrayBuffer(value, key, option));
        } else {
            files.push({
                name: key,
                contentType: '',
                remoteFileName: '',
                data: value,
                filePath: ''
            });
        }
    });

    return { files: files, data: [] };
}

function handleString(value, key, option, cacheDir) {
    let isInternalUri = value.indexOf('internal://') === 0;
    let isPartPath = value.indexOf(part) === 0;

    if (isInternalUri || isPartPath) {
        let filename = option?.filename ?? getFileNameByPath(value);
        let type = option?.type ?? getType(filename);
        let filePath = isInternalUri
            ? `${cacheDir.split('/cache')[0]}/${value.split('internal://')[1]}`
            : value;

        return {
            name: key,
            contentType: type,
            remoteFileName: filename,
            data: '',
            filePath: filePath
        };
    }

    return {
        name: key,
        contentType: '',
        remoteFileName: '',
        data: value,
        filePath: ''
    };
}

function handleArrayBuffer(value, key, option) {
    let filename = option?.filename ?? (typeof option === 'string' ? option : `default${Date.now()}`);
    let type = option?.type ?? getType(filename);

    return {
        name: key,
        contentType: type,
        remoteFileName: filename,
        data: value,
        filePath: ''
    };
}

/**
 * æ ¹æ®å·²çŸ¥æ–‡ä»¶è·¯å¾„ï¼Œè·å–åç¼€å
 * path: æ–‡ä»¶è·¯å¾„
 */
function getType(filename) {
    let index = filename && filename.lastIndexOf('.');
    return index > -1 ? filename.substr(index) : '';
}

/**
 * htmlString: å­—ç¬¦ä¸²
 */
function isHTMLTag(htmlString) {
    // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…HTMLæ ‡ç­¾
    const tagPattern = /<[^>]+>/g; // åŒ¹é…ä»»ä½•ä¸åŒ…å«é—­åˆæ ‡ç­¾çš„æ ‡ç­¾
    // ä½¿ç”¨testæ–¹æ³•æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…
    return tagPattern.test(htmlString);
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºjsonå­—ä¸²
 */
function isValidJson(str) {
    // JSONå­—ç¬¦ä¸²å¿…é¡»ä»¥ {, [ æˆ– " å¼€å§‹ï¼Œä»¥ }, ], æˆ– " ç»“æŸï¼Œä¸”ä¸èƒ½åŒ…å«æœªé—­åˆçš„å¼•å·
    var jsonPattern = /^[\\],:{}\\s]*$/;
    // å¿½ç•¥ç©ºå­—ç¬¦ä¸²å’Œéå­—ç¬¦ä¸²
    if (str === '' || typeof str !== 'string') {
        return false;
    }
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æŸ¥
    return jsonPattern.test(str);
}

/**
 * ä¸Šä¼ 
 * @param config é…ç½®é¡¹
 * @param resolve
 * @param reject
 */
async function upload(httpConfig, resolve, reject) {
    const { httpRequest, fullPath, config } = httpConfig;
    let cacheDir = config.context?.cacheDir || '';
    let list = getFileList(config.data, reject, cacheDir);
    let options = setOptions(config, options => {
        options.multiFormDataList = list.files;
    });
    // å‘é€uploadè¯·æ±‚
    try {
        let responseHeader = {};
        let dataFul = [];
        let resultData = null;
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶äº‹ä»¶
        httpRequest.on('headersReceive', onHeadersReceive(responseHeader, config, reject, httpRequest));
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶è¿›åº¦äº‹ä»¶
        httpRequest.on('dataSendProgress', onDataSendProgress(config));
        httpRequest.on('dataReceive', onDataReceive(dataFul));
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶å®Œæ¯•äº‹ä»¶
        httpRequest.on('dataEnd', () => {
            removeEvent(httpRequest);
        });
        // å¡«å†™httpè¯·æ±‚çš„urlåœ°å€ï¼Œå¯ä»¥å¸¦å‚æ•°ä¹Ÿå¯ä»¥ä¸å¸¦å‚æ•°ã€‚URLåœ°å€éœ€è¦å¼€å‘è€…è‡ªå®šä¹‰ã€‚GETè¯·æ±‚çš„å‚æ•°å¯ä»¥åœ¨extraDataä¸­æŒ‡å®š
        let url = buildURL(fullPath, config.params, config.paramsSerializer);
        httpRequest.requestInStream(url, options, handleUploadRequest(options, responseHeader, config, reject, resolve, httpRequest, dataFul, resultData));
    } catch (err) {
        reject(new AxiosError(err, AxiosError.ERR_BAD_OPTION_VALUE, config, null, null));
    }
}

function onHeadersReceive(responseHeader, config, reject, httpRequest) {
    return (header) => {
        responseHeader.header = header;
        const totalSize = Number(header['content-length']);
        if (totalSize) {
            judgeMaxContentLength(totalSize, config, reject, httpRequest, validErrorCallback());
        }
    };
}

function validErrorCallback() {
    return (valid) => {
        // æ ¡éªŒå¤±è´¥ï¼Œç§»é™¤ç›‘å¬
        if (!valid) {
            removeEvent(httpRequest);
        }
    };
}

function onDataSendProgress(config) {
    return ({sendSize, totalSize}) => {
        if (typeof config.onUploadProgress === 'function') {
            config.onUploadProgress({
                loaded: sendSize,
                total: totalSize
            });
        }
    };
}

function onDataReceive(dataFul) {
    return (arrayBuffer) => {
        let data = buffer.from(arrayBuffer);
        dataFul.push(data);
    };
}

function handleUploadRequest(options, responseHeader, config, reject, resolve, httpRequest, dataFul, resultData) {
    return (err, data) => {
        if (responseHeader.header) {
            let fullBuffer = buffer.concat(dataFul);
            if (responseHeader.header['content-type'] === 'gzip' || responseHeader.header['content-type'] === 'application/octet-stream') {
                resultData = fullBuffer.buffer;
            } else if (options.expectDataType === 0) { // string
                resultData = fullBuffer.toString('utf8');
            } else if (options.expectDataType === 2) { // arraybuffer
                resultData = fullBuffer.buffer;
            } else { // object æˆ–è€… é»˜è®¤æ— 
                let textDecoder = util.TextDecoder.create('utf-8', { ignoreBOM: true });
                let dest = new Uint8Array(fullBuffer.buffer);
                let resStr = textDecoder.decodeWithStream(dest);
                resultData = isValidJson(resStr) ? JSON.parse(resStr) : resStr;
            }
            resultData = responseHeader.header.body ? responseHeader.header.body : resultData ? resultData : 'upload success!';
        }
        if (!err) {
            let response = {
                data: resultData,
                status: data,
                statusText: '',
                headers: responseHeader.header,
                config: config,
                request: httpRequest
            };
            settle(function _resolve(value) {
                resolve(value);
            }, function _reject(error) {
                reject(error);
            }, response);
        } else {
            removeEvent(httpRequest);
            let {message, code} = err;
            reject(new AxiosError(message || '', code || 0, config, null, null));
        }
    };
}

// ç§»é™¤ç›‘å¬
const removeEvent = (httpRequest) => {
    httpRequest.off('headersReceive');
    // å–æ¶ˆè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶äº‹ä»¶
    httpRequest.off('dataReceive');
    // å–æ¶ˆè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶è¿›åº¦äº‹ä»¶
    httpRequest.off('dataSendProgress');
    httpRequest.off('dataEnd');
    // å½“è¯¥è¯·æ±‚ä½¿ç”¨å®Œæ¯•æ—¶ï¼Œè°ƒç”¨destroyæ–¹æ³•ä¸»åŠ¨é”€æ¯
    httpRequest.destroy();
}

export default uploadÔrE•§version¨mappings¥names§sources®sourcesContentÜ‘”    ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”  	 ‘”  
 ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”    ‘”  ! ‘”  " ‘”  # ‘”  $ ‘”  % ‘”  & ‘”  ' ‘”  ( ‘”  ) ‘”  * ‘”  + ‘”  , ‘”  - ‘”  . ‘”  / ‘”  0 ‘”  1 ‘”  2 ‘”  3 ‘”  4 ‘”  5 ‘”  6 ‘”  7 ‘”  8 ‘”  9 ‘”  : ‘”  ; ‘”  < ‘”  = ‘”  > ‘”  ? ‘”  Ì@ ‘”  ÌA ‘”  ÌB ‘”  ÌC ‘”  ÌD ‘”  ÌE ‘”  ÌF ‘”  ÌG ‘”  ÌH ‘”  ÌI ‘”  ÌJ ‘”  ÌK ‘”  ÌL ‘”  ÌM ‘”  ÌN ‘”  ÌO ‘”  ÌP ‘”  ÌQ ‘”  ÌR ‘”  ÌS ‘”  ÌT ‘”  ÌU ‘”  ÌV ‘”  ÌW ‘”  ÌX ‘”  ÌY ‘”  ÌZ ‘”  Ì[ ‘”  Ì\ ‘”  Ì] ‘”  Ì^ ‘”  Ì_ ‘”  Ì` ‘”  Ìa ‘”  Ìb ‘”  Ìc ‘”  Ìd ‘”  Ìe ‘”  Ìf ‘”  Ìg ‘”  Ìh ‘”  Ìi ‘”  Ìj ‘”  Ìk ‘”  Ìl ‘”  Ìm ‘”  Ìn ‘”  Ìo ‘”  Ìp ‘”  Ìq ‘”  Ìr ‘”  Ìs ‘”  Ìt ‘”  Ìu ‘”  Ìv ‘”  Ìw ‘”  Ìx ‘”  Ìy ‘”  Ìz ‘”  Ì{ ‘”  Ì| ‘”  Ì} ‘”  Ì~ ‘”  Ì ‘”  Ì€ ‘”  Ì ‘”  Ì‚ ‘”  Ìƒ ‘”  Ì„ ‘”  Ì… ‘”  Ì† ‘”  Ì‡ ‘”  Ìˆ ‘”  Ì‰ ‘”  ÌŠ ‘”  Ì‹ ‘”  ÌŒ ‘”  Ì ‘”  Ì ‘”  Ì ‘”  Ì ‘”  Ì‘ ‘”  Ì’ ‘”  Ì“ ‘”  Ì” ‘”  Ì• ‘”  Ì– ‘”  Ì— ‘”  Ì˜ ‘”  Ì™ ‘”  Ìš ‘”  Ì› ‘”  Ìœ ‘”  Ì ‘”  Ì ‘”  ÌŸ ‘”  Ì  ‘”  Ì¡ ‘”  Ì¢ ‘”  Ì£ ‘”  Ì¤ ‘”  Ì¥ ‘”  Ì¦ ‘”  Ì§ ‘”  Ì¨ ‘”  Ì© ‘”  Ìª ‘”  Ì« ‘”  Ì¬ ‘”  Ì­ ‘”  Ì® ‘”  Ì¯ ‘”  Ì° ‘”  Ì± ‘”  Ì² ‘”  Ì³ ‘”  Ì´ ‘”  Ìµ ‘”  Ì¶ ‘”  Ì· ‘”  Ì¸ ‘”  Ì¹ ‘”  Ìº ‘”  Ì» ‘”  Ì¼ ‘”  Ì½ ‘”  Ì¾ ‘”  Ì¿ ‘”  ÌÀ ‘”  ÌÁ ‘”  ÌÂ ‘”  ÌÃ ‘”  ÌÄ ‘”  ÌÅ ‘”  ÌÆ ‘”  ÌÇ ‘”  ÌÈ ‘”  ÌÉ ‘”  ÌÊ ‘”  ÌË ‘”  ÌÌ ‘”  ÌÍ ‘”  ÌÎ ‘”  ÌÏ ‘”  ÌĞ ‘”  ÌÑ ‘”  ÌÒ ‘”  ÌÓ ‘”  ÌÔ ‘”  ÌÕ ‘”  ÌÖ ‘”  Ì× ‘”  ÌØ ‘”  ÌÙ ‘”  ÌÚ ‘”  ÌÛ ‘”  ÌÜ ‘”  Ìİ ‘”  ÌŞ ‘”  Ìß ‘”  Ìà ‘”  Ìá ‘”  Ìâ ‘”  Ìã ‘”  Ìä ‘”  Ìå ‘”  Ìæ ‘”  Ìç ‘”  Ìè ‘”  Ìé ‘”  Ìê ‘”  Ìë ‘”  Ìì ‘”  Ìí ‘”  Ìî ‘”  Ìï ‘”  Ìğ ‘”  Ìñ ‘”  Ìò ‘”  Ìó ‘”  Ìô ‘”  Ìõ ‘”  Ìö ‘”  Ì÷ ‘”  Ìø ‘”  Ìù ‘”  Ìú ‘”  Ìû ‘”  Ìü ‘”  Ìı ‘”  Ìş ‘”  Ìÿ ‘”  Í  ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í	 ‘”  Í
 ‘ÙˆD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\adapters\ohos\upload.js‘Ú$h/*
 * The MIT License (MIT)
 * Copyright (C) 2023 Huawei Device Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */

'use strict';

import buildURL from '../../../lib/helpers/buildURL.js';
import settle from '../../../lib/core/settle';
import AxiosError from '../../../lib/core/AxiosError';
import buffer from '@ohos.buffer';
import util from '@ohos.util';
import { setOptions, judgeMaxContentLength } from './index';

const part = '/data/storage/';

/**
 * æ ¹æ®å·²çŸ¥æ–‡ä»¶è·¯å¾„ï¼Œè·å–æ–‡ä»¶åã€‚ä¾‹å¦‚è¾“å…¥: internal://cache/temp.jpg, è¾“å‡º: temp.jpg
 * path: æ–‡ä»¶è·¯å¾„
 */
function getFileNameByPath(path) {
    let index = path.lastIndexOf('/');
    return path.substr(index + 1);
}

/**
 * è·å– fileï¼š  nameã€contentTypeã€remoteFileNameã€dataã€ filePath
 * 1.å¦‚æœæ˜¯uriï¼ŒfilePath ç›´æ¥èµ‹å€¼
 * 2.å¦‚æœæ˜¯ArrayBufferï¼Œdata ç›´æ¥èµ‹å€¼ï¼Œè‹¥æœ‰optionç»™remoteFileNameèµ‹å€¼
 * 3.å¦‚æœæ˜¯å­—ç¬¦ï¼Œ å­˜å…¥ä¸´æ—¶å˜é‡data[]ï¼Œç„¶åç»™remoteFileName èµ‹å€¼
 * @param requestData
 * @param reject
 */
function getFileList(requestData, reject, cacheDir) {
    let files = [];
    requestData.forEach((value, key, option) => {
        if (typeof value === 'string') {
            let file = handleString(value, key, option, cacheDir);
            if (file) {
                files.push(file);
            }
        } else if (value instanceof ArrayBuffer) {
            files.push(handleArrayBuffer(value, key, option));
        } else {
            files.push({
                name: key,
                contentType: '',
                remoteFileName: '',
                data: value,
                filePath: ''
            });
        }
    });

    return { files: files, data: [] };
}

function handleString(value, key, option, cacheDir) {
    let isInternalUri = value.indexOf('internal://') === 0;
    let isPartPath = value.indexOf(part) === 0;

    if (isInternalUri || isPartPath) {
        let filename = option?.filename ?? getFileNameByPath(value);
        let type = option?.type ?? getType(filename);
        let filePath = isInternalUri
            ? `${cacheDir.split('/cache')[0]}/${value.split('internal://')[1]}`
            : value;

        return {
            name: key,
            contentType: type,
            remoteFileName: filename,
            data: '',
            filePath: filePath
        };
    }

    return {
        name: key,
        contentType: '',
        remoteFileName: '',
        data: value,
        filePath: ''
    };
}

function handleArrayBuffer(value, key, option) {
    let filename = option?.filename ?? (typeof option === 'string' ? option : `default${Date.now()}`);
    let type = option?.type ?? getType(filename);

    return {
        name: key,
        contentType: type,
        remoteFileName: filename,
        data: value,
        filePath: ''
    };
}

/**
 * æ ¹æ®å·²çŸ¥æ–‡ä»¶è·¯å¾„ï¼Œè·å–åç¼€å
 * path: æ–‡ä»¶è·¯å¾„
 */
function getType(filename) {
    let index = filename && filename.lastIndexOf('.');
    return index > -1 ? filename.substr(index) : '';
}

/**
 * htmlString: å­—ç¬¦ä¸²
 */
function isHTMLTag(htmlString) {
    // æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…HTMLæ ‡ç­¾
    const tagPattern = /<[^>]+>/g; // åŒ¹é…ä»»ä½•ä¸åŒ…å«é—­åˆæ ‡ç­¾çš„æ ‡ç­¾
    // ä½¿ç”¨testæ–¹æ³•æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…
    return tagPattern.test(htmlString);
}

/**
 * åˆ¤æ–­æ˜¯å¦ä¸ºjsonå­—ä¸²
 */
function isValidJson(str) {
    // JSONå­—ç¬¦ä¸²å¿…é¡»ä»¥ {, [ æˆ– " å¼€å§‹ï¼Œä»¥ }, ], æˆ– " ç»“æŸï¼Œä¸”ä¸èƒ½åŒ…å«æœªé—­åˆçš„å¼•å·
    var jsonPattern = /^[\\],:{}\\s]*$/;
    // å¿½ç•¥ç©ºå­—ç¬¦ä¸²å’Œéå­—ç¬¦ä¸²
    if (str === '' || typeof str !== 'string') {
        return false;
    }
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æŸ¥
    return jsonPattern.test(str);
}

/**
 * ä¸Šä¼ 
 * @param config é…ç½®é¡¹
 * @param resolve
 * @param reject
 */
async function upload(httpConfig, resolve, reject) {
    const { httpRequest, fullPath, config } = httpConfig;
    let cacheDir = config.context?.cacheDir || '';
    let list = getFileList(config.data, reject, cacheDir);
    let options = setOptions(config, options => {
        options.multiFormDataList = list.files;
    });
    // å‘é€uploadè¯·æ±‚
    try {
        let responseHeader = {};
        let dataFul = [];
        let resultData = null;
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶äº‹ä»¶
        httpRequest.on('headersReceive', onHeadersReceive(responseHeader, config, reject, httpRequest));
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶è¿›åº¦äº‹ä»¶
        httpRequest.on('dataSendProgress', onDataSendProgress(config));
        httpRequest.on('dataReceive', onDataReceive(dataFul));
        // ç”¨äºè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶å®Œæ¯•äº‹ä»¶
        httpRequest.on('dataEnd', () => {
            removeEvent(httpRequest);
        });
        // å¡«å†™httpè¯·æ±‚çš„urlåœ°å€ï¼Œå¯ä»¥å¸¦å‚æ•°ä¹Ÿå¯ä»¥ä¸å¸¦å‚æ•°ã€‚URLåœ°å€éœ€è¦å¼€å‘è€…è‡ªå®šä¹‰ã€‚GETè¯·æ±‚çš„å‚æ•°å¯ä»¥åœ¨extraDataä¸­æŒ‡å®š
        let url = buildURL(fullPath, config.params, config.paramsSerializer);
        httpRequest.requestInStream(url, options, handleUploadRequest(options, responseHeader, config, reject, resolve, httpRequest, dataFul, resultData));
    } catch (err) {
        reject(new AxiosError(err, AxiosError.ERR_BAD_OPTION_VALUE, config, null, null));
    }
}

function onHeadersReceive(responseHeader, config, reject, httpRequest) {
    return (header) => {
        responseHeader.header = header;
        const totalSize = Number(header['content-length']);
        if (totalSize) {
            judgeMaxContentLength(totalSize, config, reject, httpRequest, validErrorCallback());
        }
    };
}

function validErrorCallback() {
    return (valid) => {
        // æ ¡éªŒå¤±è´¥ï¼Œç§»é™¤ç›‘å¬
        if (!valid) {
            removeEvent(httpRequest);
        }
    };
}

function onDataSendProgress(config) {
    return ({sendSize, totalSize}) => {
        if (typeof config.onUploadProgress === 'function') {
            config.onUploadProgress({
                loaded: sendSize,
                total: totalSize
            });
        }
    };
}

function onDataReceive(dataFul) {
    return (arrayBuffer) => {
        let data = buffer.from(arrayBuffer);
        dataFul.push(data);
    };
}

function handleUploadRequest(options, responseHeader, config, reject, resolve, httpRequest, dataFul, resultData) {
    return (err, data) => {
        if (responseHeader.header) {
            let fullBuffer = buffer.concat(dataFul);
            if (responseHeader.header['content-type'] === 'gzip' || responseHeader.header['content-type'] === 'application/octet-stream') {
                resultData = fullBuffer.buffer;
            } else if (options.expectDataType === 0) { // string
                resultData = fullBuffer.toString('utf8');
            } else if (options.expectDataType === 2) { // arraybuffer
                resultData = fullBuffer.buffer;
            } else { // object æˆ–è€… é»˜è®¤æ— 
                let textDecoder = util.TextDecoder.create('utf-8', { ignoreBOM: true });
                let dest = new Uint8Array(fullBuffer.buffer);
                let resStr = textDecoder.decodeWithStream(dest);
                resultData = isValidJson(resStr) ? JSON.parse(resStr) : resStr;
            }
            resultData = responseHeader.header.body ? responseHeader.header.body : resultData ? resultData : 'upload success!';
        }
        if (!err) {
            let response = {
                data: resultData,
                status: data,
                statusText: '',
                headers: responseHeader.header,
                config: config,
                request: httpRequest
            };
            settle(function _resolve(value) {
                resolve(value);
            }, function _reject(error) {
                reject(error);
            }, response);
        } else {
            removeEvent(httpRequest);
            let {message, code} = err;
            reject(new AxiosError(message || '', code || 0, config, null, null));
        }
    };
}

// ç§»é™¤ç›‘å¬
const removeEvent = (httpRequest) => {
    httpRequest.off('headersReceive');
    // å–æ¶ˆè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶äº‹ä»¶
    httpRequest.off('dataReceive');
    // å–æ¶ˆè®¢é˜…HTTPæµå¼å“åº”æ•°æ®æ¥æ”¶è¿›åº¦äº‹ä»¶
    httpRequest.off('dataSendProgress');
    httpRequest.off('dataEnd');
    // å½“è¯¥è¯·æ±‚ä½¿ç”¨å®Œæ¯•æ—¶ï¼Œè°ƒç”¨destroyæ–¹æ³•ä¸»åŠ¨é”€æ¯
    httpRequest.destroy();
}

export default uploadÔrF–¬@ohos.bufferª@ohos.utilÙ ../../../lib/helpers/buildURL.js¼../../../lib/core/AxiosError§./index¸../../../lib/core/settleÔrG—ªassertions¨external¢id¤meta±moduleSideEffectsªresolvedByµsyntheticNamedExportsAÃÙ| hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.buffer.d.tsAÃªoh-resolveÂGAÃÙz hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.util.d.tsAÃªoh-resolveÂGAÂÙ„D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\helpers\buildURL.jsAÃªoh-resolveÂGAÂÙƒD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\core\AxiosError.jsAÃªoh-resolveÂGAÂÙ‡D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\adapters\ohos\index.jsAÃªoh-resolveÂGAÂÙD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@ohos+axios@2.2.6\oh_modules\@ohos\axios\src\main\ets\components\lib\core\settle.jsAÃªoh-resolveÂ‘ÔrH’§missing¦pluginÃ¦genAbcÂÔ  ÔrI”²dynamicImportCache¹exportAllDeclarationCache»exportNamedDeclarationCache«importCache–ÔrJ•¤type¥start£endªspecifiers¦source±ImportDeclarationÍ½Íõ‘ÔrK”¤type¥start£end¥local¶ImportDefaultSpecifierÍÄÍÌÔrL”¤type¥start£end¤nameªIdentifierÍÄÍÌ¨buildURLÔrM•¤type¥start£end¥value£raw§LiteralÍÒÍôÙ ../../../lib/helpers/buildURL.jsÙ"'../../../lib/helpers/buildURL.js'J±ImportDeclarationÍ÷Í%‘K¶ImportDefaultSpecifierÍşÍLªIdentifierÍşÍ¦settleM§LiteralÍ
Í$¸../../../lib/core/settleº'../../../lib/core/settle'J±ImportDeclarationÍ'Í]‘K¶ImportDefaultSpecifierÍ.Í8LªIdentifierÍ.Í8ªAxiosErrorM§LiteralÍ>Í\¼../../../lib/core/AxiosError¾'../../../lib/core/AxiosError'J±ImportDeclarationÍ_Í‘K¶ImportDefaultSpecifierÍfÍlLªIdentifierÍfÍl¦bufferM§LiteralÍrÍ€¬@ohos.buffer®'@ohos.buffer'J±ImportDeclarationÍƒÍ¡‘K¶ImportDefaultSpecifierÍŠÍLªIdentifierÍŠÍ¤utilM§LiteralÍ”Í ª@ohos.util¬'@ohos.util'J±ImportDeclarationÍ£Íß’ÔrN•¤type¥start£end¨imported¥local¯ImportSpecifierÍ¬Í¶LªIdentifierÍ¬Í¶ªsetOptionsLªIdentifierÍ¬Í¶ªsetOptionsN¯ImportSpecifierÍ¸ÍÍLªIdentifierÍ¸ÍÍµjudgeMaxContentLengthLªIdentifierÍ¸ÍÍµjudgeMaxContentLengthM§LiteralÍÕÍŞ§./index©'./index'