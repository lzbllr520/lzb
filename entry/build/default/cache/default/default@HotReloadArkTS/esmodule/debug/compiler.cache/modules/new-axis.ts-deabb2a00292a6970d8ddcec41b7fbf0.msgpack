‘r@ü™assertions§code¥customTransformCache¨dependencies¢id§meta±moduleSideEffects¨originalCode±originalSourcemap´resolvedIdsÆsourcemapChainµsyntheticNamedExportsµtransformDependenciesÆtransformFiles®cacheAst‘rAê⁄vÊimport { doUpdate } from '../class/updater.class';
import { xAxisConfig, yAxisConfig } from '../config';
import { filterNonNumber, deepMerge, mergeSameStackData, drawTexts, drawBreakText, getIndices, px2vp } from '../util';
import { deepClone, getFormatterVal } from '../util/common';
import drawing from "@ohos.graphics.drawing";
const axisConfig = { xAxisConfig, yAxisConfig };
const { min, max, abs, pow } = Math;
let callbackSendable = null;
let font = new drawing.Font();
export async function axis(chart, option) {
    // let dataZoom = {
    //   show: false,
    //   start: 0,
    //   end: 0,
    //   num: 1
    // }
    callbackSendable = chart.sendableTestClass || {};
    let { xAxis, yAxis, series } = option;
    let allAxis = [];
    // dataZoom = chart.dataZoom
    if (xAxis && yAxis && series) {
        allAxis = getAllAxis(xAxis, yAxis);
        allAxis = mergeDefaultAxisConfig(allAxis);
        allAxis = allAxis.filter(({ show }) => show);
        allAxis = mergeDefaultBoundaryGap(allAxis);
        allAxis = calcAxisLinePosition(allAxis, chart);
        allAxis = calcAxisLabelData(allAxis, series, chart);
        allAxis = setAxisPosition(allAxis);
        allAxis = calcAxisTickPosition(allAxis, chart);
        allAxis = calcAxisNamePosition(allAxis, chart);
        allAxis = calcSplitLinePosition(allAxis, chart);
    }
    doUpdate({
        'chart': chart,
        'series': allAxis,
        'key': 'axisLine',
        'getGraphConfig': getLineConfig
    });
    // const time52 = Date.now()
    // console.log('Êó∂Èó¥5.2', time52-time51)
    doUpdate({
        chart,
        series: allAxis,
        key: 'axisTick',
        getGraphConfig: getTickConfig
    });
    // const time53 = Date.now()
    // console.log('Êó∂Èó¥5.3', time53-time52)
    doUpdate({
        chart,
        series: allAxis,
        key: 'axisLabel',
        getGraphConfig: getLabelConfig
    });
    // const time54 = Date.now()
    // console.log('Êó∂Èó¥5.4', time54-time53)
    doUpdate({
        chart,
        series: allAxis,
        key: 'axisName',
        getGraphConfig: getNameConfig
    });
    // const time55 = Date.now()
    // console.log('Êó∂Èó¥5.5', time55-time54)
    doUpdate({
        chart,
        series: allAxis,
        key: 'splitLine',
        getGraphConfig: getSplitLineConfig
    });
    // await Promise.all([
    //   doUpdate({
    //     'chart': chart,
    //     'series': allAxis,
    //     'key': 'axisLine',
    //     'getGraphConfig': getLineConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'axisTick',
    //     getGraphConfig: getTickConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'axisLabel',
    //     getGraphConfig: getLabelConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'axisName',
    //     getGraphConfig: getNameConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'splitLine',
    //     getGraphConfig: getSplitLineConfig
    //   })
    // ]);
    chart.axisData = allAxis;
}
function asyncTask(callBack) {
    return callBack();
}
function getAllAxis(xAxis, yAxis) {
    let [allXAxis, allYAxis] = [[], []];
    if (xAxis instanceof Array) {
        allXAxis.push(...xAxis);
    }
    else {
        allXAxis.push(xAxis);
    }
    if (yAxis instanceof Array) {
        allYAxis.push(...yAxis);
    }
    else {
        allYAxis.push(yAxis);
    }
    allXAxis.splice(2);
    allYAxis.splice(2);
    allXAxis = allXAxis.map((axis, i) => ({ ...axis, index: i, axis: 'x' }));
    allYAxis = allYAxis.map((axis, i) => ({ ...axis, index: i, axis: 'y' }));
    return [...allXAxis, ...allYAxis];
}
function mergeDefaultAxisConfig(allAxis) {
    let xAxis = allAxis.filter(({ axis }) => axis === 'x');
    let yAxis = allAxis.filter(({ axis }) => axis === 'y');
    xAxis = xAxis.map(axis => deepMerge(deepClone(xAxisConfig), axis));
    yAxis = yAxis.map(axis => deepMerge(deepClone(yAxisConfig), axis));
    return [...xAxis, ...yAxis];
}
function mergeDefaultBoundaryGap(allAxis) {
    const valueAxis = allAxis.filter(({ type }) => type === 'value');
    const labelAxis = allAxis.filter(({ type }) => type !== 'value');
    valueAxis.forEach(axis => {
        if (typeof axis.boundaryGap === 'boolean')
            return;
        axis.boundaryGap = false;
    });
    labelAxis.forEach(axis => {
        if (typeof axis.boundaryGap === 'boolean')
            return;
        axis.boundaryGap = true;
    });
    return [...valueAxis, ...labelAxis];
}
function calcAxisLabelData(allAxis, series, chart) {
    const { dataZoom } = chart;
    let valueAxis = allAxis.filter(({ type }) => type === 'value');
    let labelAxis = allAxis.filter(({ data }) => data instanceof Array);
    valueAxis = calcValueAxisLabelData(valueAxis, series, dataZoom);
    labelAxis = calcLabelAxisLabelData(labelAxis, dataZoom);
    return [...valueAxis, ...labelAxis];
}
function calcValueAxisLabelData(valueAxis, series, dataZoom) {
    return valueAxis.map(axis => {
        const minMaxValue = getValueAxisMaxMinValue(axis, series, dataZoom);
        const [min, max] = getTrueMinMax(axis, minMaxValue);
        const interval = getValueInterval(min, max, axis);
        const { axisLabel: { formatter } } = axis;
        let label = [];
        if (min < 0 && max > 0) {
            label = getValueAxisLabelFromZero(min, max, interval, axis);
        }
        else {
            label = getValueAxisLabelFromMin(min, max, interval);
        }
        label = label.map(l => parseFloat(l.toFixed(2)));
        return {
            ...axis,
            labelData: label,
            maxValue: label.slice(-1)[0],
            minValue: label[0],
            label: getAfterFormatterLabel(dataZoom, label, formatter)
        };
    });
}
// // Êù•ËÆ°ÁÆóÁªôÂÆöÊï∞ÁªÑ‰∏≠ÊØèÂØπËøûÁª≠ÂÖÉÁ¥†‰πãÈó¥ÁöÑÂ∑ÆÂÄº
// function calculateDifferences(arr) {
//   let differences = [];
//   for (let i = 0; i < arr.length - 1; i++) {
//     differences.push(Number(arr[i + 1]) - Number(arr[i]));
//   }
//   return differences;
// }
function getValueAxisMaxMinValue(axis, series, dataZoom) {
    series = series.filter(({ show, type }) => {
        if (show === false)
            return false;
        if (type === 'pie')
            return false;
        return true;
    });
    if (series.length === 0)
        return [0, 0];
    const { index, axis: axisType } = axis;
    series = mergeStackData(series, dataZoom);
    const axisName = axisType + 'Axis';
    let valueSeries = series.filter(s => s[axisName] === index);
    if (!valueSeries.length)
        valueSeries = series;
    return getSeriesMinMaxValue(valueSeries, dataZoom);
}
function getSeriesMinMaxValue(series, dataZoom) {
    if (!series)
        return;
    const dataZoomValue = function (data) {
        if (dataZoom && dataZoom.show) {
            data = data.filter((item, i) => (i >= dataZoom.start && i <= dataZoom.end));
        }
        return data;
    };
    let seriesData = [];
    series
        .map(({ data }) => {
        if (data && data.length) {
            // data = dataZoomValue(data)
            seriesData = [...seriesData, ...filterNonNumber(data)];
        }
        else {
            seriesData = [...seriesData, 0];
        }
    });
    const minValue = Math.min(...seriesData, 0);
    const maxValue = Math.max(...seriesData, 10);
    return [minValue, maxValue];
}
function mergeStackData(series, dataZoom) {
    const seriesCloned = JSON.parse(JSON.stringify(series));
    seriesCloned.forEach((item, i) => {
        if (dataZoom && dataZoom.show) {
            item.data = item.data.slice(dataZoom.start, dataZoom.end + 1);
        }
        const data = mergeSameStackData(item, series);
        item.data = data;
    });
    return seriesCloned;
}
function getTrueMinMax(axisJson, minMaxValue) {
    let { min, max, axis, splitNumber } = axisJson;
    let [minValue, maxValue] = minMaxValue;
    if (min === null) {
        min = '20%';
    }
    if (max === null) {
        max = '20%';
    }
    let [minType, maxType] = [typeof min, typeof max];
    if (!testMinMaxType(min)) {
        min = axisConfig[axis + 'AxisConfig'].min;
        minType = 'string';
    }
    if (!testMinMaxType(max)) {
        max = axisConfig[axis + 'AxisConfig'].max;
        maxType = 'string';
    }
    if (minType === 'string') {
        min = Number(String(minValue - abs(minValue * parseFloat(min) / 100)));
        const lever = getValueLever(min);
        min = Math.min(parseFloat((min / lever).toFixed(1)) * lever, 0);
        min = Math.floor(min / splitNumber) * splitNumber;
    }
    if (maxType === 'string') {
        max = Number(maxValue + abs(maxValue * parseFloat(max) / 100));
        const lever = getValueLever(max);
        max = parseFloat((max / lever).toFixed(1)) * lever;
        max = Math.ceil(max / splitNumber) * splitNumber;
    }
    return [min, max];
}
function getValueLever(value) {
    const valueString = abs(parseInt(value)).toString();
    const valueLength = valueString.length;
    const firstZeroIndex = valueString.replace(/0*$/g, '').indexOf('0');
    let pow10Num = valueLength - 1;
    if (firstZeroIndex !== -1)
        pow10Num -= firstZeroIndex;
    return pow(10, pow10Num);
}
function testMinMaxType(val) {
    const valType = typeof val;
    const isValidString = (valType === 'string' && /^\d+%$/.test(val));
    const isValidNumber = valType === 'number';
    return isValidString || isValidNumber;
}
function getValueAxisLabelFromZero(min, max, interval, axis) {
    let [negative, positive] = [[], []];
    let [currentNegative, currentPositive] = [0, 0];
    do {
        currentNegative -= interval;
        if (axis.min) {
            currentNegative = Math.max(min, currentNegative);
        }
        negative.push(currentNegative);
    } while (currentNegative > min);
    do {
        currentPositive += interval;
        if (axis.max) {
            currentPositive = Math.min(max, currentPositive);
        }
        positive.push(currentPositive);
    } while (currentPositive < max);
    return [...negative.reverse(), 0, ...positive];
}
function getValueAxisLabelFromMin(min, max, interval) {
    let [label, currentValue] = [[min], min];
    do {
        currentValue += interval;
        label.push(Math.min(currentValue, max));
    } while (currentValue < max);
    return label;
}
function getAfterFormatterLabel(dataZoom, label, formatter, type = 'val') {
    if (!formatter) {
        return getDataZoomLabel(type, label, dataZoom);
    }
    label = getDataZoomLabel(type, label, dataZoom);
    if (typeof formatter === 'string')
        label = label.map(l => getFormatterVal(callbackSendable, formatter, l));
    if (typeof formatter === 'function')
        label = label.map((value, index) => formatter(value, dataZoom && dataZoom.show ? dataZoom.start + index : index));
    return label;
}
function getDataZoomLabel(type, label, dataZoom) {
    if (dataZoom && dataZoom.show && type === 'label') {
        label = label.slice(dataZoom.start, dataZoom.end + 1);
    }
    return label;
}
function calcLabelAxisLabelData(labelAxis, dataZoom) {
    return labelAxis.map(axis => {
        const { data, axisLabel: { formatter } } = axis;
        return Object.assign({}, axis, { label: getAfterFormatterLabel(dataZoom, data, formatter, 'label') });
    });
}
function getValueInterval(min, max, axis) {
    let { interval, minInterval, maxInterval, splitNumber, axis: axisType } = axis;
    const config = axisConfig[axisType + 'AxisConfig'];
    if (typeof interval !== 'number')
        interval = config.interval;
    if (typeof minInterval !== 'number')
        minInterval = config.minInterval;
    if (typeof maxInterval !== 'number')
        maxInterval = config.maxInterval;
    if (typeof splitNumber !== 'number')
        splitNumber = config.splitNumber;
    if (typeof interval === 'number')
        return interval;
    let valueInterval = parseInt(String((max - min) / (splitNumber)));
    // if (valueInterval.toString().length > 1) valueInterval = parseInt(valueInterval.toString().replace(/\d$/, '0'))
    if (valueInterval === 0)
        valueInterval = 1;
    if (typeof minInterval === 'number' && valueInterval < minInterval)
        return minInterval;
    if (typeof maxInterval === 'number' && valueInterval > maxInterval)
        return maxInterval;
    return valueInterval;
}
function setAxisPosition(allAxis) {
    const xAxis = allAxis.filter(({ axis }) => axis === 'x');
    const yAxis = allAxis.filter(({ axis }) => axis === 'y');
    if (xAxis[0] && !xAxis[0].position)
        xAxis[0].position = xAxisConfig.position;
    if (xAxis[1] && !xAxis[1].position) {
        xAxis[1].position = xAxis[0].position === 'bottom' ? 'top' : 'bottom';
    }
    if (yAxis[0] && !yAxis[0].position)
        yAxis[0].position = yAxisConfig.position;
    if (yAxis[1] && !yAxis[1].position) {
        yAxis[1].position = yAxis[0].position === 'left' ? 'right' : 'left';
    }
    return [...xAxis, ...yAxis];
}
function calcAxisLinePosition(allAxis, chart) {
    const { x, y, w, h } = chart.gridArea;
    allAxis = allAxis.map(axis => {
        const { position } = axis;
        let linePosition = [];
        if (position === 'left') {
            linePosition = [[x, y], [x, y + h]].reverse();
        }
        else if (position === 'right') {
            linePosition = [[x + w, y], [x + w, y + h]].reverse();
        }
        else if (position === 'top') {
            linePosition = [[x, y], [x + w, y]];
        }
        else if (position === 'bottom') {
            linePosition = [[x, y + h], [x + w, y + h]];
        }
        return {
            ...axis,
            linePosition
        };
    });
    return allAxis;
}
function calcAxisTickPosition(allAxis, chart) {
    const { render, dataZoom } = chart;
    return allAxis.map((axisItem) => {
        let { type, axis, linePosition, position, label, labelData, max, min, boundaryGap, axisTick, minValue, maxValue, axisLabel: { formatter, style, interval, overflow, fontSize, width } } = axisItem;
        if (typeof boundaryGap !== 'boolean')
            boundaryGap = axisConfig[axis + 'AxisConfig'].boundaryGap;
        let labelNum = label.length;
        const [[startX, startY], [endX, endY]] = linePosition;
        const gapLength = axis === 'x' ? endX - startX : endY - startY;
        let gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1);
        const ratio = (maxValue - minValue) === 0 ? (abs(gapLength) / (maxValue - minValue)) : 0;
        // Â¶ÇÊûúÊòØÊªöÂä®Ê®°Âºè, ‰∏îxËΩ¥
        if (type === 'data' && dataZoom && dataZoom.show) {
            labelNum = Math.min(dataZoom.num, labelNum);
            gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1);
            axisItem.dataZoom = dataZoom;
        }
        else {
            axisItem.dataZoom = {};
        }
        const tickPosition = new Array(labelNum)
            .fill(0)
            .map((foo, i) => {
            if (axis === 'x') {
                if (type === 'data') {
                    return [startX + gap * (boundaryGap ? (i + 0.5) : i), startY];
                }
                else {
                    return [startX + (labelData[i] - minValue) * ratio, startY];
                }
            }
            if (type === 'data') {
                return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)];
            }
            else {
                if (min !== null || max !== null) {
                    return [startX, startY - (labelData[i] - minValue) * ratio];
                }
                else {
                    return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)];
                }
            }
        });
        if (type === 'data') {
            if (overflow && overflow !== 'none') {
                let overflowW = width ? width : axis === 'x' ? gap : startX;
                // ËÆ°ÁÆóÂΩìÂâçÊñáÊú¨ÊòØÂê¶ÈúÄË¶ÅËÆæÁΩÆËá™Âä®Êç¢Ë°åÊàñËÄÖÊà™Âèñ
                axisItem.label = label.map((labelItem, index) => {
                    // ctx.font = `${fontSize}px`;
                    font.setSize(fontSize);
                    labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem);
                    let textI = labelItem.length;
                    if (overflow === 'truncate') {
                        textI = drawTexts(font, labelItem, overflowW);
                        labelItem = labelItem.substring(0, textI) + (textI !== labelItem.length ? '...' : '');
                    }
                    else if (overflow === 'breakAll') {
                        labelItem = drawBreakText(font, labelItem, overflowW);
                    }
                    return labelItem;
                });
            }
            // ËÆ°ÁÆóÊòØÂê¶ÈúÄË¶ÅÈó¥ÈöîÊòæÁ§∫
            interval = interval === null ? 'auto' : interval;
            if (interval === 'auto') {
                let labelTotalW = 0;
                let maxNum = 0;
                let maxText = '';
                axisItem.label.forEach((labelItem, index) => {
                    labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem);
                    if (labelItem.length > maxNum) {
                        maxNum = labelItem.length;
                        maxText = labelItem;
                    }
                });
                font.setSize(fontSize);
                const txtW = px2vp(font.measureText(String(maxText), drawing.TextEncoding.TEXT_ENCODING_UTF8));
                labelTotalW = txtW * axisItem.label.length;
                let flag = (txtW > gap) || (labelTotalW > gapLength);
                // axisItem.label.forEach((labelItem, index) => {
                //   ctx.font = `${fontSize}px`;
                //   labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
                //   // const txtW = ctx.measureText(labelItem).width; // Ëé∑ÂèñÊñáÂ≠óÁöÑÈïøÂ∫¶
                //   // const txtW = MeasureText.measureText({ // Âª∫ËÆÆ‰ΩøÁî® this.getUIContext().getMeasureUtils().measureText()Êé•Âè£
                //   //   textContent: labelItem,
                //   //   fontSize: `${fontSize}px`
                //   // }); // Ëé∑ÂèñÊñáÂ≠óÁöÑÈïøÂ∫¶
                //   font.setSize(fontSize);
                //   const txtW = px2vp(font.measureText(labelItem, drawing.TextEncoding.TEXT_ENCODING_UTF8))
                //   // console.log('txtW', px2vp(txtW))
                //   if (txtW > gap) {
                //     flag = true
                //   }
                //   labelTotalW += txtW
                // })
                // return result;
                if (flag) {
                    interval = Math.max(Math.round(labelTotalW / (gapLength)), 1);
                }
            }
        }
        // console.log('interval', interval)
        if (!isNaN(interval)) {
            let indices = getIndices(0, axisItem.label.length, interval);
            // if (dataZoom.show && type === 'data' &&  axis === 'x') {
            //   indices = getIndices(dataZoom.start, dataZoom.num, interval)
            // }
            // console.log('indicesindices1', JSON.stringify(indices), axis, JSON.stringify(axisItem.label))
            axisItem.label = axisItem.label.map((item, index) => {
                if (!indices.includes(index)) {
                    item = '';
                }
                return item;
            });
        }
        const tickLinePosition = getTickLinePosition(axis, boundaryGap, position, tickPosition, gap, axisTick);
        return {
            ...axisItem,
            tickPosition,
            tickLinePosition,
            tickGap: gap
        };
    });
}
function getTickLinePosition(axisType, boundaryGap, position, tickPosition, gap, axisTick) {
    let index = axisType === 'x' ? 1 : 0;
    let { length: plus = 5 } = axisTick;
    // let plus = 10
    if (axisType === 'x' && position === 'top')
        plus = -5;
    if (axisType === 'y' && position === 'left')
        plus = -5;
    let tickLinePosition = tickPosition.map(lineStart => {
        const lineEnd = deepClone(lineStart);
        lineEnd[index] += plus;
        return [deepClone(lineStart), lineEnd];
    });
    if (!boundaryGap)
        return tickLinePosition;
    index = axisType === 'x' ? 0 : 1;
    plus = gap / 2;
    tickLinePosition.forEach(([lineStart, lineEnd]) => {
        lineStart[index] += plus;
        lineEnd[index] += plus;
    });
    return tickLinePosition;
}
function calcAxisNamePosition(allAxis, chart) {
    return allAxis.map(axisItem => {
        let { nameGap, nameLocation, position, linePosition } = axisItem;
        const [lineStart, lineEnd] = linePosition;
        let namePosition = [...lineStart];
        if (nameLocation === 'end')
            namePosition = [...lineEnd];
        if (nameLocation === 'center') {
            namePosition[0] = (lineStart[0] + lineEnd[0]) / 2;
            namePosition[1] = (lineStart[1] + lineEnd[1]) / 2;
        }
        let index = 0;
        if (position === 'top' && nameLocation === 'center')
            index = 1;
        if (position === 'bottom' && nameLocation === 'center')
            index = 1;
        if (position === 'left' && nameLocation !== 'center')
            index = 1;
        if (position === 'right' && nameLocation !== 'center')
            index = 1;
        let plus = nameGap;
        if (position === 'top' && nameLocation !== 'end')
            plus *= -1;
        if (position === 'left' && nameLocation !== 'start')
            plus *= -1;
        if (position === 'bottom' && nameLocation === 'start')
            plus *= -1;
        if (position === 'right' && nameLocation === 'end')
            plus *= -1;
        namePosition[index] += plus;
        return {
            ...axisItem,
            namePosition
        };
    });
}
function calcSplitLinePosition(allAxis, chart) {
    const { w, h } = chart.gridArea;
    return allAxis.map(axisItem => {
        const { tickLinePosition, position, boundaryGap } = axisItem;
        let [index, plus] = [0, w];
        if (position === 'top' || position === 'bottom')
            index = 1;
        if (position === 'top' || position === 'bottom')
            plus = h;
        if (position === 'right' || position === 'bottom')
            plus *= -1;
        const splitLinePosition = tickLinePosition.map(([startPoint]) => {
            const endPoint = [...startPoint];
            endPoint[index] += plus;
            return [[...startPoint], endPoint];
        });
        if (!boundaryGap)
            splitLinePosition.shift();
        return {
            ...axisItem,
            splitLinePosition
        };
    });
}
function getLineConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    return [{
            name: 'polyline',
            index: rLevel,
            visible: axisItem.axisLine.show,
            animationCurve,
            animationFrame: 0,
            shape: getLineShape(axisItem),
            style: getLineStyle(axisItem)
        }];
}
function getLineShape(axisItem) {
    const { linePosition } = axisItem;
    return {
        points: linePosition
    };
}
function getLineStyle(axisItem) {
    setLineWidth(axisItem.axisLine.lineStyle);
    return axisItem.axisLine.lineStyle;
}
function getTickConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    const shapes = getTickShapes(axisItem);
    const style = getTickStyle(axisItem);
    return shapes.map(shape => ({
        name: 'polyline',
        index: rLevel,
        visible: axisItem.axisTick.show,
        animationCurve,
        animationFrame: 0,
        shape,
        style
    }));
}
function getTickShapes(axisItem) {
    const { tickLinePosition } = axisItem;
    return tickLinePosition.map(points => ({ points }));
}
function getTickStyle(axisItem) {
    setLineWidth(axisItem.axisTick.lineStyle);
    return axisItem.axisTick.lineStyle;
}
function getLabelConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel, axis, dataZoom } = axisItem;
    const shapes = getLabelShapes(axisItem);
    const styles = getLabelStyle(axisItem, shapes);
    return shapes.map((shape, i) => {
        let visible = shape.content && axisItem.axisLabel.show;
        // if (dataZoom.show) {
        //   visible = i >= dataZoom.start && i <= dataZoom.end
        // }
        return {
            name: 'text',
            index: rLevel,
            visible,
            animationCurve,
            animationFrame: 0,
            shape,
            style: styles[i],
            setGraphCenter: () => (void 0)
        };
    });
}
function getLabelShapes(axisItem) {
    const { label, tickPosition, position, axisLabel, axisTick } = axisItem;
    return tickPosition.map((point, i) => ({
        position: getLabelRealPosition(point, position, axisLabel, axisTick),
        content: label[i].toString(),
    }));
}
function getLabelRealPosition(points, position, axisLabel, axisTick) {
    let { margin: plus = 10 } = axisLabel;
    let { length } = axisTick;
    let index = 0;
    if (position === 'top' || position === 'bottom')
        index = 1;
    if (position === 'top' || position === 'left')
        plus *= -1;
    if (position === 'top' || position === 'left')
        length *= -1;
    points = deepClone(points);
    points[index] += (plus + length);
    return points;
}
function getLabelStyle(axisItem, shapes) {
    const { position } = axisItem;
    let { color, fontSize, rotate, fontWeight, fontFamily, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY } = axisItem.axisLabel;
    let style = {
        fill: color,
        fontSize,
        rotate,
        fontWeight,
        fontFamily,
        shadowColor,
        shadowBlur,
        shadowOffsetX,
        shadowOffsetY
    };
    const align = getAxisLabelRealAlign(position);
    style = deepMerge(align, style);
    const styles = shapes.map(({ position }) => ({
        ...style,
        graphCenter: position
    }));
    return styles;
}
function getAxisLabelRealAlign(position) {
    if (position === 'left')
        return {
            textAlign: 'right',
            textBaseline: 'middle'
        };
    if (position === 'right')
        return {
            textAlign: 'left',
            textBaseline: 'middle'
        };
    if (position === 'top')
        return {
            textAlign: 'center',
            textBaseline: 'bottom'
        };
    if (position === 'bottom')
        return {
            textAlign: 'center',
            textBaseline: 'top'
        };
}
function getNameConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    return [{
            name: 'text',
            index: rLevel,
            animationCurve,
            animationFrame: 0,
            shape: getNameShape(axisItem),
            style: getNameStyle(axisItem)
        }];
}
function getNameShape(axisItem) {
    const { name, namePosition } = axisItem;
    return {
        content: name,
        position: namePosition
    };
}
function getNameStyle(axisItem) {
    const { nameLocation, position, nameTextStyle: style } = axisItem;
    const align = getNameRealAlign(position, nameLocation);
    // style.fill = style.color
    return deepMerge(align, {
        fill: style.color,
        fontWeight: style.fontWeight,
        fontFamily: style.fontFamily,
        fontSize: style.fontSize
    });
}
function getNameRealAlign(position, location) {
    if ((position === 'top' && location === 'start') ||
        (position === 'bottom' && location === 'start') ||
        (position === 'left' && location === 'center'))
        return {
            textAlign: 'right',
            textBaseline: 'middle'
        };
    if ((position === 'top' && location === 'end') ||
        (position === 'bottom' && location === 'end') ||
        (position === 'right' && location === 'center'))
        return {
            textAlign: 'left',
            textBaseline: 'middle'
        };
    if ((position === 'top' && location === 'center') ||
        (position === 'left' && location === 'end') ||
        (position === 'right' && location === 'end'))
        return {
            textAlign: 'center',
            textBaseline: 'bottom'
        };
    if ((position === 'bottom' && location === 'center') ||
        (position === 'left' && location === 'start') ||
        (position === 'right' && location === 'start'))
        return {
            textAlign: 'center',
            textBaseline: 'top'
        };
}
function getSplitLineConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    const shapes = getSplitLineShapes(axisItem);
    const style = getSplitLineStyle(axisItem);
    return shapes.map(shape => ({
        name: 'polyline',
        index: rLevel,
        visible: axisItem.splitLine.show,
        animationCurve,
        animationFrame: 0,
        shape,
        style
    }));
}
function getSplitLineShapes(axisItem) {
    const { splitLinePosition } = axisItem;
    return splitLinePosition.map(points => ({ points }));
}
function getSplitLineStyle(axisItem) {
    setLineWidth(axisItem.splitLine.lineStyle);
    return axisItem.splitLine.lineStyle;
}
function setLineWidth(data) {
    data.lineWidth = data.width;
}
//# sourceMappingURL=axis.js.map¬ïŸÖD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\class\updater.class.tsŸ~D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\config\index.tsŸ|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\index.tsŸ}D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\common.tsŸÜ hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.graphics.drawing.d.tsŸ{D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\core\axis.ts‘rBò±isLocalDependencyØisNodeEntryFileßpkgPathßpkgName™pkgVersion±belongProjectPath±dependencyPkgInfo¨shouldEmitJs¬¬ŸZD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mcchartsÆ@mcui/mccharts•2.8.9∫D:\apps\deveco\tzb2025jbgs‘rCíßpkgName™pkgVersionÆ@mcui/mccharts•2.8.9√√⁄gÑimport { doUpdate } from '../class/updater.class'

import { xAxisConfig, yAxisConfig } from '../config'

import { filterNonNumber, deepMerge, mergeSameStackData, drawTexts, drawBreakText, getIndices, px2vp } from '../util'

import { deepClone, getFormatterVal } from '../util/common'
import { drawing } from '@kit.ArkGraphics2D';
const axisConfig = { xAxisConfig, yAxisConfig }

const { min, max, abs, pow } = Math

let callbackSendable = null
let font = new drawing.Font();
export async function axis (chart, option?) {
  // let dataZoom = {
  //   show: false,
  //   start: 0,
  //   end: 0,
  //   num: 1
  // }

  callbackSendable = chart.sendableTestClass || {}
  let { xAxis, yAxis, series } = option
  let allAxis = []
  // dataZoom = chart.dataZoom
  if (xAxis && yAxis && series) {
    allAxis = getAllAxis(xAxis, yAxis)
    allAxis = mergeDefaultAxisConfig(allAxis)
    allAxis = allAxis.filter(({ show }) => show)
    allAxis = mergeDefaultBoundaryGap(allAxis)
    allAxis = calcAxisLinePosition(allAxis, chart)
    allAxis = calcAxisLabelData(allAxis, series, chart)
    allAxis = setAxisPosition(allAxis)
    allAxis = calcAxisTickPosition(allAxis, chart)
    allAxis = calcAxisNamePosition(allAxis, chart)
    allAxis = calcSplitLinePosition(allAxis, chart)
  }


  doUpdate({
    'chart': chart,
    'series': allAxis,
    'key': 'axisLine',
    'getGraphConfig': getLineConfig
  })
  // const time52 = Date.now()
  // console.log('Êó∂Èó¥5.2', time52-time51)
  doUpdate({
    chart,
    series: allAxis,
    key: 'axisTick',
    getGraphConfig: getTickConfig
  })
  // const time53 = Date.now()
  // console.log('Êó∂Èó¥5.3', time53-time52)
  doUpdate({
    chart,
    series: allAxis,
    key: 'axisLabel',
    getGraphConfig: getLabelConfig
  })
  // const time54 = Date.now()
  // console.log('Êó∂Èó¥5.4', time54-time53)
  doUpdate({
    chart,
    series: allAxis,
    key: 'axisName',
    getGraphConfig: getNameConfig
  })
  // const time55 = Date.now()
  // console.log('Êó∂Èó¥5.5', time55-time54)
  doUpdate({
    chart,
    series: allAxis,
    key: 'splitLine',
    getGraphConfig: getSplitLineConfig
  })

  // await Promise.all([
  //   doUpdate({
  //     'chart': chart,
  //     'series': allAxis,
  //     'key': 'axisLine',
  //     'getGraphConfig': getLineConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'axisTick',
  //     getGraphConfig: getTickConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'axisLabel',
  //     getGraphConfig: getLabelConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'axisName',
  //     getGraphConfig: getNameConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'splitLine',
  //     getGraphConfig: getSplitLineConfig
  //   })
  // ]);
  chart.axisData = allAxis
}

function asyncTask(callBack) {
  return callBack();
}

function getAllAxis (xAxis, yAxis) {
  let [allXAxis, allYAxis] = [[], []]

  if (xAxis instanceof Array) {
    allXAxis.push(...xAxis)
  } else {
    allXAxis.push(xAxis)
  }

  if (yAxis instanceof Array) {
    allYAxis.push(...yAxis)
  } else {
    allYAxis.push(yAxis)
  }

  allXAxis.splice(2)
  allYAxis.splice(2)

  allXAxis = allXAxis.map((axis, i) => ({ ...axis, index: i, axis: 'x' }))
  allYAxis = allYAxis.map((axis, i) => ({ ...axis, index: i, axis: 'y' }))

  return [...allXAxis, ...allYAxis]
}

function mergeDefaultAxisConfig (allAxis) {
  let xAxis = allAxis.filter(({ axis }) => axis === 'x')
  let yAxis = allAxis.filter(({ axis }) => axis === 'y')

  xAxis = xAxis.map(axis => deepMerge(deepClone(xAxisConfig), axis))
  yAxis = yAxis.map(axis => deepMerge(deepClone(yAxisConfig), axis))

  return [...xAxis, ...yAxis]
}

function mergeDefaultBoundaryGap (allAxis) {
  const valueAxis = allAxis.filter(({ type }) => type === 'value')
  const labelAxis = allAxis.filter(({ type }) => type !== 'value')

  valueAxis.forEach(axis => {
    if (typeof axis.boundaryGap === 'boolean') return

    axis.boundaryGap = false
  })
  labelAxis.forEach(axis => {
    if (typeof axis.boundaryGap === 'boolean') return

    axis.boundaryGap = true
  })

  return [...valueAxis, ...labelAxis]
}

function calcAxisLabelData (allAxis, series, chart) {
  const { dataZoom } = chart
  let valueAxis = allAxis.filter(({ type }) => type === 'value')
  let labelAxis = allAxis.filter(({ data }) => data instanceof Array)

  valueAxis = calcValueAxisLabelData(valueAxis, series, dataZoom)
  labelAxis = calcLabelAxisLabelData(labelAxis, dataZoom)
  return [...valueAxis, ...labelAxis]
}

function calcValueAxisLabelData (valueAxis, series, dataZoom) {
  return valueAxis.map(axis => {

    const minMaxValue = getValueAxisMaxMinValue(axis, series, dataZoom)
    const [min, max] = getTrueMinMax(axis, minMaxValue)
    const interval = getValueInterval(min, max, axis)
    const { axisLabel: { formatter } } = axis

    let label = []

    if (min < 0 && max > 0) {
      label = getValueAxisLabelFromZero(min, max, interval, axis)
    } else {
      label = getValueAxisLabelFromMin(min, max, interval)
    }

    label = label.map(l => parseFloat(l.toFixed(2)))
    return {
      ...axis,
      labelData: label,
      maxValue: label.slice(-1)[0],
      minValue: label[0],
      label: getAfterFormatterLabel(dataZoom, label, formatter)
    }
  })
}

// // Êù•ËÆ°ÁÆóÁªôÂÆöÊï∞ÁªÑ‰∏≠ÊØèÂØπËøûÁª≠ÂÖÉÁ¥†‰πãÈó¥ÁöÑÂ∑ÆÂÄº
// function calculateDifferences(arr) {
//   let differences = [];
//   for (let i = 0; i < arr.length - 1; i++) {
//     differences.push(Number(arr[i + 1]) - Number(arr[i]));
//   }
//   return differences;
// }


function getValueAxisMaxMinValue (axis, series, dataZoom) {
  series = series.filter(({ show, type }) => {
    if (show === false) return false

    if (type === 'pie') return false

    return true
  })

  if (series.length === 0) return [0, 0]
  
  const { index, axis: axisType } = axis

  series = mergeStackData(series, dataZoom)

  const axisName = axisType + 'Axis'

  let valueSeries = series.filter(s => s[axisName] === index)

  if (!valueSeries.length) valueSeries = series

  return getSeriesMinMaxValue(valueSeries, dataZoom)
}

function getSeriesMinMaxValue (series, dataZoom) {
  if (!series) return

  const dataZoomValue = function (data) {
    if (dataZoom && dataZoom.show) {
      data = data.filter((item, i) => (i >= dataZoom.start && i <= dataZoom.end))
    }
    return data
  }

  let seriesData = []
  series
    .map(({ data }) => {
      if (data && data.length) {
        // data = dataZoomValue(data)
        seriesData = [...seriesData, ...filterNonNumber(data)]
      } else {
        seriesData = [...seriesData, 0]
      }
    })
  const minValue = Math.min(...seriesData, 0)

  const maxValue = Math.max(...seriesData, 10)

  return [minValue, maxValue]
}

function mergeStackData (series, dataZoom) {

  const seriesCloned = JSON.parse(JSON.stringify(series))

  seriesCloned.forEach((item, i) => {
    if (dataZoom && dataZoom.show) {
      item.data = item.data.slice(dataZoom.start, dataZoom.end + 1)
    }
    const data = mergeSameStackData(item, series)
    item.data = data
  })

  return seriesCloned
}

function getTrueMinMax (axisJson, minMaxValue) {
  let { min, max, axis, splitNumber } = axisJson
  let  [minValue, maxValue] = minMaxValue
  if (min === null) {
    min = '20%'
  }
  if (max === null) {
    max = '20%'
  }
  let [minType, maxType] = [typeof min, typeof max]
  if (!testMinMaxType(min)) {
    min = axisConfig[axis + 'AxisConfig'].min
    minType = 'string'
  }

  if (!testMinMaxType(max)) {
    max = axisConfig[axis + 'AxisConfig'].max
    maxType = 'string'
  }

  if (minType === 'string') {
    min = Number(String(minValue - abs(minValue * parseFloat(min) / 100)))

    const lever = getValueLever(min)

    min = Math.min(parseFloat((min / lever).toFixed(1)) * lever, 0)

    min = Math.floor(min / splitNumber) * splitNumber;
  }

  if (maxType === 'string') {
    max = Number(maxValue + abs(maxValue * parseFloat(max) / 100))

    const lever = getValueLever(max)

    max = parseFloat((max / lever).toFixed(1)) * lever

    max = Math.ceil(max / splitNumber) * splitNumber;
  }

  return [min, max]
}

function getValueLever (value) {
  const valueString = abs(parseInt(value)).toString()

  const valueLength = valueString.length

  const firstZeroIndex = valueString.replace(/0*$/g, '').indexOf('0')

  let pow10Num = valueLength - 1

  if (firstZeroIndex !== -1) pow10Num -= firstZeroIndex

  return pow(10, pow10Num)
}

function testMinMaxType (val) {
  const valType = typeof val

  const isValidString = (valType === 'string' && /^\d+%$/.test(val))
  const isValidNumber = valType === 'number'

  return isValidString || isValidNumber
}

function getValueAxisLabelFromZero (min, max, interval, axis) {
  let [negative, positive] = [[], []]
  let [currentNegative, currentPositive] = [0, 0]

  do {
    currentNegative -= interval
    if (axis.min) {
      currentNegative = Math.max(min, currentNegative)
    }
    negative.push(currentNegative)
  } while (currentNegative > min)

  do {
    currentPositive += interval
    if (axis.max) {
      currentPositive = Math.min(max, currentPositive)
    }
    positive.push(currentPositive)
  } while (currentPositive < max)

  return [...negative.reverse(), 0, ...positive]
}

function getValueAxisLabelFromMin (min, max, interval) {
  let [label, currentValue] = [[min], min]

  do {
    currentValue += interval
    label.push(Math.min(currentValue, max))
  } while (currentValue < max)

  return label
}

function getAfterFormatterLabel (dataZoom, label, formatter, type = 'val') {

  if (!formatter) {
    return getDataZoomLabel(type, label, dataZoom)
  }

  label = getDataZoomLabel(type, label, dataZoom)

  if (typeof formatter === 'string') label = label.map(l => getFormatterVal(callbackSendable, formatter, l))
  if (typeof formatter === 'function') label = label.map((value, index) => formatter(value, dataZoom && dataZoom.show ? dataZoom.start + index : index))

  return label
}

function getDataZoomLabel (type, label, dataZoom) {
  if (dataZoom && dataZoom.show && type === 'label') {
    label = label.slice(dataZoom.start, dataZoom.end + 1)
  }
  return label
}

function calcLabelAxisLabelData (labelAxis, dataZoom) {
  return labelAxis.map(axis => {
    const { data, axisLabel: { formatter } } = axis

    return Object.assign({}, axis, { label: getAfterFormatterLabel(dataZoom, data, formatter, 'label') })
  })
}

function getValueInterval (min, max, axis) {
  let { interval, minInterval, maxInterval, splitNumber, axis: axisType } = axis

  const config = axisConfig[axisType + 'AxisConfig']

  if (typeof interval !== 'number') interval = config.interval
  if (typeof minInterval !== 'number') minInterval = config.minInterval
  if (typeof maxInterval !== 'number') maxInterval = config.maxInterval
  if (typeof splitNumber !== 'number') splitNumber = config.splitNumber

  if (typeof interval === 'number') return interval

  let valueInterval = parseInt(String((max - min) / (splitNumber)))

  // if (valueInterval.toString().length > 1) valueInterval = parseInt(valueInterval.toString().replace(/\d$/, '0'))

  if (valueInterval === 0) valueInterval = 1

  if (typeof minInterval === 'number' && valueInterval < minInterval) return minInterval

  if (typeof maxInterval === 'number' && valueInterval > maxInterval) return maxInterval

  return valueInterval
}

function setAxisPosition (allAxis) {
  const xAxis = allAxis.filter(({ axis }) => axis === 'x')
  const yAxis = allAxis.filter(({ axis }) => axis === 'y')

  if (xAxis[0] && !xAxis[0].position) xAxis[0].position = xAxisConfig.position
  if (xAxis[1] && !xAxis[1].position) {
    xAxis[1].position = xAxis[0].position === 'bottom' ? 'top' : 'bottom'
  }

  if (yAxis[0] && !yAxis[0].position) yAxis[0].position = yAxisConfig.position
  if (yAxis[1] && !yAxis[1].position) {
    yAxis[1].position = yAxis[0].position === 'left' ? 'right' : 'left'
  }

  return [...xAxis, ...yAxis]
}

function calcAxisLinePosition (allAxis, chart) {
  const { x, y, w, h } = chart.gridArea

  allAxis = allAxis.map(axis => {
    const { position } = axis

    let linePosition = []

    if (position === 'left') {
      linePosition = [[x, y], [x, y + h]].reverse()
    } else if (position === 'right') {
      linePosition = [[x + w, y], [x + w, y + h]].reverse()
    } else if (position === 'top') {
      linePosition = [[x, y], [x + w, y]]
    } else if (position === 'bottom') {
      linePosition = [[x, y + h], [x + w, y + h]]
    }

    return {
      ...axis,
      linePosition
    }
  })

  return allAxis
}

function calcAxisTickPosition (allAxis, chart) {
  const { render, dataZoom } = chart
  return allAxis.map((axisItem) => {
    let {
      type,
      axis,
      linePosition,
      position,
      label,
      labelData,
      max,
      min,
      boundaryGap,
      axisTick,
      minValue,
      maxValue,
      axisLabel: {
        formatter,
        style,
        interval,
        overflow,
        fontSize,
        width
      }
    } = axisItem
    if (typeof boundaryGap !== 'boolean') boundaryGap = axisConfig[axis + 'AxisConfig'].boundaryGap

    let labelNum = label.length

    const [[startX, startY], [endX, endY]] = linePosition

    const gapLength = axis === 'x' ? endX - startX : endY - startY

    let gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1)

    const ratio = (maxValue - minValue) === 0 ? (abs(gapLength) / (maxValue - minValue)) : 0;

    // Â¶ÇÊûúÊòØÊªöÂä®Ê®°Âºè, ‰∏îxËΩ¥
    if (type === 'data' && dataZoom && dataZoom.show) {
      labelNum = Math.min(dataZoom.num, labelNum)
      gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1)
      axisItem.dataZoom = dataZoom
    } else {
      axisItem.dataZoom = {}
    }

    const tickPosition = new Array(labelNum)
      .fill(0)
      .map((foo, i) => {
        if (axis === 'x') {
          if (type === 'data') {
            return [startX + gap * (boundaryGap ? (i + 0.5) : i), startY]
          } else {
            return [startX +  (labelData[i] - minValue) * ratio, startY]
          }
        }
        if (type === 'data') {
          return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)]
        } else {
          if (min !== null || max !== null) {
            return [startX, startY - (labelData[i] - minValue) * ratio]
          } else {
            return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)]
          }
        }
      })
    if (type === 'data') {
      if (overflow && overflow !== 'none') {
        let overflowW = width ? width : axis === 'x' ? gap : startX
        // ËÆ°ÁÆóÂΩìÂâçÊñáÊú¨ÊòØÂê¶ÈúÄË¶ÅËÆæÁΩÆËá™Âä®Êç¢Ë°åÊàñËÄÖÊà™Âèñ
        axisItem.label = label.map((labelItem, index) => {
          // ctx.font = `${fontSize}px`;
          font.setSize(fontSize);
          labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
          let textI = labelItem.length
          if (overflow === 'truncate') {
            textI = drawTexts(font, labelItem, overflowW)
            labelItem = labelItem.substring(0, textI) + (textI !== labelItem.length ? '...' : '')
          } else if (overflow === 'breakAll') {
            labelItem = drawBreakText(font, labelItem, overflowW)
          }
          return labelItem
        })
      }

      // ËÆ°ÁÆóÊòØÂê¶ÈúÄË¶ÅÈó¥ÈöîÊòæÁ§∫
      interval = interval === null ? 'auto' : interval
      if (interval === 'auto') {
        let labelTotalW = 0
        let maxNum = 0
        let maxText = ''
        axisItem.label.forEach((labelItem, index) => {
          labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
          if (labelItem.length > maxNum) {
            maxNum = labelItem.length
            maxText = labelItem
          }
        })
        font.setSize(fontSize);
        const txtW = px2vp(font.measureText(String(maxText), drawing.TextEncoding.TEXT_ENCODING_UTF8))
        labelTotalW = txtW * axisItem.label.length
        let flag = (txtW > gap) || (labelTotalW > gapLength)
        // axisItem.label.forEach((labelItem, index) => {
        //   ctx.font = `${fontSize}px`;
        //   labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
        //   // const txtW = ctx.measureText(labelItem).width; // Ëé∑ÂèñÊñáÂ≠óÁöÑÈïøÂ∫¶
        //   // const txtW = MeasureText.measureText({ // Âª∫ËÆÆ‰ΩøÁî® this.getUIContext().getMeasureUtils().measureText()Êé•Âè£
        //   //   textContent: labelItem,
        //   //   fontSize: `${fontSize}px`
        //   // }); // Ëé∑ÂèñÊñáÂ≠óÁöÑÈïøÂ∫¶
        //   font.setSize(fontSize);
        //   const txtW = px2vp(font.measureText(labelItem, drawing.TextEncoding.TEXT_ENCODING_UTF8))
        //   // console.log('txtW', px2vp(txtW))
        //   if (txtW > gap) {
        //     flag = true
        //   }
        //   labelTotalW += txtW
        // })
        // return result;
        if (flag) {
          interval = Math.max(Math.round(labelTotalW / (gapLength)), 1)
        }
      }
    }
    // console.log('interval', interval)
    if (!isNaN(interval)) {
      let indices = getIndices(0, axisItem.label.length, interval)
      // if (dataZoom.show && type === 'data' &&  axis === 'x') {
      //   indices = getIndices(dataZoom.start, dataZoom.num, interval)
      // }
      // console.log('indicesindices1', JSON.stringify(indices), axis, JSON.stringify(axisItem.label))
      axisItem.label = axisItem.label.map((item, index) => {
        if (!indices.includes(index)) {
          item = ''
        }
        return item
      })
    }


    const tickLinePosition = getTickLinePosition(axis, boundaryGap, position, tickPosition, gap, axisTick)

    return {
      ...axisItem,
      tickPosition,
      tickLinePosition,
      tickGap: gap
    }
  })
}

function getTickLinePosition (axisType, boundaryGap, position, tickPosition, gap, axisTick) {
  let index = axisType === 'x' ? 1 : 0
  let {length: plus = 5} = axisTick
  // let plus = 10

  if (axisType === 'x' && position === 'top') plus = -5
  if (axisType === 'y' && position === 'left') plus = -5

  let tickLinePosition = tickPosition.map(lineStart => {
    const lineEnd = deepClone(lineStart)

    lineEnd[index] += plus

    return [deepClone(lineStart), lineEnd]
  })

  if (!boundaryGap) return tickLinePosition

  index = axisType === 'x' ? 0 : 1
  plus = gap / 2

  tickLinePosition.forEach(([lineStart, lineEnd]) => {
    lineStart[index] += plus
    lineEnd[index] += plus
  })

  return tickLinePosition
}

function calcAxisNamePosition (allAxis, chart) {
  return allAxis.map(axisItem => {
    let { nameGap, nameLocation, position, linePosition } = axisItem

    const [lineStart, lineEnd] = linePosition

    let namePosition = [...lineStart]

    if (nameLocation === 'end') namePosition = [...lineEnd]

    if (nameLocation === 'center') {
      namePosition[0] = (lineStart[0] + lineEnd[0]) / 2
      namePosition[1] = (lineStart[1] + lineEnd[1]) / 2
    }

    let index = 0

    if (position === 'top' && nameLocation === 'center') index = 1
    if (position === 'bottom' && nameLocation === 'center') index = 1
    if (position === 'left' && nameLocation !== 'center') index = 1
    if (position === 'right' && nameLocation !== 'center') index = 1

    let plus = nameGap

    if (position === 'top' && nameLocation !== 'end') plus *= -1
    if (position === 'left' && nameLocation !== 'start') plus *= -1
    if (position === 'bottom' && nameLocation === 'start') plus *= -1
    if (position === 'right' && nameLocation === 'end') plus *= -1

    namePosition[index] += plus

    return {
      ...axisItem,
      namePosition
    }
  })
}

function calcSplitLinePosition (allAxis, chart) {
  const { w, h } = chart.gridArea

  return allAxis.map(axisItem => {
    const { tickLinePosition, position, boundaryGap } = axisItem

    let [index, plus] = [0, w]

    if (position === 'top' || position === 'bottom') index = 1

    if (position === 'top' || position === 'bottom') plus = h

    if (position === 'right' || position === 'bottom') plus *= -1

    const splitLinePosition = tickLinePosition.map(([startPoint]) => {
      const endPoint = [...startPoint]
      endPoint[index] += plus

      return [[...startPoint], endPoint]
    })

    if (!boundaryGap) splitLinePosition.shift()

    return {
      ...axisItem,
      splitLinePosition
    }
  })
}

function getLineConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem

  return [{
    name: 'polyline',
    index: rLevel,
    visible: axisItem.axisLine.show,
    animationCurve,
    animationFrame: 0,
    shape: getLineShape(axisItem),
    style: getLineStyle(axisItem)
  }]
}

function getLineShape (axisItem) {
  const { linePosition } = axisItem

  return {
    points: linePosition
  }
}

function getLineStyle (axisItem) {
  setLineWidth(axisItem.axisLine.lineStyle)
  return axisItem.axisLine.lineStyle
}

function getTickConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem
  const shapes = getTickShapes(axisItem)
  const style = getTickStyle(axisItem)
  return shapes.map(shape => ({
    name: 'polyline',
    index: rLevel,
    visible: axisItem.axisTick.show,
    animationCurve,
    animationFrame: 0,
    shape,
    style
  }))
}

function getTickShapes (axisItem) {
  const { tickLinePosition } = axisItem

  return tickLinePosition.map(points => ({ points }))
}

function getTickStyle (axisItem) {
  setLineWidth(axisItem.axisTick.lineStyle)
  return axisItem.axisTick.lineStyle
}

function getLabelConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel, axis, dataZoom } = axisItem

  const shapes = getLabelShapes(axisItem)
  const styles = getLabelStyle(axisItem, shapes)

  return shapes.map((shape, i) => {
    let visible = shape.content && axisItem.axisLabel.show
    // if (dataZoom.show) {
    //   visible = i >= dataZoom.start && i <= dataZoom.end
    // }
    return {
      name: 'text',
      index: rLevel,
      visible,
      animationCurve,
      animationFrame: 0,
      shape,
      style: styles[i],
      setGraphCenter: () => (void 0)
    }
  })
}

function getLabelShapes (axisItem) {
  const { label, tickPosition, position, axisLabel, axisTick } = axisItem

  return tickPosition.map((point, i) => ({
    position: getLabelRealPosition(point, position, axisLabel, axisTick),
    content: label[i].toString(),
  }))
}

function getLabelRealPosition (points, position, axisLabel, axisTick) {
  let {margin: plus = 10} = axisLabel
  let { length } = axisTick
  let index = 0

  if (position === 'top' || position === 'bottom') index = 1
  if (position === 'top' || position === 'left') plus *= -1
  if (position === 'top' || position === 'left') length *= -1

  points = deepClone(points)
  points[index] += (plus + length)

  return points
}

function getLabelStyle (axisItem, shapes) {
  const { position } = axisItem

  let { color, fontSize, rotate, fontWeight, fontFamily, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY } = axisItem.axisLabel
  let style = {
    fill: color,
    fontSize,
    rotate,
    fontWeight,
    fontFamily,
    shadowColor,
    shadowBlur,
    shadowOffsetX,
    shadowOffsetY
  }
  const align = getAxisLabelRealAlign(position)

  style = deepMerge(align, style)

  const styles = shapes.map(({ position }) => ({
    ...style,
    graphCenter: position
  }))

  return styles
}

function getAxisLabelRealAlign (position) {
  if (position === 'left') return {
    textAlign: 'right',
    textBaseline: 'middle'
  }

  if (position === 'right') return {
    textAlign: 'left',
    textBaseline: 'middle'
  }

  if (position === 'top') return {
    textAlign: 'center',
    textBaseline: 'bottom'
  }

  if (position === 'bottom') return {
    textAlign: 'center',
    textBaseline: 'top'
  }
}

function getNameConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem

  return [{
    name: 'text',
    index: rLevel,
    animationCurve,
    animationFrame: 0,
    shape: getNameShape(axisItem),
    style: getNameStyle(axisItem)
  }]
}

function getNameShape (axisItem) {
  const { name, namePosition } = axisItem

  return {
    content: name,
    position: namePosition
  }
}

function getNameStyle (axisItem) {
  const { nameLocation, position, nameTextStyle: style } = axisItem

  const align = getNameRealAlign(position, nameLocation)
  // style.fill = style.color
  return deepMerge(align, {
    fill: style.color,
    fontWeight: style.fontWeight,
    fontFamily: style.fontFamily,
    fontSize: style.fontSize
  })
}

function getNameRealAlign (position, location) {
  if (
    (position === 'top' && location === 'start') ||
    (position === 'bottom' && location === 'start') ||
    (position === 'left' && location === 'center')
  ) return {
    textAlign: 'right',
    textBaseline: 'middle'
  }

  if (
    (position === 'top' && location === 'end') ||
    (position === 'bottom' && location === 'end') ||
    (position === 'right' && location === 'center')
  ) return {
    textAlign: 'left',
    textBaseline: 'middle'
  }

  if (
    (position === 'top' && location === 'center') ||
    (position === 'left' && location === 'end') ||
    (position === 'right' && location === 'end')
  ) return {
    textAlign: 'center',
    textBaseline: 'bottom'
  }

  if (
    (position === 'bottom' && location === 'center') ||
    (position === 'left' && location === 'start') ||
    (position === 'right' && location === 'start')
  ) return {
    textAlign: 'center',
    textBaseline: 'top'
  }
}

function getSplitLineConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem

  const shapes = getSplitLineShapes(axisItem)
  const style = getSplitLineStyle(axisItem)

  return shapes.map(shape => ({
    name: 'polyline',
    index: rLevel,
    visible: axisItem.splitLine.show,
    animationCurve,
    animationFrame: 0,
    shape,
    style
  }))
}

function getSplitLineShapes (axisItem) {
  const { splitLinePosition } = axisItem

  return splitLinePosition.map(points => ({ points }))
}

function getSplitLineStyle (axisItem) {
  setLineWidth(axisItem.splitLine.lineStyle)
  return axisItem.splitLine.lineStyle
}

function setLineWidth (data) {
  data.lineWidth = data.width
}
¿‘rDï∂@ohos.graphics.drawing∂../class/updater.classß../util©../configÆ../util/common‘rEó™assertions®external¢id§meta±moduleSideEffects™resolvedByµsyntheticNamedExportsA√ŸÜ hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.graphics.drawing.d.tsA√™oh-resolve¬EA¬ŸÖD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\class\updater.class.tsA√™oh-resolve¬EA¬Ÿ|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\index.tsA√™oh-resolve¬EA¬Ÿ~D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\config\index.tsA√™oh-resolve¬EA¬Ÿ}D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\common.tsA√™oh-resolve¬ì‘rFñßversion§file™sourceRootßsources•names®mappingsßaxis.js†ëßaxis.tsê‹5òî    î  î	  	î  î  î  î1  1î2  1öî   î î	 	î î î! !î# #î) )î4 4î5 4‹ î   î î	 	î î î# #î% %î7 7î9 9îÃB ÃBîÃD ÃDîÃQ ÃQîÃS ÃSîÃ] Ã]îÃ_ Ã_îÃd ÃdîÃf ÃfîÃl ÃlîÃu ÃuîÃv Ãuöî   î î	 	î î î# #î% %î+ +î; ;î< ;ñî   î 	î î î, ,î- -öî   î î î î î   î" "î- -î/ /î0 /ûî  
 î 
î 
î 
î 
î 
î 
î 
î 
î 
î 
î 
î# 
#î$ 
#ñî   î î î î î öî   î î î î î î î î î öî   î î î î î î î  !î" #î( *íî î íî î íî î íî î íî î íî î ôî î î î î î. ,î2 0î4 2î5 2úî î î
 î î î î î î  î# !î) 'î* 'ñî î î î î î íî î  òî î î î î î î  î"  öî î î î î î" î$  î) %î* &î+ &òî î î î( $î) %î0 ,î1 -î2 -‹ î î î î î î  î! î" î$  î( $î* &î, (î. *î/ +î3 /î4 0î5 0òî î î î) %î* &î1 -î2 .î3 .öî î î î& "î' #î. *î0 ,î5 1î6 2î7 2úî  î  î  î#  î$   î+  'î-  )î3  /î5  1î:  6î;  7î<  7òî !î !î !î! !î" !î) !%î* !&î+ !&öî "î "î "î& ""î' "#î. "*î0 ",î5 "1î6 "2î7 "2öî #î #î #î& #"î' ##î. #*î0 #,î5 #1î6 #2î7 #2öî $î $î $î' $#î( $$î/ $+î1 $-î6 $2î7 $3î8 $3ëî %ìî (î (
î (îî )î )î )î )îî *î *î *î *îî +î +	î +î +îî ,î ,î ,î' ,#ìî -î -î -íî .î  .íî /î* /(ìî 0î 0
î 0íî 1î 1	îî 2î 2
î 2î 2îî 3î 3î 3	î 3îî 4î 4î 4î% 4!ìî 5î 5î 5íî 6î  6íî 7î* 7(ìî 8î 8
î 8íî 9î 9	îî :î :
î :î :îî ;î ;î ;	î ;îî <î <î <î& <"ìî =î =î =íî >î  >íî ?î* ?(ìî Ã@î Ã@
î Ã@íî ÃAî ÃA	îî ÃBî ÃB
î ÃBî ÃBîî ÃCî ÃCî ÃC	î ÃCîî ÃDî ÃDî ÃDî% ÃD!ìî ÃEî ÃEî ÃEíî ÃFî  ÃFíî ÃGî* ÃG(ìî ÃHî ÃH
î ÃHíî ÃIî ÃI	îî ÃJî ÃJ
î ÃJî ÃJîî ÃKî ÃKî ÃK	î ÃKîî ÃLî ÃLî ÃLî* ÃL&ìî ÃMî ÃMî ÃMíî ÃOî ÃOíî ÃPî ÃPíî ÃQî ÃQíî ÃRî ÃRíî ÃSî ÃSíî ÃTî* ÃT(íî ÃUî ÃU
íî ÃVî ÃVíî ÃWî ÃWíî ÃXî ÃXíî ÃYî ÃYíî ÃZî( ÃZ&íî Ã[î Ã[
íî Ã\î Ã\íî Ã]î Ã]íî Ã^î Ã^íî Ã_î Ã_íî Ã`î) Ã`'íî Ãaî Ãa
íî Ãbî Ãbíî Ãcî Ãcíî Ãdî Ãdíî Ãeî Ãeíî Ãfî( Ãf&íî Ãgî Ãg
íî Ãhî Ãhíî Ãiî Ãiíî Ãjî Ãjíî Ãkî Ãkíî Ãlî- Ãl+íî Ãmî Ãm	íî Ãnî
 Ãnóî Ãoî	 Ãoî
 Ãoî Ãoî Ãoî Ãoî Ãoíî  Ãp î Ãpïî  Ãr î	 Ãr	î Ãrî Ãrî Ãrïî Ãsî Ãs	î Ãsî Ãsî Ãsíî  Ãt î Ãtóî  Ãv î	 Ãv	î Ãvî Ãvî Ãvî Ãvî  Ãv!ûî Ãwî Ãwî	 Ãwî Ãwî Ãwî Ãwî Ãwî Ãwî  Ãwî" Ãw î$ Ãw"î& Ãw$î' Ãw%î( Ãw%ñî Ãyî Ãyî Ãyî Ãyî Ãyî  Ãyôî Ãzî Ãzî Ãzî Ãzî Ãzî Ãzî Ãzî Ãzî  Ãzëî Ã{ëî	 Ã{	òî Ã|î Ã|î Ã|î Ã|î Ã|î Ã|î Ã|î Ã|ëî Ã}ñî Ãî Ãî Ãî Ãî Ãî  Ãôî ÃÄî ÃÄî ÃÄî ÃÄî ÃÄî ÃÄî ÃÄî ÃÄî  ÃÄëî ÃÅëî	 ÃÅ	òî ÃÇî ÃÇî ÃÇî ÃÇî ÃÇî ÃÇî ÃÇî ÃÇëî ÃÉòî ÃÖî ÃÖ
î ÃÖî ÃÖî ÃÖî ÃÖî ÃÖî ÃÖòî ÃÜî ÃÜ
î ÃÜî ÃÜî ÃÜî ÃÜî ÃÜî ÃÜ‹ î Ãàî Ãà
î Ãàî Ãàî Ãàî Ãàî Ãàî Ãàî! Ãàî# Ãà!î$ Ãà"î& Ãà$î( Ãà&î) Ãà'î* Ãà(î, Ãà*î/ Ãà-î3 Ãà1î5 Ãà3î: Ãà8î< Ãà:î= Ãà;î? Ãà=îÃC ÃàÃAîÃE ÃàÃCîÃH ÃàÃFîÃJ ÃàÃHîÃK ÃàÃIîÃL ÃàÃJîÃM ÃàÃJ‹ î Ãâî Ãâ
î Ãâî Ãâî Ãâî Ãâî Ãâî Ãâî! Ãâî# Ãâ!î$ Ãâ"î& Ãâ$î( Ãâ&î) Ãâ'î* Ãâ(î, Ãâ*î/ Ãâ-î3 Ãâ1î5 Ãâ3î: Ãâ8î< Ãâ:î= Ãâ;î? Ãâ=îÃC ÃâÃAîÃE ÃâÃCîÃH ÃâÃFîÃJ ÃâÃHîÃK ÃâÃIîÃL ÃâÃJîÃM ÃâÃJöî Ããî Ãã	î Ãã
î Ããî Ããî Ããî Ããî$ Ãã"î% Ãã#î& Ãã#íî  Ãå î Ãåïî  Ãé î	 Ãé	î Ãéî  Ãé!î' Ãé(‹ î Ãèî Ãèî Ãèî Ãèî Ãèî Ãèî Ãèî Ãèî  Ãèî" Ãè î& Ãè$î( Ãè&î* Ãè(î, Ãè*î- Ãè+î1 Ãè/î6 Ãè4î9 Ãè7î: Ãè8î; Ãè8‹ î Ãêî Ãêî Ãêî Ãêî Ãêî Ãêî Ãêî Ãêî  Ãêî" Ãê î& Ãê$î( Ãê&î* Ãê(î, Ãê*î- Ãê+î1 Ãê/î6 Ãê4î9 Ãê7î: Ãê8î; Ãê8‹ î Ãíî	 Ãíî Ãí
î Ãíî Ãíî Ãíî Ãíî Ãíî Ãíî Ãíî Ãíî' Ãí%î( Ãí&î1 Ãí/î2 Ãí0î= Ãí;î> Ãí<îÃ@ Ãí>îÃD ÃíÃBîÃE ÃíÃCîÃF ÃíÃDîÃG ÃíÃD‹ î Ãìî	 Ãìî Ãì
î Ãìî Ãìî Ãìî Ãìî Ãìî Ãìî Ãìî Ãìî' Ãì%î( Ãì&î1 Ãì/î2 Ãì0î= Ãì;î> Ãì<îÃ@ Ãì>îÃD ÃìÃBîÃE ÃìÃCîÃF ÃìÃDîÃG ÃìÃDöî Ãïî Ãï	î Ãï
î Ãïî Ãïî Ãïî Ãïî Ãïî Ãïî  Ãïíî  Ãñ î Ãñïî  Ãò î	 Ãò	î  Ãò î! Ãò"î( Ãò)‹ î Ãôî
 Ãôî Ãôî Ãôî Ãôî Ãôî$ Ãô"î% Ãô#î& Ãô$î( Ãô&î, Ãô*î. Ãô,î0 Ãô.î2 Ãô0î3 Ãô1î7 Ãô5î< Ãô:îÃC ÃôÃAîÃD ÃôÃBîÃE ÃôÃB‹ î Ãöî
 Ãöî Ãöî Ãöî Ãöî Ãöî$ Ãö"î% Ãö#î& Ãö$î( Ãö&î, Ãö*î. Ãö,î0 Ãö.î2 Ãö0î3 Ãö1î7 Ãö5î< Ãö:îÃC ÃöÃAîÃD ÃöÃBîÃE ÃöÃBòî Ãúî Ãúî Ãúî Ãúî Ãúî Ãúî Ãúî Ãúòî Ãùî Ãùî Ãùî Ãùî Ãùî# Ãùî( Ãù$î1 Ãù-íî Ãù/î Ãù5óî Ãüî Ãüî Ãü	î Ãüî Ãüî  Ãüî! Ãüîî Ã†î Ã†î Ã†î Ã†òî Ã°î Ã°î Ã°î Ã°î Ã°î Ã°î Ã°î Ã°òî Ã¢î Ã¢î Ã¢î Ã¢î Ã¢î# Ã¢î( Ã¢$î1 Ã¢-íî Ã¢/î Ã¢5óî Ã§î Ã§î Ã§	î Ã§î Ã§î Ã§î  Ã§îî Ã•î Ã•î Ã•î Ã•öî Ãßî Ãß	î Ãß
î Ãßî Ãßî Ãßî Ãßî& Ãß$î' Ãß%î( Ãß%íî  Ã® î Ã®ôî  Ã™ î	 Ã™	î Ã™î Ã™î" Ã™#î$ Ã™%î* Ã™+î, Ã™-î1 Ã™2òî Ã´î
 Ã´î Ã´
î Ã´î Ã´î Ã´î Ã´î Ã´‹ î Ã¨î Ã¨î Ã¨î Ã¨î Ã¨î Ã¨î" Ã¨ î# Ã¨!î$ Ã¨"î& Ã¨$î* Ã¨(î, Ã¨*î. Ã¨,î0 Ã¨.î1 Ã¨/î5 Ã¨3î: Ã¨8îÃA Ã¨?îÃB Ã¨Ã@îÃC Ã¨Ã@‹ î Ã≠î Ã≠î Ã≠î Ã≠î Ã≠î Ã≠î" Ã≠ î# Ã≠!î$ Ã≠"î& Ã≠$î* Ã≠(î, Ã≠*î. Ã≠,î0 Ã≠.î1 Ã≠/î5 Ã≠3îÃA Ã≠?îÃF Ã≠ÃDîÃG Ã≠ÃEîÃH Ã≠ÃEúî ÃØî ÃØî ÃØî& ÃØ$î' ÃØ%î0 ÃØ.î2 ÃØ0î8 ÃØ6î: ÃØ8îÃB ÃØÃ@îÃC ÃØÃAîÃD ÃØÃAöî Ã∞î Ã∞î Ã∞î& Ã∞$î' Ã∞%î0 Ã∞.î2 Ã∞0î: Ã∞8î; Ã∞9î< Ã∞9öî Ã±î Ã±	î Ã±
î Ã±î Ã±î Ã±î Ã±î& Ã±$î' Ã±%î( Ã±%íî  Ã≤ î Ã≤ôî  Ã¥ î	 Ã¥	î Ã¥î  Ã¥!î) Ã¥*î+ Ã¥,î1 Ã¥2î3 Ã¥4î; Ã¥<ôî Ãµî Ãµ	î Ãµî Ãµî Ãµî Ãµî Ãµî Ãµî  Ãµùî Ã∑î Ã∑
î Ã∑î Ã∑î3 Ã∑/î4 Ã∑0î8 Ã∑4î: Ã∑6îÃ@ Ã∑<îÃB Ã∑>îÃJ Ã∑ÃFîÃK Ã∑ÃGîÃL Ã∑ÃGüî Ã∏î Ã∏
î Ã∏î Ã∏î Ã∏î Ã∏î Ã∏î Ã∏î( Ã∏$î) Ã∏%î- Ã∏)î/ Ã∏+î: Ã∏6î; Ã∏7î< Ã∏7ùî Ãπî Ãπ
î Ãπî Ãπî) Ãπ%î* Ãπ&î- Ãπ)î/ Ãπ+î2 Ãπ.î4 Ãπ0î8 Ãπ4î9 Ãπ5î: Ãπ5úî Ã∫î Ã∫
î Ã∫î Ã∫î Ã∫î Ã∫î& Ã∫"î( Ã∫$î* Ã∫&î- Ã∫)î1 Ã∫-î2 Ã∫-ñî Ãºî Ãºî Ãºî Ãºî Ãºî Ãºöî Ãæî Ãæî Ãæî Ãæî Ãæî Ãæî Ãæî Ãæî Ãæî  Ãæûî Ãøî Ãøî Ãøî- Ãø'î. Ãø(î1 Ãø+î3 Ãø-î6 Ãø0î8 Ãø2îÃ@ Ãø:îÃB Ãø<îÃF ÃøÃ@îÃG ÃøÃAîÃH ÃøÃAëî	 Ã¿ëî Ã¿úî Ã¡î Ã¡î Ã¡î, Ã¡&î- Ã¡'î0 Ã¡*î2 Ã¡,î5 Ã¡/î7 Ã¡1î? Ã¡9îÃ@ Ã¡:îÃA Ã¡:ëî	 Ã¬‹ î Ãƒî Ãƒ	î Ãƒî Ãƒî Ãƒî Ãƒî Ãƒî Ãƒî Ãƒî Ãƒî Ãƒî) Ãƒ%î* Ãƒ&î+ Ãƒ'î, Ãƒ(î3 Ãƒ/î4 Ãƒ0î5 Ãƒ1î6 Ãƒ2î7 Ãƒ3î8 Ãƒ4î9 Ãƒ4íî Ã≈î Ã≈ìî Ã∆î Ã∆	î Ã∆îî Ã«î Ã«î Ã«î Ã«ùî Ã»î Ã»î Ã»î Ã»î Ã»î! Ã»î" Ã»î# Ã»î$ Ã»î% Ã»î& Ã» î' Ã»!î( Ã»"óî Ã…î Ã…î Ã…î Ã…î Ã…î Ã…î Ã…õî Ã î Ã î Ã î) Ã #î* Ã $î2 Ã ,î4 Ã .î9 Ã 3î; Ã 5îÃD Ã >îÃE Ã ?íî	 ÃÀî
 ÃÀîî ÃÃî ÃÃî ÃÃî ÃÃíî  ÃÕ î ÃÕíî  Ãœ î Ãœíî  Ã– î' Ã–'íî  Ã— î Ã—íî  Ã“ î/ Ã“/íî  Ã” î= Ã”=íî  Ã‘ î Ã‘íî  Ã’ î Ã’íî  Ã÷ î Ã÷ôî  ÃŸ î	 ÃŸ	î  ÃŸ î! ÃŸ"î% ÃŸ&î' ÃŸ(î- ÃŸ.î/ ÃŸ0î7 ÃŸ8üî Ã⁄î
 Ã⁄î Ã⁄î Ã⁄î Ã⁄î Ã⁄î Ã⁄î Ã⁄î Ã⁄î" Ã⁄ î$ Ã⁄"î( Ã⁄&î* Ã⁄(î, Ã⁄*î. Ã⁄,ïî Ã€î Ã€î Ã€î Ã€î Ã€îî Ã€î Ã€î Ã€$î Ã€$ïî Ã›î Ã›î Ã›î Ã›î Ã›îî Ã›î Ã›î Ã›$î Ã›$îî Ãﬂî Ãﬂî Ãﬂî Ãﬂîî Ã‡î Ã‡î Ã‡î Ã‡óî Ã‚î Ã‚î Ã‚î Ã‚î Ã‚î Ã‚î Ã‚òî Ã‚î Ã‚"î Ã‚#î Ã‚$î Ã‚&î Ã‚'î Ã‚(î Ã‚(úî Ã‰î
 Ã‰î Ã‰
î Ã‰î Ã‰î Ã‰î Ã‰î! Ã‰î# Ã‰!î& Ã‰$î* Ã‰(î+ Ã‰(öî ÃÊî
 ÃÊî ÃÊî ÃÊî ÃÊî" ÃÊ î$ ÃÊ"î, ÃÊ*î- ÃÊ+î. ÃÊ+òî ÃËî
 ÃËî ÃËî ÃËî ÃËî  ÃËî& ÃË$î' ÃË$‹ î ÃÍî ÃÍî ÃÍî ÃÍî ÃÍî ÃÍî# ÃÍ!î$ ÃÍ"î% ÃÍ#î& ÃÍ$î( ÃÍ&î) ÃÍ'î* ÃÍ(î+ ÃÍ)î3 ÃÍ1î4 ÃÍ2î9 ÃÍ7î> ÃÍ<î? ÃÍ=îÃ@ ÃÍ=ñî ÃÏî ÃÏî	 ÃÏî ÃÏî ÃÏî ÃÏïî ÃÏî ÃÏ&î ÃÏ)î ÃÏ/î ÃÏ/ôî ÃÓî ÃÓ	î ÃÓî  ÃÓî+ ÃÓ)î- ÃÓ+î5 ÃÓ3î6 ÃÓ4î7 ÃÓ4íî  ÃÔ î ÃÔóî  ÃÒ î	 ÃÒ	î ÃÒî ÃÒî$ ÃÒ%î& ÃÒ'î. ÃÒ/îî ÃÚî ÃÚî	 ÃÚî ÃÚíî ÃÚî ÃÚñî ÃÙî
 ÃÙî ÃÙî ÃÙî$ ÃÙ"î( ÃÙ&òî Ãıî Ãıî Ãıî Ãıî  Ãıî! Ãıî% Ãı!î' Ãı#‹ î Ãˆî Ãˆ
î Ãˆî Ãˆî Ãˆî Ãˆî Ãˆî  Ãˆî$ Ãˆî& Ãˆ î' Ãˆ!î) Ãˆ#î+ Ãˆ%î, Ãˆ&î- Ãˆ'î. Ãˆ(î2 Ãˆ,î: Ãˆ4î; Ãˆ5îÃ@ Ãˆ:îÃD Ãˆ>îÃE Ãˆ?îÃI ÃˆÃCîÃQ ÃˆÃKîÃR ÃˆÃLîÃU ÃˆÃOîÃV ÃˆÃPîÃW ÃˆÃQîÃX ÃˆÃQëî	 Ã˜îî Ã¯î Ã¯î Ã¯î Ã¯ìî Ã˘î Ã˘î Ã˘ñî Ã˚î Ã˚î Ã˚î Ã˚î Ã˚î Ã˚íî Ã¸î
 Ã¸ôî	 Ã˝î Ã˝î Ã˝	î Ã˝
î Ã˝î Ã˝î Ã˝î Ã˝î Ã˝òî Ã˛î Ã˛
î Ã˛î Ã˛î Ã˛î Ã˛î Ã˛î! Ã˛íî Ãˇî) Ãˇ%ûî Õ î Õ î Õ î Õ î Õ î' Õ #î) Õ %î, Õ (î; Õ 7î< Õ 8îÃ@ Õ <îÃA Õ =îÃB Õ >îÃC Õ >ëî	 Õëî Õöî Õî Õî Õî Õî Õî' Õ#î) Õ%î* Õ&î+ Õ'î, Õ'ëî	 Õîî Õî Õî Õî Õûî Õî
 Õî Õî Õî Õî Õî Õî Õî! Õî+ Õ)î- Õ+î. Õ,î/ Õ-î0 Õ-ûî Õî
 Õî Õî Õî Õî Õî Õî Õî! Õî+ Õ)î- Õ+î/ Õ-î0 Õ.î1 Õ.òî Õ	î Õ		î Õ	
î Õ	î Õ	î Õ	î Õ	î  Õ	íî  Õ
 î Õ
óî  Õ î	 Õ	î Õî Õî Õî  Õ!î( Õ)‹ î Õî
 Õî Õî Õî Õî Õî# Õ!î$ Õ"î( Õ&î) Õ'î2 Õ0î3 Õ1î9 Õ7î: Õ8î; Õ9î< Õ9õî Õî Õî Õî Õî Õî Õî Õî  Õî! Õî# Õ!î% Õ#òî Õî Õî Õî Õî  Õî! Õî% Õ!î' Õ#‹ î Õî Õ
î Õî Õî Õî Õî Õî! Õî" Õî' Õ!î( Õ"î0 Õ*î1 Õ+î6 Õ0î8 Õ2îÃ@ Õ:îÃA Õ;îÃD Õ>îÃG ÕÃAîÃH ÕÃBîÃI ÕÃCîÃJ ÕÃCëî	 Õõî Õî Õ
î Õî Õî' Õ#î( Õ$î, Õ(î. Õ*î4 Õ0î5 Õ1î6 Õ1óî Õî Õî Õ	î Õî Õî Õî Õîî Õî Õî Õî Õîî Õî Õ	î Õî Õíî  Õ î Õóî  Õ î	 Õ	î Õî Õî Õ î! Õ"î, Õ-ûî Õî Õî
 Õî Õî Õî Õî Õî Õî Õî% Õ#î' Õ%î* Õ(î2 Õ0î3 Õ0öî Õî Õî	 Õî Õî Õî Õî Õî Õî* Õ)î+ Õ)ñî Õî Õî Õ	î Õî Õî Õïî Õî Õî Õ
î Õî Õëî Õ ñî Õ!î Õ!î Õ!	î Õ!î Õ!î Õ!ïî Õ"î Õ"î Õ"
î Õ"î Õ"ëî Õ#‹ î Õ$î Õ$î	 Õ$î Õ$î Õ$î Õ$î Õ$î Õ$î Õ$î% Õ$#î( Õ$&î* Õ$(î1 Õ$/î4 Õ$2î5 Õ$3î6 Õ$3òî Õ%î Õ%î	 Õ%î Õ%î Õ%î Õ%î Õ%î Õ%úî Õ&î Õ&î Õ&
î Õ&î Õ&î Õ&î  Õ&î, Õ&(î- Õ&)î. Õ&*î1 Õ&-î2 Õ&-ïî Õ'î Õ'î Õ'î Õ'î Õ'ëî Õ(òî Õ*î Õ*î	 Õ*î Õ*î Õ*î Õ*î Õ*î Õ*úî Õ+î Õ+î Õ+
î Õ+î Õ+î Õ+î  Õ+î, Õ+(î- Õ+)î. Õ+*î1 Õ+-î2 Õ+-ïî Õ,î Õ,î Õ,î Õ,î Õ,ëî Õ-ñî Õ/î Õ/î Õ/î Õ/î Õ/î Õ/‹ î Õ0î Õ0î Õ0
î Õ0î Õ0î Õ0î Õ0î$ Õ0 î' Õ0#î* Õ0&î+ Õ0'î3 Õ0/î6 Õ02îÃ@ Õ0<îÃA Õ0=îÃD Õ0Ã@îÃE Õ0ÃAîÃH Õ0ÃDîÃK Õ0ÃGîÃL Õ0ÃHîÃM Õ0ÃIîÃN Õ0ÃJîÃO Õ0ÃJôî Õ2î Õ2
î Õ2î Õ2î# Õ2î$ Õ2 î' Õ2#î( Õ2$î) Õ2$‹ î Õ4î Õ4î Õ4
î Õ4î Õ4î Õ4î Õ4î! Õ4î" Õ4î# Õ4î& Õ4"î) Õ4%î. Õ4*î/ Õ4+î0 Õ4,î7 Õ43î8 Õ44î9 Õ45î: Õ46î; Õ47î> Õ4:îÃC Õ4?îÃE Õ4ÃAîÃF Õ4ÃBîÃG Õ4ÃCîÃH Õ4ÃCûî Õ6î Õ6î Õ6
î Õ6î Õ6î Õ6î Õ6î Õ6î Õ6î* Õ6&î+ Õ6'î. Õ6*î9 Õ65î: Õ66ëî Õ7ñî Õ9î Õ9î Õ9î Õ9î Õ9î Õ9‹ î Õ:î Õ:î Õ:
î Õ:î Õ:î Õ:î  Õ:î# Õ:î$ Õ: î, Õ:(î/ Õ:+î9 Õ:5î: Õ:6î= Õ:9î> Õ::îÃA Õ:=îÃD Õ:Ã@îÃE Õ:ÃAîÃF Õ:ÃBîÃG Õ:ÃBôî Õ<î Õ<
î Õ<î Õ<î# Õ<î$ Õ< î' Õ<#î( Õ<$î) Õ<$‹ î Õ>î Õ>î Õ>
î Õ>î Õ>î Õ>î Õ>î  Õ>î% Õ>!î& Õ>"î' Õ>#î. Õ>*î/ Õ>+î0 Õ>,î1 Õ>-î2 Õ>.î5 Õ>1î: Õ>6î; Õ>6ûî Õ@î Õ@î Õ@
î Õ@î Õ@î Õ@î Õ@î Õ@î Õ@î) Õ@%î* Õ@&î- Õ@)î8 Õ@4î9 Õ@5ëî ÕAòî ÕCî ÕC	î ÕC
î ÕCî ÕCî ÕCî ÕCî ÕCíî  ÕD î ÕDïî  ÕF î	 ÕF	î ÕFî ÕFî ÕFüî ÕGî
 ÕGî ÕGî ÕGî ÕGî ÕGî$ ÕG"î% ÕG#î* ÕG(î+ ÕG)î, ÕG*î- ÕG+î5 ÕG3î7 ÕG5î8 ÕG5òî ÕIî
 ÕIî ÕIî ÕIî# ÕI!î$ ÕI"î* ÕI(î+ ÕI(‹ î ÕKî
 ÕKî ÕKî ÕKî& ÕK$î' ÕK%î. ÕK,î/ ÕK-î5 ÕK3î7 ÕK5î9 ÕK7î: ÕK8î; ÕK9îÃB ÕKÃ@îÃC ÕKÃAîÃF ÕKÃDîÃG ÕKÃEîÃH ÕKÃEòî ÕMî ÕMî ÕMî ÕMî ÕMî! ÕMî" ÕM î# ÕM ñî ÕOî ÕOî ÕOî ÕOî ÕOî ÕOïî ÕOî ÕO%î ÕO)î" ÕO7î# ÕO7ôî ÕQî ÕQ	î ÕQî ÕQî ÕQî ÕQî ÕQî ÕQî ÕQíî  ÕR î ÕRïî  ÕT î	 ÕT	î ÕTî ÕTî ÕTóî ÕUî
 ÕUî ÕUî ÕUî ÕUî ÕUî ÕU‹ î ÕWî
 ÕWî ÕWî ÕWî ÕWî" ÕW î' ÕW%î/ ÕW-î3 ÕW1î; ÕW9î< ÕW:îÃ@ ÕW>îÃA ÕW?îÃD ÕWÃBîÃE ÕWÃCîÃF ÕWÃDîÃG ÕWÃDòî ÕXî
 ÕXî ÕXî ÕXî! ÕXî& ÕX$î. ÕX,î/ ÕX,ñî ÕZî ÕZ	î ÕZî ÕZî) ÕZ'î* ÕZ'íî  Õ[ î Õ[õî  Õ] î	 Õ]	î" Õ]"î# Õ]$î& Õ]'î( Õ])î+ Õ],î- Õ].î5 Õ]6î7 Õ]8î; Õ]<ûî Õ^î Õ^î	 Õ^î Õ^î Õ^î Õ^î Õ^î Õ^î  Õ^î" Õ^ î$ Õ^"î& Õ^$î' Õ^%î( Õ^%ûî Õ_î Õ_î	 Õ_î Õ_î Õ_î) Õ_'î* Õ_(î- Õ_+î. Õ_,î/ Õ_-î1 Õ_/î2 Õ_0î3 Õ_1î4 Õ_1íî Õaî Õaïî Õbî Õbî Õbî# Õbî$ Õbñî Õcî Õcî Õcî Õcî Õcî Õcúî Õdî Õdî Õdî" Õdî# Õdî& Õd î' Õd!î* Õd$î, Õd&î; Õd5î< Õd6î= Õd6ëî	 Õeòî Õfî Õfî Õfî Õfî Õfî% Õf!î& Õf"î' Õf"ñî Õgî Õgî Õgî Õgî" Õg î$ Õg!íî Õiî Õiïî Õjî Õjî Õjî# Õjî$ Õjñî Õkî Õkî Õkî Õkî Õkî Õkúî Õlî Õlî Õlî" Õlî# Õlî& Õl î' Õl!î* Õl$î, Õl&î; Õl5î< Õl6î= Õl6ëî	 Õmòî Õnî Õnî Õnî Õnî Õnî% Õn!î& Õn"î' Õn"ñî Õoî Õoî Õoî Õoî" Õo î$ Õo!üî Õqî Õq	î Õq
î Õqî Õqî Õqî Õqî! Õqî# Õq!î$ Õq"î& Õq$î) Õq'î1 Õq/î2 Õq0î3 Õq0íî  Õr î Õrôî  Õt î	 Õt	î! Õt!î" Õt#î% Õt&î' Õt(î* Õt+î, Õt-î4 Õt5‹ î Õuî Õuî	 Õuî Õuî Õuî Õuî Õuî  Õuî! Õuî" Õu î% Õu#î& Õu$î( Õu&î+ Õu)î, Õu*î- Õu*íî Õwî Õwïî Õxî Õxî Õxî  Õxî! Õxüî Õyî Õy	î Õy
î Õyî Õyî Õyî Õyî Õyî Õyî( Õy$î* Õy&î- Õy)î. Õy*î/ Õy+î0 Õy+ñî Õzî Õzî Õzî Õzî Õzî! Õzîî Õ|î Õ|	î Õ|î Õ|íî  Õ} î Õ}ùî  Õ î	 Õ	î Õî  Õ!î( Õ)î* Õ+î/ Õ0î1 Õ2î: Õ;î< Õ=îÃ@ ÕÃAîÃC ÕÃDîÃH ÕÃIïî ÕÅî ÕÅî	 ÕÅî ÕÅî ÕÅõî ÕÇî ÕÇî ÕÇî  ÕÇî$ ÕÇ î& ÕÇ"î+ ÕÇ'î- ÕÇ)î5 ÕÇ1î6 ÕÇ2î7 ÕÇ2ëî ÕÉúî ÕÖî	 ÕÖî ÕÖ
î ÕÖî ÕÖî! ÕÖî# ÕÖ!î( ÕÖ&î* ÕÖ(î2 ÕÖ0î3 ÕÖ1î4 ÕÖ1ñî Õáî Õáî Õáî Õáî Õáî% Õá#‹ î Õá%î Õá*î Õá-î Õá2î Õá3î Õá6î Õá7î Õá8î Õá9î Õá;î Õá<î. ÕáÃKî/ ÕáÃLî? ÕáÃ\îÃA ÕáÃ^îÃJ ÕáÃgîÃL ÕáÃiîÃM ÕáÃjîÃN ÕáÃkîÃO ÕáÃlîÃP ÕáÃlñî Õàî Õàî Õàî Õàî Õàî' Õà%‹ &î Õà'î Õà,î Õà/î Õà4î Õà5î Õà8î Õà9î Õà:î  Õà?î" ÕàÃAî' ÕàÃFî) ÕàÃHî+ ÕàÃJî, ÕàÃKî5 ÕàÃTî6 ÕàÃUî; ÕàÃZî= ÕàÃ\îÃE ÕàÃdîÃI ÕàÃhîÃQ ÕàÃpîÃR ÕàÃqîÃV ÕàÃuîÃW ÕàÃvîÃX ÕàÃwîÃY ÕàÃxîÃa ÕàÃÄîÃb ÕàÃÅîÃg ÕàÃÜîÃj ÕàÃâîÃo ÕàÃéîÃp ÕàÃèîÃq ÕàÃêîÃr ÕàÃëîÃw ÕàÃñîÃx ÕàÃóîÃy ÕàÃòîÃz ÕàÃòîî Õäî Õä	î Õäî Õäíî  Õã î Õãôî  Õç î	 Õç	î Õçî Õçî Õçî  Õç!î% Õç&î' Õç(î/ Õç0úî Õéî Õéî Õéî Õéî Õéî Õéî! Õéî% Õé#î) Õé'î. Õé,î5 Õé3î7 Õé5‹ î Õèî Õè	î Õèî Õèî Õèî Õèî Õèî$ Õè î% Õè!î* Õè&î, Õè(î4 Õè0î5 Õè1î8 Õè4î; Õè7î< Õè8î= Õè9î> Õè9ëî Õêîî Õëî Õë	î Õëî Õëíî  Õí î Õíóî  Õî î	 Õî	î Õîî  Õî!î) Õî*î+ Õî,î3 Õî4ôî Õïî Õï	î Õïî Õïî Õïî Õïî Õïî Õïî  Õïûî Õñî Õñ
î Õñî Õñî Õñî Õñî! Õñî# Õñî, Õñ(î. Õñ*î0 Õñ,î3 Õñ/î7 Õñ3î8 Õñ3‹ î Õòî Õòî Õòî Õòî Õòî Õòî Õòî! Õòî% Õò!î' Õò#î) Õò%î. Õò*î0 Õò,îÃF ÕòÃBîÃG ÕòÃCîÃO ÕòÃKîÃQ ÕòÃMîÃU ÕòÃQîÃW ÕòÃSîÃ` ÕòÃ\îÃb ÕòÃ^îÃi ÕòÃeîÃj ÕòÃfîÃl ÕòÃhîÃm ÕòÃiîÃn ÕòÃiîî Õôî Õôî Õôî Õôíî  Õö î Õöôî  Õú î	 Õú	î Õúî Õúî Õúî Õú î" Õú#î$ Õú%î( Õú)‹ î Õùî Õùî
 Õùî Õùî Õùî Õùî! Õùî, Õù*î. Õù,î9 Õù7î; Õù9î? Õù=îÃA Õù?îÃI ÕùÃGîÃK ÕùÃIîÃN ÕùÃLîÃR ÕùÃPîÃS ÕùÃPõî Õüî
 Õüî Õüî Õüî Õüî Õüî& Õü$î) Õü'î5 Õü3î6 Õü4î7 Õü4ñî Õ°î Õ°î Õ°î Õ°î Õ°î$ Õ°"óî Õ°$î Õ°,î Õ°/î Õ°5î Õ°6î" Õ°>î# Õ°>ñî Õ¢î Õ¢î Õ¢î Õ¢î Õ¢î' Õ¢%óî Õ¢'î Õ¢2î Õ¢5î Õ¢;î Õ¢<î( Õ¢ÃGî) Õ¢ÃGñî Õ£î Õ£î Õ£î Õ£î Õ£î' Õ£%óî Õ£'î Õ£2î Õ£5î Õ£;î Õ£<î( Õ£ÃGî) Õ£ÃGñî Õ§î Õ§î Õ§î Õ§î Õ§î' Õ§%óî Õ§'î Õ§2î Õ§5î Õ§;î Õ§<î( Õ§ÃGî) Õ§ÃGñî Õ¶î Õ¶î Õ¶î Õ¶î Õ¶î$ Õ¶"îî Õ¶$î Õ¶+î Õ¶3î Õ¶3‹ î Õ®î Õ®î Õ®î Õ®î  Õ®î! Õ®î' Õ®%î( Õ®&î) Õ®'î, Õ®*î/ Õ®-î2 Õ®0î3 Õ®1î6 Õ®4î7 Õ®5îÃB Õ®Ã@îÃC Õ®ÃAîÃD Õ®ÃBîÃE Õ®ÃCîÃF Õ®ÃCíî Õ™îÃv Õ™Ãtïî Õ¨î Õ¨î Õ¨î Õ¨î Õ¨ïî Õ¨î Õ¨(î Õ¨+î Õ¨,î Õ¨,öî ÕÆî ÕÆî ÕÆî ÕÆî ÕÆî' ÕÆ%î+ ÕÆ)î8 ÕÆ6î; ÕÆ9îÃF ÕÆÃDîî ÕÆÃFî ÕÆÃMî ÕÆÃXî ÕÆÃXöî Õ∞î Õ∞î Õ∞î Õ∞î Õ∞î' Õ∞%î+ Õ∞)î8 Õ∞6î; Õ∞9îÃF Õ∞ÃDîî Õ∞ÃFî Õ∞ÃMî Õ∞ÃXî Õ∞ÃXîî Õ≤î Õ≤	î Õ≤î Õ≤íî  Õ≥ î Õ≥ïî  Õµ î	 Õµ	î Õµî Õµî  Õµ!‹ î Õ∂î
 Õ∂î Õ∂î Õ∂î Õ∂î Õ∂î  Õ∂î! Õ∂î" Õ∂ î$ Õ∂"î( Õ∂&î* Õ∂(î, Õ∂*î. Õ∂,î/ Õ∂-î3 Õ∂1î8 Õ∂6î; Õ∂9î< Õ∂:î= Õ∂:‹ î Õ∑î
 Õ∑î Õ∑î Õ∑î Õ∑î Õ∑î  Õ∑î! Õ∑î" Õ∑ î$ Õ∑"î( Õ∑&î* Õ∑(î, Õ∑*î. Õ∑,î/ Õ∑-î3 Õ∑1î8 Õ∑6î; Õ∑9î< Õ∑:î= Õ∑:ûî Õπî Õπî Õπî Õπî Õπî Õπî Õπî Õπî Õπî Õπî Õπî Õπî Õπî& Õπ$úî Õπ&î Õπ+î Õπ,î Õπ-î Õπ.î Õπ/î Õπ7î Õπ:î' ÕπÃEî( ÕπÃFî0 ÕπÃNî1 ÕπÃNüî Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î Õ∫î& Õ∫$î( Õ∫&‹ î Õªî Õª	î Õª
î Õªî Õªî Õªî Õªî Õªî! Õªî" Õªî# Õªî$ Õª î% Õª!î- Õª)î2 Õª.î: Õª6î; Õª7î< Õª8î= Õª9îÃB Õª>îÃC Õª?îÃD ÕªÃ@îÃE ÕªÃAîÃM ÕªÃIîÃN ÕªÃIëî Õºûî Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî& Õæ$úî Õæ&î Õæ+î Õæ,î Õæ-î Õæ.î Õæ/î Õæ7î Õæ:î' ÕæÃEî( ÕæÃFî0 ÕæÃNî1 ÕæÃNüî Õøî Õøî Õøî Õøî Õøî Õøî Õøî Õøî Õøî Õøî Õøî Õøî Õøî& Õø$î( Õø&‹ î Õ¿î Õ¿	î Õ¿
î Õ¿î Õ¿î Õ¿î Õ¿î Õ¿î! Õ¿î" Õ¿î# Õ¿î$ Õ¿ î% Õ¿!î- Õ¿)î2 Õ¿.î8 Õ¿4î9 Õ¿5î: Õ¿6î; Õ¿7îÃB Õ¿>îÃC Õ¿?îÃD Õ¿Ã@îÃE Õ¿ÃAîÃK Õ¿ÃGîÃL Õ¿ÃGëî Õ¡öî Õ√î Õ√	î Õ√
î Õ√î Õ√î Õ√î Õ√î Õ√î Õ√î  Õ√íî  Õƒ î Õƒóî  Õ∆ î	 Õ∆	î Õ∆î Õ∆î% Õ∆&î' Õ∆(î, Õ∆-‹ î Õ«î
 Õ«î Õ«
î Õ«î Õ«î Õ«î Õ«î Õ«î Õ«î Õ«î Õ«î Õ«î  Õ«î! Õ«î) Õ«'î* Õ«'öî Õ…î Õ…	î Õ…î Õ…î Õ…î Õ…î Õ…î Õ…î Õ…î! Õ…òî Õ î Õ 
î Õ î Õ î Õ î Õ î! Õ î" Õ ñî ÕÃî ÕÃî ÕÃî ÕÃî ÕÃî ÕÃñî ÕŒî ÕŒî ÕŒî ÕŒî ÕŒî! ÕŒ‹ î Õœî Õœî Õœî Õœî Õœî Õœî  Õœî! Õœî" Õœî$ Õœî% Õœî& Õœ î( Õœ"î) Õœ#î, Õœ&î- Õœ'î. Õœ(î/ Õœ)î0 Õœ*î7 Õœ1î9 Õœ3î: Õœ3ëî	 Õ–ñî Õ–î Õ–î Õ–î Õ–î% Õ–#î' Õ–%‹ î Õ—î Õ—î Õ—î Õ—î Õ—î Õ—î! Õ—î" Õ—î$ Õ—î% Õ—î& Õ— î( Õ—"î) Õ—#î* Õ—$î- Õ—'î. Õ—(î0 Õ—*î1 Õ—+î4 Õ—.î5 Õ—/î6 Õ—0î7 Õ—1î8 Õ—2î? Õ—9îÃA Õ—;îÃB Õ—;ëî	 Õ“ñî Õ“î Õ“î Õ“î Õ“î# Õ“!î% Õ“#‹ î Õ”î Õ”î Õ”î Õ”î Õ”î Õ”î  Õ”î! Õ”î" Õ”î$ Õ”î% Õ”î& Õ” î) Õ”#î* Õ”$î, Õ”&î- Õ”'î. Õ”(î/ Õ”)î0 Õ”)ëî	 Õ‘ñî Õ‘î Õ‘î Õ‘î Õ‘î& Õ‘$î( Õ‘&‹ î Õ’î Õ’î Õ’î Õ’î Õ’î Õ’î  Õ’î! Õ’î$ Õ’î% Õ’î& Õ’ î( Õ’"î) Õ’#î* Õ’$î- Õ’'î. Õ’(î0 Õ’*î1 Õ’+î4 Õ’.î5 Õ’/î6 Õ’0î7 Õ’1î8 Õ’1ëî	 Õ÷íî Õÿî Õÿìî ÕŸî ÕŸ	î ÕŸíî Õ⁄î Õ⁄íî	 Õ€î
 Õ€îî Õ‹î Õ‹î Õ‹î Õ‹îî Õﬁî Õﬁ	î Õﬁî Õﬁíî  Õﬂ î Õﬂóî  Õ· î	 Õ·	î Õ·î Õ·î% Õ·&î' Õ·(î, Õ·-öî Õ‚î
 Õ‚î Õ‚
î Õ‚î Õ‚î Õ‚î Õ‚î! Õ‚î& Õ‚$î' Õ‚$öî Õ„î Õ„	î Õ„î Õ„î Õ„î Õ„î Õ„î  Õ„î" Õ„ î$ Õ„"‹ .î Õ‰î Õ‰î ÕÂî ÕÂ
î ÕÊî ÕÊ
î ÕÁî& ÕÁî( ÕËî0 ÕËî2 ÕÈî7 ÕÈî9 ÕÍîÃB ÕÍîÃD ÕÎîÃG ÕÎ	îÃI ÕÏîÃL ÕÏ	îÃN ÕÌîÃY ÕÌîÃ[ ÕÓîÃc ÕÓîÃe ÕÔîÃm ÕÔîÃo ÕîÃw ÕîÃy ÕÒîÃÇ ÕÒîÃÑ ÕÒîÃÜ ÕÚîÃè ÕÚîÃë ÕÛîÃñ ÕÛîÃò ÕÙîÃ† ÕÙîÃ¢ ÕıîÃ™ ÕıîÃ¨ ÕˆîÃ¥ ÕˆîÃ∂ Õ˜îÃª Õ˜îÃΩ Õ¯îÃø Õ˘îÃ¬ Õ˘îÃ  Õ˘îÃÀ Õ˘ñî Õ˙î Õ˙î Õ˙î Õ˙î# Õ˙î, Õ˙(úî Õ˙*î Õ˙5î Õ˙8î$ Õ˙ÃBî% Õ˙ÃCî) Õ˙ÃGî, Õ˙ÃJî8 Õ˙ÃVî9 Õ˙ÃWî: Õ˙ÃXîÃE Õ˙ÃcîÃF Õ˙Ãcòî Õ¸î Õ¸î Õ¸î Õ¸î Õ¸î Õ¸î# Õ¸î$ Õ¸‹ î Õ˛î Õ˛
î Õ˛î Õ˛î Õ˛î Õ˛î Õ˛î Õ˛î! Õ˛î" Õ˛î& Õ˛"î( Õ˛$î, Õ˛(î- Õ˛)î. Õ˛*î1 Õ˛-î= Õ˛9î> Õ˛9‹ î Õ î Õ 
î Õ î Õ î Õ î# Õ î& Õ "î' Õ #î( Õ $î) Õ %î- Õ )î0 Õ ,î6 Õ 2î7 Õ 3î8 Õ 4î9 Õ 5î= Õ 9îÃ@ Õ <îÃF Õ ÃBîÃG Õ ÃB‹ î Õî Õî Õî Õî Õî Õî" Õî# Õî& Õ"î' Õ#î( Õ$î3 Õ/î4 Õ0î5 Õ1î6 Õ2î> Õ:î? Õ;îÃ@ Õ<îÃA Õ=îÃI ÕÃEîÃL ÕÃHîÃM ÕÃIîÃN ÕÃJîÃP ÕÃLîÃQ ÕÃMîÃR ÕÃNîÃS ÕÃN‹ î Õî Õ
î Õî Õî Õî Õî" Õî* Õ&î+ Õ'î0 Õ,î1 Õ-î2 Õ.î3 Õ/î4 Õ0î5 Õ1î8 Õ4î9 Õ5îÃB Õ>îÃC Õ?îÃF ÕÃBîÃG ÕÃCîÃO ÕÃKîÃR ÕÃNîÃZ ÕÃVîÃ[ ÕÃWîÃ\ ÕÃXîÃ] ÕÃYîÃ^ ÕÃZîÃ_ ÕÃ[îÃ` ÕÃ\îÃa ÕÃ]íî Õî Õúî Õî Õî Õî Õî Õî Õî' Õ#î+ Õ'î3 Õ/î4 Õ0î8 Õ4î: Õ6ûî Õî Õî Õî Õî Õî Õî  Õî( Õ"î) Õ#î, Õ&î. Õ(î6 Õ0î7 Õ1î8 Õ1‹ î Õ	î Õ		î Õ	î Õ	î Õ	î" Õ	î# Õ	î& Õ	 î' Õ	!î( Õ	"î3 Õ	-î4 Õ	.î5 Õ	/î6 Õ	0î> Õ	8î? Õ	9îÃ@ Õ	:îÃA Õ	;îÃI Õ	ÃCîÃL Õ	ÃFîÃM Õ	ÃGîÃN Õ	ÃHîÃP Õ	ÃJîÃQ Õ	ÃKîÃR Õ	ÃLîÃS Õ	ÃLóî Õ
î Õ
î Õ
î Õ
î  Õ
î( Õ
"î) Õ
"ëî	 Õëî Õóî Õî Õî Õî Õî  Õî" Õî# Õëî	 Õôî Õî Õ
î Õî Õî! Õî& Õ"î' Õ#î/ Õ+î0 Õ,ïî Õî Õî Õî Õî Õôî Õî Õ
î Õî Õî Õî Õî Õî Õî Õñî Õî Õî Õî Õî Õî Õñî Õ
î Õî Õî Õî# Õî% Õ‹ î Õî Õî Õî" Õî% Õî( Õ î+ Õ#î, Õ$î7 Õ/î8 Õ0î9 Õ1î: Õ2î; Õ3î< Õ4î? Õ7îÃB Õ:îÃC Õ;îÃD Õ<îÃE Õ=îÃF Õ>îÃG Õ?îÃH ÕÃ@îÃJ ÕÃBîÃP ÕÃHîÃQ ÕÃIîÃR ÕÃIëî Õëî Õ‹ î Õî Õî Õî" Õî% Õî& Õî/ Õ(î0 Õ)î1 Õ*î2 Õ+î5 Õ.î= Õ6î> Õ7îÃA Õ:îÃF Õ?îÃH ÕÃAîÃN ÕÃGîÃO ÕÃHîÃP ÕÃHëî Õëî Õ	ñî Õî Õî Õî Õî Õî! Õ‹ î Õ
î Õî Õî Õî  Õî& Õ î) Õ#î, Õ&î/ Õ)î0 Õ*î; Õ5î< Õ6î= Õ7î> Õ8î? Õ9îÃ@ Õ:îÃC Õ=îÃF ÕÃ@îÃG ÕÃAîÃH ÕÃBîÃI ÕÃCîÃJ ÕÃDîÃK ÕÃEîÃL ÕÃFîÃM ÕÃGîÃN ÕÃGëî Õ	ëî Õöî Õ
î Õî Õî Õî  Õî$ Õî' Õ!î, Õ&î0 Õ*î2 Õ,‹ î Õî Õî Õî" Õî$ Õî* Õ"î- Õ%î. Õ&î7 Õ/î8 Õ0î9 Õ1î: Õ2î= Õ5îÃE Õ=îÃF Õ>îÃI ÕÃAîÃN ÕÃFîÃO ÕÃGîÃP ÕÃGëî Õëî Õ‹ î Õî Õî Õî" Õî$ Õî* Õ"î- Õ%î0 Õ(î3 Õ+î4 Õ,î? Õ7îÃ@ Õ8îÃA Õ9îÃB Õ:îÃC Õ;îÃD Õ<îÃG Õ?îÃJ ÕÃBîÃK ÕÃCîÃL ÕÃDîÃM ÕÃEîÃN ÕÃFîÃO ÕÃGîÃP ÕÃHîÃQ ÕÃIîÃR ÕÃIëî Õ ëî Õ!	îî Õ"î	 Õ"î
 Õ"î Õ"ñî Õ#î Õ#î Õ#î Õ#î Õ#î Õ#òî Õ$î Õ$
î Õ$î Õ$î$ Õ$î) Õ$#î/ Õ$)î1 Õ$+‹ î Õ%î Õ%î Õ%î  Õ%î% Õ%î& Õ%î' Õ%î( Õ% î- Õ%%î. Õ%&î/ Õ%'î0 Õ%(î4 Õ%,î9 Õ%1î< Õ%4î= Õ%5î> Õ%6î? Õ%7îÃB Õ%:îÃC Õ%;îÃD Õ%<îÃE Õ%=îÃK Õ%ÃCîÃL Õ%ÃCíî Õ&î' Õ&üî Õ'î Õ'î Õ'î Õ'î! Õ'î& Õ'î' Õ'î* Õ'"î+ Õ'#î, Õ'$î5 Õ'-î7 Õ'/î< Õ'4î> Õ'6îÃ@ Õ'8íî Õ(
î2 Õ((òî Õ)
î Õ)î Õ)î  Õ)î! Õ)î) Õ)î* Õ) î+ Õ)!‹ î Õ*
î Õ*î  Õ*î& Õ*î' Õ*î0 Õ*&î1 Õ*'î2 Õ*(î3 Õ*)îÃB Õ*8îÃC Õ*9îÃS Õ*ÃIîÃU Õ*ÃKîÃ^ Õ*ÃTîÃ` Õ*ÃVîÃi Õ*Ã_îÃk Õ*ÃaîÃp Õ*ÃfîÃq Õ*ÃgîÃr Õ*ÃhîÃs Õ*ÃiîÃt Õ*ÃjîÃ} Õ*ÃsîÃ~ Õ*ÃtîÃ Õ*Ãtòî Õ+
î Õ+î Õ+î  Õ+î) Õ+î* Õ+ î0 Õ+&î1 Õ+&ñî Õ,
î Õ,î  Õ,î% Õ,î/ Õ,%î1 Õ,'úî Õ-î Õ-î  Õ-î) Õ-î* Õ-î. Õ-"î0 Õ-$î9 Õ--î; Õ-/îÃD Õ-8îÃE Õ-9îÃF Õ-9‹ î Õ.î! Õ.î$ Õ.î- Õ.!î. Õ."î7 Õ.+î8 Õ.,î9 Õ.-î; Õ./îÃ@ Õ.4îÃA Õ.5îÃD Õ.8îÃE Õ.9îÃJ Õ.>îÃO Õ.ÃCîÃX Õ.ÃLîÃY Õ.ÃMîÃ_ Õ.ÃSîÃ` Õ.ÃTîÃa Õ.ÃUîÃb Õ.ÃVîÃg Õ.Ã[îÃh Õ.Ã\îÃi Õ.Ã]îÃj Õ.Ã^îÃl Õ.Ã`îÃm Õ.ÃaîÃn Õ.Ãaëî Õ/ñî Õ/î Õ/î% Õ/î* Õ/"î4 Õ/,î6 Õ/.úî Õ0î! Õ0î$ Õ0î1 Õ0%î2 Õ0&î6 Õ0*î8 Õ0,îÃA Õ05îÃC Õ07îÃL Õ0Ã@îÃM Õ0ÃAîÃN Õ0ÃAëî Õ1îî Õ2
î Õ2î$ Õ2î% Õ2îî Õ3î Õ3	î Õ3
î Õ3
ëî Õ4íî Õ6î Õ6üî Õ7î Õ7î Õ7î Õ7î$ Õ7î( Õ7"î) Õ7#î* Õ7$î+ Õ7%î1 Õ7+î2 Õ7,î3 Õ7-î4 Õ7.î< Õ76î= Õ76ñî Õ8î Õ8
î Õ8î Õ8î# Õ8î% Õ8ñî Õ9î Õ9î Õ9î" Õ9î# Õ9î$ Õ9ñî Õ:î Õ:î Õ:î Õ:î Õ:î Õ:ñî Õ;î Õ;î Õ;î Õ;î  Õ;î! Õ;ùî Õ<î Õ<î Õ<î Õ<î Õ<î& Õ<î' Õ<î( Õ< î1 Õ<)î3 Õ<+î8 Õ<0î: Õ<2î< Õ<4‹ î Õ=
î Õ=î  Õ=î& Õ=î' Õ=î0 Õ=&î1 Õ='î2 Õ=(î3 Õ=)îÃB Õ=8îÃC Õ=9îÃS Õ=ÃIîÃU Õ=ÃKîÃ^ Õ=ÃTîÃ` Õ=ÃVîÃi Õ=Ã_îÃk Õ=ÃaîÃp Õ=ÃfîÃq Õ=ÃgîÃr Õ=ÃhîÃs Õ=ÃiîÃt Õ=ÃjîÃ} Õ=ÃsîÃ~ Õ=ÃtîÃ Õ=Ãtòî Õ>
î Õ>î! Õ>î" Õ>î( Õ>î+ Õ>!î1 Õ>'î3 Õ>)óî Õ?î Õ?î! Õ?î* Õ?î+ Õ?î1 Õ?%î2 Õ?%ïî Õ@î Õ@î" Õ@î+ Õ@î, Õ@ëî ÕAîî ÕBî ÕB	î ÕB
î ÕB
òî ÕCî ÕCî ÕCî ÕCî ÕCî% ÕCî& ÕCî' ÕC‹ î ÕDî ÕDî ÕDî ÕDî" ÕDî# ÕDî' ÕDî( ÕD î3 ÕD+î4 ÕD,î: ÕD2î; ÕD3îÃB ÕD:îÃC ÕD;îÃE ÕD=îÃL ÕDÃDîÃM ÕDÃEîÃY ÕDÃQîÃZ ÕDÃRîÃl ÕDÃdîÃm ÕDÃeîÃn ÕDÃfîÃo ÕDÃfõî ÕEî ÕEî ÕEî" ÕEî% ÕEî- ÕE%î. ÕE&î3 ÕE+î4 ÕE,î: ÕE2î; ÕE2‹ î ÕFî ÕFî ÕFî ÕFî ÕFî  ÕFî# ÕFî& ÕFî' ÕFî+ ÕF#î, ÕF$î7 ÕF/î: ÕF2îÃC ÕF;îÃD ÕF<îÃE ÕF<íî ÕGîÃA ÕG9íî ÕHî0 ÕH(íî ÕIîÃ ÕIÃwíî ÕJîÃQ ÕJÃIíî ÕKîÃ| ÕKÃtíî ÕLî1 ÕL)íî ÕMî3 ÕM+íî ÕNî& ÕNíî ÕOî, ÕO$íî ÕPîÃm ÕPÃeíî ÕQî8 ÕQ0íî ÕRî& ÕRíî ÕSî" ÕSíî ÕTî ÕTíî ÕUî( ÕU íî ÕVî ÕVíî ÕWî! ÕWîî ÕXî ÕXî ÕXî ÕX‹ î ÕY
î ÕYî ÕYî# ÕYî$ ÕYî' ÕYî( ÕYî, ÕY"î- ÕY#î2 ÕY(î3 ÕY)î> ÕY4îÃA ÕY7îÃB ÕY8îÃK ÕYÃAîÃL ÕYÃBîÃM ÕYÃCîÃO ÕYÃEîÃP ÕYÃFîÃQ ÕYÃGîÃR ÕYÃGëî ÕZ	ëî Õ[ëî	 Õ\íî Õ]î, Õ](òî Õ^î Õ^î Õ^	î Õ^î Õ^î Õ^î Õ^î Õ^‹ î Õ_î Õ_
î Õ_î Õ_î$ Õ_î% Õ_î& Õ_ î( Õ_"î0 Õ_*î1 Õ_+î6 Õ_0î7 Õ_1î= Õ_7î? Õ_9îÃG Õ_ÃAîÃH Õ_ÃBîÃI Õ_ÃBíî Õ`îÃG Õ`ÃAíî ÕaîÃM ÕaÃGíî Õbî Õb
íî ÕcîÃl ÕcÃf‹ î Õdî Õdî Õdî Õdî Õdî% Õdî& Õd î+ Õd%î, Õd&î/ Õd)î0 Õd*î1 Õd+î5 Õd/î7 Õd1î< Õd6î> Õd8îÃ@ Õd:öî Õeî Õeî Õeî Õeî Õeî% Õeî& Õeî+ Õe#î, Õe$î. Õe&ïî Õf
î Õfî Õfî Õfî Õfëî Õg	îî Õhî Õhî Õhî Õhîî Õiî Õiî Õiî Õiëî	 Õj‹ î Õmî Õm
î Õmî! Õmî4 Õm0î5 Õm1î9 Õm5î; Õm7îÃF ÕmÃBîÃH ÕmÃDîÃP ÕmÃLîÃR ÕmÃNîÃ^ ÕmÃZîÃ` ÕmÃ\îÃc ÕmÃ_îÃe ÕmÃaîÃm ÕmÃiîÃn ÕmÃjîÃo ÕmÃjíî Õoî Õoìî Õpî Õp	î Õpíî Õqî Õqíî Õrî Õrîî Õsî Õsî Õsî Õsíî	 Õtî
 Õtîî Õuî Õuî Õuî Õuíî  Õv î Õvüî  Õx î	 Õx	î Õxî Õxî% Õx&î' Õx(î2 Õx3î4 Õx5î< Õx=î> Õx?îÃJ ÕxÃKîÃL ÕxÃMîÃO ÕxÃPîÃQ ÕxÃRîÃY ÕxÃZ‹ î Õyî Õyî Õyî Õyî Õyî Õyî  Õyî! Õyî" Õy î# Õy!î$ Õy"î% Õy#î& Õy$î' Õy%î( Õy&î) Õy&úî Õzî Õzî
 Õzî Õzî Õzî Õzî Õzî Õzî Õzî Õzî' Õz#î( Õz#íî Õ{î Õ{ôî Õ}î Õ}î Õ}î Õ}î Õ}î Õ}î$ Õ}"î) Õ}'î. Õ},ñî Õ}.î Õ}2î Õ}5î Õ}6î Õ}7î Õ}7ôî Õ~î Õ~î Õ~î Õ~î Õ~î Õ~î$ Õ~"î) Õ~'î/ Õ~-ñî Õ~/î Õ~3î Õ~6î Õ~7î Õ~8î Õ~8õî ÕÄî ÕÄî ÕÄî ÕÄî' ÕÄ%î( ÕÄ&î+ ÕÄ)î, ÕÄ*î5 ÕÄ3î6 ÕÄ4î8 ÕÄ6ôî ÕÅî ÕÅ
î ÕÅî ÕÅî! ÕÅî" ÕÅî+ ÕÅ'î, ÕÅ(î- ÕÅ(òî ÕÉî ÕÉî ÕÉî ÕÉî ÕÉî ÕÉî ÕÉî ÕÉõî ÕÖî ÕÖî ÕÖî ÕÖî ÕÖî# ÕÖî$ ÕÖ î& ÕÖ"î- ÕÖ)î. ÕÖ*î/ ÕÖ*îî ÕÜî ÕÜî ÕÜî ÕÜîî Õàî Õàî	 Õàî Õàîî Õàî Õàî Õà+î  Õà+üî Õäî	 Õäî Õä
î Õäî Õäî Õäî Õäî Õäî Õäî  Õäî! Õäî" Õä î# Õä!î$ Õä"î% Õä"óî Õãî Õãî Õã	î Õãî Õãî Õãî Õãùî Õçî Õçî Õçî Õçî Õçî Õçî Õçî( Õç&î* Õç(î1 Õç/î2 Õç0î4 Õç2î6 Õç4òî Õéî Õéî Õéî Õéî Õéî Õéî  Õéî! Õéòî Õèî Õèî Õèî Õèî Õèî Õèî Õèî Õèîî Õêî Õêî Õêî Õêîî Õíî Õí	î Õíî Õííî  Õì î Õìóî  Õï î	 Õï	î Õïî Õïî% Õï&î' Õï(î, Õï-ôî Õñî Õñ	î Õñî Õñî Õñî Õñî Õñî  Õñî" Õñ ûî Õóî Õóî Õó
î Õóî Õóî# Õóî% Õó!î- Õó)î/ Õó+î; Õó7î= Õó9îÃ@ Õó<îÃH ÕóÃDîÃI ÕóÃDöî Õôî Õô
î Õôî Õôî Õôî! Õôî" Õôî% Õô!î1 Õô-î2 Õô-ôî Õõî Õõî Õõî Õõî Õõî Õõî( Õõ$î) Õõ%î* Õõ%ïî Õùî Õùî Õùî Õùî" Õùòî Õù î Õù,î Õù/î Õù0î Õù3î& Õù:î' Õù;î( Õù;ñî Õüî Õüî Õüî Õüî% Õü!î' Õü#‹ î Õ†î Õ†î Õ†î Õ†î Õ†î Õ†î Õ†î( Õ†"î) Õ†#î* Õ†$î+ Õ†%î. Õ†(î5 Õ†/î6 Õ†0î7 Õ†1î8 Õ†2î9 Õ†3î< Õ†6î= Õ†7î> Õ†7‹ î Õ°î Õ°î Õ°î Õ°î Õ°î Õ°î Õ°î( Õ°"î) Õ°#î* Õ°$î+ Õ°%î. Õ°(î5 Õ°/î6 Õ°0î7 Õ°1î8 Õ°2î9 Õ°3î< Õ°6î= Õ°7î> Õ°7ëî	 Õ¢ñî Õ§î Õ§î Õ§î Õ§î Õ§î Õ§ôî Õ¶î Õ¶î Õ¶î Õ¶î Õ¶î" Õ¶î. Õ¶*î3 Õ¶/î; Õ¶7ïî Õ¶9î Õ¶>î Õ¶ÃAî Õ¶ÃBî Õ¶ÃBôî Õßî Õßî Õßî Õßî! Õßî% Õß!î1 Õß-î6 Õß2î> Õß:ïî Õß<î ÕßÃAî ÕßÃDî ÕßÃEî ÕßÃEôî Õ®î Õ®î Õ®î Õ®î Õ®î# Õ®î/ Õ®+î4 Õ®0î< Õ®8ïî Õ®:î Õ®?î Õ®ÃBî Õ®ÃCî Õ®ÃCôî Õ©î Õ©î Õ©î Õ©î  Õ©î$ Õ© î0 Õ©,î5 Õ©1î= Õ©9ïî Õ©;î Õ©Ã@î Õ©ÃCî Õ©ÃDî Õ©ÃDñî Õ´î Õ´î Õ´î Õ´î Õ´î Õ´ôî Õ≠î Õ≠î Õ≠î Õ≠î Õ≠î" Õ≠î. Õ≠*î3 Õ≠/î8 Õ≠4ñî Õ≠6î Õ≠:î Õ≠>î Õ≠?î Õ≠Ã@î Õ≠Ã@ôî ÕÆî ÕÆî ÕÆî ÕÆî ÕÆî# ÕÆî/ ÕÆ+î4 ÕÆ0î; ÕÆ7ñî ÕÆ9î ÕÆ=î ÕÆÃAî ÕÆÃBî ÕÆÃCî ÕÆÃCôî ÕØî ÕØî ÕØî ÕØî! ÕØî% ÕØ!î1 ÕØ-î6 ÕØ2î= ÕØ9ñî ÕØ;î ÕØ?î ÕØÃCî ÕØÃDî ÕØÃEî ÕØÃEôî Õ∞î Õ∞î Õ∞î Õ∞î  Õ∞î$ Õ∞ î0 Õ∞,î5 Õ∞1î: Õ∞6ñî Õ∞8î Õ∞<î Õ∞Ã@î Õ∞ÃAî Õ∞ÃBî Õ∞ÃBòî Õ≤î Õ≤î Õ≤î Õ≤î Õ≤î Õ≤î# Õ≤î$ Õ≤íî Õ¥î Õ¥ìî Õµî Õµ	î Õµíî Õ∂î Õ∂íî	 Õ∑î
 Õ∑îî Õ∏î Õ∏î Õ∏î Õ∏íî  Õπ î Õπóî  Õª î	 Õª	î Õªî Õª î& Õª'î( Õª)î- Õª.úî Õºî
 Õºî Õº
î Õºî Õºî Õºî Õºî Õºî Õºî Õºî# Õº!î$ Õº!ôî Õæî Õæ	î Õæî Õæî Õæî Õæî Õæî  Õæî" Õæ úî Õøî Õø
î Õøî  Õøî" Õøî* Õø&î, Õø(î7 Õø3î9 Õø5î< Õø8îÃD ÕøÃ@îÃE ÕøÃ@ûî Õ¡î Õ¡î Õ¡	î Õ¡î Õ¡î Õ¡î Õ¡î Õ¡î Õ¡î Õ¡î  Õ¡î! Õ¡î" Õ¡î# Õ¡ôî Õ√î Õ√î Õ√î Õ√î Õ√î" Õ√î* Õ√&î/ Õ√+î7 Õ√3ïî Õ√5î Õ√:î Õ√=î Õ√>î Õ√>ôî Õ≈î Õ≈î Õ≈î Õ≈î Õ≈î" Õ≈î* Õ≈&î/ Õ≈+î7 Õ≈3ïî Õ≈5î Õ≈9î Õ≈<î Õ≈=î Õ≈=ôî Õ«î Õ«î Õ«î Õ«î  Õ«î$ Õ« î, Õ«(î1 Õ«-î9 Õ«5ñî Õ«7î Õ«;î Õ«?î Õ«Ã@î Õ«ÃAî Õ«ÃAûî Õ…î Õ…
î Õ…î" Õ…î2 Õ….î3 Õ…/î6 Õ…2î7 Õ…3î8 Õ…4î9 Õ…5îÃC Õ…?îÃD Õ…Ã@îÃF Õ…ÃBîÃH Õ…ÃDôî Õ î Õ î Õ î Õ î Õ î! Õ î+ Õ %î, Õ &î- Õ &òî ÕÀî ÕÀî ÕÀî ÕÀî ÕÀî ÕÀî# ÕÀî$ ÕÀõî ÕÕî ÕÕî ÕÕî ÕÕî ÕÕî" ÕÕî# ÕÕî% ÕÕî- ÕÕ'î. ÕÕ(î/ ÕÕ(îî ÕŒî	 ÕŒî
 ÕŒî ÕŒîî Õ–î Õ–î Õ–	î Õ–ñî Õ–î Õ–'î Õ–(î# Õ–-î% Õ–/î& Õ–/íî Õ“î Õ“ìî Õ”î Õ”	î Õ”íî Õ‘î Õ‘íî	 Õ’î
 Õ’îî Õ÷î Õ÷î Õ÷î Õ÷íî  Õ◊ î Õ◊ïî  ÕŸ î	 ÕŸ	î ÕŸî ÕŸî ÕŸ úî Õ⁄î
 Õ⁄î Õ⁄
î Õ⁄î Õ⁄î* Õ⁄(î, Õ⁄*î2 Õ⁄0î4 Õ⁄2î7 Õ⁄5î? Õ⁄=îÃ@ Õ⁄=ìî Õ‹î Õ‹	î Õ‹
îî Õ›î Õ›î Õ›
î Õ›îî Õﬁî Õﬁ	î Õﬁî Õﬁòî Õﬂî Õﬂî Õﬂî Õﬂî Õﬂî& Õﬂî' Õﬂî+ Õﬂ#íî Õ‡î Õ‡îî Õ·î Õ·î Õ·î Õ·óî Õ‚î Õ‚	î Õ‚î Õ‚î  Õ‚î( Õ‚ î) Õ‚!óî Õ„î Õ„	î Õ„î Õ„î  Õ„î( Õ„ î) Õ„!ìî	 Õ‰î
 Õ‰î Õ‰íî  ÕÂ î ÕÂïî  ÕÁ î	 ÕÁ	î ÕÁî ÕÁî ÕÁòî ÕËî
 ÕËî ÕË
î ÕËî ÕËî ÕËî% ÕË#î& ÕË#íî ÕÍî ÕÍ	îî ÕÎî ÕÎ
î ÕÎî ÕÎíî ÕÏî ÕÏíî  ÕÌ î ÕÌïî  ÕÔ î	 ÕÔ	î ÕÔî ÕÔî ÕÔöî Õî Õî Õî Õî Õî" Õ î# Õ!î, Õ*î- Õ+î. Õ+òî ÕÒî ÕÒ	î ÕÒî ÕÒî ÕÒî ÕÒî& ÕÒ$î' ÕÒ$íî  ÕÚ î ÕÚïî  ÕÙ î	 ÕÙ	î ÕÙî ÕÙî ÕÙ úî Õıî
 Õıî Õı
î Õıî Õıî* Õı(î, Õı*î2 Õı0î4 Õı2î7 Õı5î? Õı=îÃ@ Õı=ôî Õˆî
 Õˆî Õˆî Õˆî  Õˆî! Õˆî) Õˆ'î* Õˆ(î+ Õˆ(ôî Õ˜î
 Õ˜î Õ˜î Õ˜î Õ˜î Õ˜î' Õ˜%î( Õ˜&î) Õ˜&õî Õ¯î Õ¯	î Õ¯î Õ¯î Õ¯î Õ¯î Õ¯î Õ¯î Õ¯î Õ¯î  Õ¯îî Õ˘î Õ˘î Õ˘
î Õ˘îî Õ˙î Õ˙	î Õ˙î Õ˙òî Õ˚î Õ˚î Õ˚î Õ˚î Õ˚î" Õ˚î# Õ˚î' Õ˚#íî Õ¸î Õ¸îî Õ˝î Õ˝î Õ˝î Õ˝íî Õ˛î Õ˛	íî Õˇî Õˇ	îî Õ î Õ î Õ î Õ íî  Õ î Õïî  Õ î	 Õ	î Õî Õî Õ òî Õî
 Õî Õ
î Õî Õî! Õî) Õ'î* Õ'‹ î Õî Õ	î Õî Õî Õî  Õî& Õ$î' Õ%î) Õ'î* Õ(î+ Õ)î- Õ+î3 Õ1î5 Õ3î6 Õ4î7 Õ5î8 Õ5íî  Õ î Õïî  Õ	 î	 Õ		î Õ	î Õ	î Õ	öî Õ
î Õ
î Õ
î Õ
î Õ
î" Õ
 î# Õ
!î, Õ
*î- Õ
+î. Õ
+òî Õî Õ	î Õî Õî Õî Õî& Õ$î' Õ$íî  Õ î Õïî  Õ î	 Õ	î Õî Õî  Õ!‹ î Õî
 Õî Õ
î Õî Õî* Õ(î, Õ*î2 Õ0î4 Õ2î8 Õ6î: Õ8îÃB ÕÃ@îÃD ÕÃBîÃG ÕÃEîÃO ÕÃMîÃP ÕÃMôî Õî
 Õî Õî Õî! Õî" Õ î* Õ(î+ Õ)î, Õ)õî Õî
 Õî Õî Õî  Õî! Õî) Õ'î+ Õ)î1 Õ/î2 Õ0î3 Õ0úî Õî Õ	î Õî Õî Õî Õî Õî Õî Õî Õî! Õî# Õ!ûî Õî Õî Õî Õî Õî Õî# Õî' Õ#î/ Õ+î0 Õ,î9 Õ5î: Õ6î> Õ:î? Õ:íî Õî Õíî Õî? Õ;íî Õî Õíî Õî Õîî Õî Õ
î Õî Õîî Õî Õî Õî Õíî Õî Õíî Õî Õîî Õî Õî Õî Õíî Õî Õóî Õ î Õ î Õ î Õ î Õ î Õ î Õ öî Õ!î Õ!î Õ!î Õ!î! Õ!î" Õ!î# Õ!î( Õ!"î) Õ!#î* Õ!$íî	 Õ"î
 Õ"îî Õ#î Õ#î Õ#î Õ#íî  Õ$ î Õ$ïî  Õ& î	 Õ&	î Õ&î Õ&î  Õ&!‹ î Õ'î
 Õ'î Õ'
î Õ'î Õ'î Õ'î! Õ'î) Õ''î+ Õ')î4 Õ'2î6 Õ'4î> Õ'<îÃ@ Õ'>îÃC Õ'ÃAîÃK Õ'ÃIîÃL Õ'ÃIûî Õ)î Õ)	î Õ)î Õ)î Õ)î Õ)î Õ)î" Õ) î$ Õ)"î% Õ)#î' Õ)%î) Õ)'î* Õ)(î+ Õ))ùî Õ*î Õ*î Õ*î& Õ*"î' Õ*#î, Õ*(î. Õ**î6 Õ*2î8 Õ*4îÃA Õ*=îÃC Õ*?îÃK Õ*ÃGîÃL Õ*ÃHöî Õ+î Õ+î Õ+î Õ+î Õ+î Õ+î Õ+î Õ+î" Õ+î$ Õ+ îî Õ,î Õ,î Õ,î Õ,íî  Õ- î Õ-õî  Õ/ î	 Õ/	î Õ/î Õ/î$ Õ/%î& Õ/'î. Õ//î0 Õ/1î9 Õ/:î; Õ/<îÃC Õ/ÃDúî Õ0î Õ0î
 Õ0î Õ0î Õ0î Õ0î Õ0î Õ0î Õ0î  Õ0î) Õ0%î* Õ0%òî Õ1î Õ1î
 Õ1î Õ1î Õ1î Õ1î Õ1î Õ1ñî Õ2î Õ2î Õ2î Õ2î Õ2î Õ2ôî Õ4î Õ4î Õ4î Õ4î Õ4î Õ4î& Õ4$î+ Õ4)î3 Õ41ïî Õ43î Õ48î Õ4;î Õ4<î Õ4<ôî Õ5î Õ5î Õ5î Õ5î Õ5î Õ5î& Õ5$î+ Õ5)î1 Õ5/ñî Õ51î Õ55î Õ59î Õ5:î Õ5;î Õ5;ôî Õ6î Õ6î Õ6î Õ6î Õ6î Õ6î& Õ6$î+ Õ6)î1 Õ6/ñî Õ61î Õ67î Õ6;î Õ6<î Õ6=î Õ6=òî Õ8î
 Õ8î Õ8î Õ8î Õ8î Õ8î Õ8î Õ8úî Õ9î
 Õ9î Õ9	î Õ9î Õ9î Õ9î Õ9î Õ9î Õ9î# Õ9!î$ Õ9"î% Õ9"îî Õ;î Õ;	î Õ;î Õ;íî  Õ< î Õ<óî  Õ> î	 Õ>	î Õ>î Õ>î Õ> î! Õ>"î' Õ>(òî Õ?î
 Õ?î Õ?
î Õ?î Õ?î Õ?î! Õ?î" Õ?‹ î ÕAî ÕAî
 ÕAî ÕAî ÕAî ÕAî ÕAî! ÕAî# ÕA!î- ÕA+î/ ÕA-î9 ÕA7î; ÕA9îÃF ÕAÃDîÃH ÕAÃFîÃR ÕAÃPîÃT ÕAÃRîÃa ÕAÃ_îÃc ÕAÃaîÃp ÕAÃnîÃr ÕAÃpîÃu ÕAÃsîÃ} ÕAÃ{îÃ~ ÕAÃ|îÃá ÕAÃÖîÃà ÕAÃÖîî ÕBî ÕBî ÕBî ÕBîî ÕCî ÕCî ÕC
î ÕCíî ÕDî ÕDíî ÕEî ÕE
íî ÕFî ÕFíî ÕGî ÕGíî ÕHî ÕHíî ÕIî ÕIíî ÕJî ÕJíî ÕKî ÕKíî ÕLî ÕLôî ÕMî
 ÕMî ÕMî ÕMî' ÕM%î( ÕM&î0 ÕM.î1 ÕM/î2 ÕM/öî ÕOî	 ÕOî ÕO
î ÕOî ÕOî ÕOî ÕOî" ÕO î# ÕO!î$ ÕO!‹ î ÕQî
 ÕQî ÕQî ÕQî ÕQî ÕQî ÕQî ÕQî ÕQî! ÕQî) ÕQ'î+ ÕQ)î- ÕQ+î/ ÕQ-î0 ÕQ.î1 ÕQ/ìî ÕRî ÕRî ÕRîî ÕSî ÕSî ÕSî ÕSîî ÕTî ÕTî ÕTî ÕTîî ÕVî ÕV	î ÕVî ÕVíî  ÕW î ÕWïî  ÕY î	 ÕY	î ÕYî ÕY î' ÕY(ïî ÕZî ÕZî ÕZî ÕZî ÕZíî ÕZî ÕZ"îî Õ[î Õ[î Õ[î Õ[îî Õ\î Õ\î Õ\î" Õ\íî	 Õ]î
 Õ]ïî Õ_î Õ_î Õ_î Õ_î Õ_íî Õ_î Õ_#îî Õ`î Õ`î Õ`î Õ`îî Õaî Õaî Õaî" Õaíî	 Õbî
 Õbïî Õdî Õdî Õdî Õdî Õdíî Õdî Õd!îî Õeî Õeî Õeî Õeîî Õfî Õfî Õfî" Õfíî	 Õgî
 Õgïî Õiî Õiî Õiî Õiî Õiíî Õiî Õi$îî Õjî Õjî Õjî Õjîî Õkî Õkî Õkî Õkíî	 Õlî
 Õlíî  Õm î Õmïî  Õo î	 Õo	î Õoî Õoî Õo úî Õpî
 Õpî Õp
î Õpî Õpî* Õp(î, Õp*î2 Õp0î4 Õp2î7 Õp5î? Õp=îÃ@ Õp=ìî Õrî Õr	î Õr
îî Õsî Õsî Õs
î Õsîî Õtî Õt	î Õtî Õtíî Õuî Õuîî Õvî Õvî Õvî Õvóî Õwî Õw	î Õwî Õwî  Õwî( Õw î) Õw!óî Õxî Õx	î Õxî Õxî  Õxî( Õx î) Õx!ìî	 Õyî
 Õyî Õyíî  Õz î Õzïî  Õ| î	 Õ|	î Õ|î Õ|î Õ|öî Õ}î
 Õ}î Õ}
î Õ}î Õ}î Õ}î  Õ}î# Õ}!î+ Õ})î, Õ})íî Õî Õ	îî ÕÄî ÕÄî ÕÄî ÕÄîî ÕÅî ÕÅî ÕÅî ÕÅíî ÕÇî ÕÇíî  ÕÉ î ÕÉïî  ÕÖ î	 ÕÖ	î ÕÖî ÕÖî ÕÖûî ÕÜî
 ÕÜî ÕÜ
î ÕÜî ÕÜî" ÕÜ î$ ÕÜ"î1 ÕÜ/î3 ÕÜ1î8 ÕÜ6î: ÕÜ8î= ÕÜ;îÃE ÕÜÃCîÃF ÕÜÃCõî Õàî
 Õàî Õàî Õàî" Õà î# Õà!î+ Õà)î- Õà+î9 Õà7î: Õà8î; Õà8íî Õâî Õâñî Õäî Õä	î Õäî Õäî Õäî Õäñî Õãî Õãî Õã
î Õãî Õãî Õãñî Õåî Õåî Õåî Õåî Õåî$ Õå ñî Õçî Õçî Õçî Õçî Õçî$ Õç ñî Õéî Õéî Õéî Õéî Õéî  Õéìî Õèî Õèî Õèíî  Õê î Õêóî  Õí î	 Õí	î Õíî Õíî" Õí#î$ Õí%î, Õí-õî Õìî Õîî	 Õîî Õîî Õîî Õîî Õîî' Õî#î, Õî(î3 Õî/î4 Õî0öî Õïî	 Õïî Õïî Õïî Õïî" Õïî* Õï&î/ Õï+î6 Õï2î7 Õï3öî Õñî	 Õñî Õñî Õñî Õñî  Õñî( Õñ$î- Õñ)î5 Õñ1î6 Õñ2íî Õóî Õóîî Õòî Õòî Õòî Õòîî Õôî Õôî Õôî" Õôíî	 Õöî
 Õöõî Õúî Õùî	 Õùî Õùî Õùî Õùî Õùî' Õù#î, Õù(î1 Õù-î2 Õù.öî Õûî	 Õûî Õûî Õûî Õûî" Õûî* Õû&î/ Õû+î4 Õû0î5 Õû1öî Õüî	 Õüî Õüî Õüî Õüî! Õüî) Õü%î. Õü*î6 Õü2î7 Õü3íî Õ†î Õ†îî Õ°î Õ°î Õ°î Õ°îî Õ¢î Õ¢î Õ¢î" Õ¢íî	 Õ£î
 Õ£õî Õ•î Õ¶î	 Õ¶î Õ¶î Õ¶î Õ¶î Õ¶î' Õ¶#î, Õ¶(î4 Õ¶0î5 Õ¶1öî Õßî	 Õßî Õßî Õßî Õßî  Õßî( Õß$î- Õß)î2 Õß.î3 Õß/öî Õ®î	 Õ®î Õ®î Õ®î Õ®î! Õ®î) Õ®%î. Õ®*î3 Õ®/î4 Õ®0íî Õ©î Õ©îî Õ™î Õ™î Õ™î Õ™îî Õ´î Õ´î Õ´î" Õ´íî	 Õ¨î
 Õ¨õî ÕÆî ÕØî	 ÕØî ÕØî ÕØî ÕØî" ÕØî* ÕØ&î/ ÕØ+î7 ÕØ3î8 ÕØ4öî Õ∞î	 Õ∞î Õ∞î Õ∞î Õ∞î  Õ∞î( Õ∞$î- Õ∞)î4 Õ∞0î5 Õ∞1öî Õ±î	 Õ±î Õ±î Õ±î Õ±î! Õ±î) Õ±%î. Õ±*î5 Õ±1î6 Õ±2íî Õ≤î Õ≤îî Õ≥î Õ≥î Õ≥î Õ≥îî Õ¥î Õ¥î Õ¥î Õ¥íî	 Õµî
 Õµíî  Õ∂ î Õ∂ïî  Õ∏ î	 Õ∏	î Õ∏î Õ∏î$ Õ∏%úî Õπî
 Õπî Õπ
î Õπî Õπî* Õπ(î, Õπ*î2 Õπ0î4 Õπ2î7 Õπ5î? Õπ=îÃ@ Õπ=ôî Õªî
 Õªî Õªî Õªî% Õª#î& Õª$î. Õª,î/ Õª-î0 Õª-ôî Õºî
 Õºî Õºî Õºî# Õº!î$ Õº"î, Õº*î- Õº+î. Õº+õî Õæî Õæ	î Õæî Õæî Õæî Õæî Õæî Õæî Õæî Õæî  Õæîî Õøî Õøî Õø
î Õøîî Õ¿î Õ¿	î Õ¿î Õ¿òî Õ¡î Õ¡î Õ¡î Õ¡î Õ¡î# Õ¡î$ Õ¡ î( Õ¡$íî Õ¬î Õ¬îî Õ√î Õ√î Õ√î Õ√íî Õƒî Õƒ	íî Õ≈î Õ≈	îî Õ∆î Õ∆î Õ∆î Õ∆íî  Õ« î Õ«ïî  Õ… î	 Õ…	î Õ…î Õ…î$ Õ…%òî Õ î
 Õ î Õ 
î Õ î Õ î" Õ  î* Õ (î+ Õ (‹ î ÕÃî ÕÃ	î ÕÃî ÕÃî  ÕÃî! ÕÃî' ÕÃ%î( ÕÃ&î* ÕÃ(î+ ÕÃ)î, ÕÃ*î. ÕÃ,î4 ÕÃ2î6 ÕÃ4î7 ÕÃ5î8 ÕÃ6î9 ÕÃ6íî  ÕÕ î ÕÕïî  Õœ î	 Õœ	î Õœî Õœî# Õœ$öî Õ–î Õ–î Õ–î Õ–î Õ–î# Õ–!î$ Õ–"î- Õ–+î. Õ–,î/ Õ–,òî Õ—î Õ—	î Õ—î Õ—î Õ—î Õ—î' Õ—%î( Õ—%íî  Õ“ î Õ“ïî  Õ‘ î	 Õ‘	î Õ‘î Õ‘î Õ‘ôî Õ’î Õ’î	 Õ’î Õ’î Õ’î Õ’î Õ’î Õ’î  Õ’íî  Õ÷ î Õ÷‘rGñßversion§fileßsourcesÆsourcesContent•names®mappings¿ë¿ë¿ê‹6ëî    ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî  	 ëî  
 ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî   ëî    ëî  ! ëî  " ëî  # ëî  $ ëî  % ëî  & ëî  ' ëî  ( ëî  ) ëî  * ëî  + ëî  , ëî  - ëî  . ëî  / ëî  0 ëî  1 ëî  2 ëî  3 ëî  4 ëî  5 ëî  6 ëî  7 ëî  8 ëî  9 ëî  : ëî  ; ëî  < ëî  = ëî  > ëî  ? ëî  Ã@ ëî  ÃA ëî  ÃB ëî  ÃC ëî  ÃD ëî  ÃE ëî  ÃF ëî  ÃG ëî  ÃH ëî  ÃI ëî  ÃJ ëî  ÃK ëî  ÃL ëî  ÃM ëî  ÃN ëî  ÃO ëî  ÃP ëî  ÃQ ëî  ÃR ëî  ÃS ëî  ÃT ëî  ÃU ëî  ÃV ëî  ÃW ëî  ÃX ëî  ÃY ëî  ÃZ ëî  Ã[ ëî  Ã\ ëî  Ã] ëî  Ã^ ëî  Ã_ ëî  Ã` ëî  Ãa ëî  Ãb ëî  Ãc ëî  Ãd ëî  Ãe ëî  Ãf ëî  Ãg ëî  Ãh ëî  Ãi ëî  Ãj ëî  Ãk ëî  Ãl ëî  Ãm ëî  Ãn ëî  Ão ëî  Ãp ëî  Ãq ëî  Ãr ëî  Ãs ëî  Ãt ëî  Ãu ëî  Ãv ëî  Ãw ëî  Ãx ëî  Ãy ëî  Ãz ëî  Ã{ ëî  Ã| ëî  Ã} ëî  Ã~ ëî  Ã ëî  ÃÄ ëî  ÃÅ ëî  ÃÇ ëî  ÃÉ ëî  ÃÑ ëî  ÃÖ ëî  ÃÜ ëî  Ãá ëî  Ãà ëî  Ãâ ëî  Ãä ëî  Ãã ëî  Ãå ëî  Ãç ëî  Ãé ëî  Ãè ëî  Ãê ëî  Ãë ëî  Ãí ëî  Ãì ëî  Ãî ëî  Ãï ëî  Ãñ ëî  Ãó ëî  Ãò ëî  Ãô ëî  Ãö ëî  Ãõ ëî  Ãú ëî  Ãù ëî  Ãû ëî  Ãü ëî  Ã† ëî  Ã° ëî  Ã¢ ëî  Ã£ ëî  Ã§ ëî  Ã• ëî  Ã¶ ëî  Ãß ëî  Ã® ëî  Ã© ëî  Ã™ ëî  Ã´ ëî  Ã¨ ëî  Ã≠ ëî  ÃÆ ëî  ÃØ ëî  Ã∞ ëî  Ã± ëî  Ã≤ ëî  Ã≥ ëî  Ã¥ ëî  Ãµ ëî  Ã∂ ëî  Ã∑ ëî  Ã∏ ëî  Ãπ ëî  Ã∫ ëî  Ãª ëî  Ãº ëî  ÃΩ ëî  Ãæ ëî  Ãø ëî  Ã¿ ëî  Ã¡ ëî  Ã¬ ëî  Ã√ ëî  Ãƒ ëî  Ã≈ ëî  Ã∆ ëî  Ã« ëî  Ã» ëî  Ã… ëî  Ã  ëî  ÃÀ ëî  ÃÃ ëî  ÃÕ ëî  ÃŒ ëî  Ãœ ëî  Ã– ëî  Ã— ëî  Ã“ ëî  Ã” ëî  Ã‘ ëî  Ã’ ëî  Ã÷ ëî  Ã◊ ëî  Ãÿ ëî  ÃŸ ëî  Ã⁄ ëî  Ã€ ëî  Ã‹ ëî  Ã› ëî  Ãﬁ ëî  Ãﬂ ëî  Ã‡ ëî  Ã· ëî  Ã‚ ëî  Ã„ ëî  Ã‰ ëî  ÃÂ ëî  ÃÊ ëî  ÃÁ ëî  ÃË ëî  ÃÈ ëî  ÃÍ ëî  ÃÎ ëî  ÃÏ ëî  ÃÌ ëî  ÃÓ ëî  ÃÔ ëî  Ã ëî  ÃÒ ëî  ÃÚ ëî  ÃÛ ëî  ÃÙ ëî  Ãı ëî  Ãˆ ëî  Ã˜ ëî  Ã¯ ëî  Ã˘ ëî  Ã˙ ëî  Ã˚ ëî  Ã¸ ëî  Ã˝ ëî  Ã˛ ëî  Ãˇ ëî  Õ  ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ	 ëî  Õ
 ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ  ëî  Õ! ëî  Õ" ëî  Õ# ëî  Õ$ ëî  Õ% ëî  Õ& ëî  Õ' ëî  Õ( ëî  Õ) ëî  Õ* ëî  Õ+ ëî  Õ, ëî  Õ- ëî  Õ. ëî  Õ/ ëî  Õ0 ëî  Õ1 ëî  Õ2 ëî  Õ3 ëî  Õ4 ëî  Õ5 ëî  Õ6 ëî  Õ7 ëî  Õ8 ëî  Õ9 ëî  Õ: ëî  Õ; ëî  Õ< ëî  Õ= ëî  Õ> ëî  Õ? ëî  Õ@ ëî  ÕA ëî  ÕB ëî  ÕC ëî  ÕD ëî  ÕE ëî  ÕF ëî  ÕG ëî  ÕH ëî  ÕI ëî  ÕJ ëî  ÕK ëî  ÕL ëî  ÕM ëî  ÕN ëî  ÕO ëî  ÕP ëî  ÕQ ëî  ÕR ëî  ÕS ëî  ÕT ëî  ÕU ëî  ÕV ëî  ÕW ëî  ÕX ëî  ÕY ëî  ÕZ ëî  Õ[ ëî  Õ\ ëî  Õ] ëî  Õ^ ëî  Õ_ ëî  Õ` ëî  Õa ëî  Õb ëî  Õc ëî  Õd ëî  Õe ëî  Õf ëî  Õg ëî  Õh ëî  Õi ëî  Õj ëî  Õk ëî  Õl ëî  Õm ëî  Õn ëî  Õo ëî  Õp ëî  Õq ëî  Õr ëî  Õs ëî  Õt ëî  Õu ëî  Õv ëî  Õw ëî  Õx ëî  Õy ëî  Õz ëî  Õ{ ëî  Õ| ëî  Õ} ëî  Õ~ ëî  Õ ëî  ÕÄ ëî  ÕÅ ëî  ÕÇ ëî  ÕÉ ëî  ÕÑ ëî  ÕÖ ëî  ÕÜ ëî  Õá ëî  Õà ëî  Õâ ëî  Õä ëî  Õã ëî  Õå ëî  Õç ëî  Õé ëî  Õè ëî  Õê ëî  Õë ëî  Õí ëî  Õì ëî  Õî ëî  Õï ëî  Õñ ëî  Õó ëî  Õò ëî  Õô ëî  Õö ëî  Õõ ëî  Õú ëî  Õù ëî  Õû ëî  Õü ëî  Õ† ëî  Õ° ëî  Õ¢ ëî  Õ£ ëî  Õ§ ëî  Õ• ëî  Õ¶ ëî  Õß ëî  Õ® ëî  Õ© ëî  Õ™ ëî  Õ´ ëî  Õ¨ ëî  Õ≠ ëî  ÕÆ ëî  ÕØ ëî  Õ∞ ëî  Õ± ëî  Õ≤ ëî  Õ≥ ëî  Õ¥ ëî  Õµ ëî  Õ∂ ëî  Õ∑ ëî  Õ∏ ëî  Õπ ëî  Õ∫ ëî  Õª ëî  Õº ëî  ÕΩ ëî  Õæ ëî  Õø ëî  Õ¿ ëî  Õ¡ ëî  Õ¬ ëî  Õ√ ëî  Õƒ ëî  Õ≈ ëî  Õ∆ ëî  Õ« ëî  Õ» ëî  Õ… ëî  Õ  ëî  ÕÀ ëî  ÕÃ ëî  ÕÕ ëî  ÕŒ ëî  Õœ ëî  Õ– ëî  Õ— ëî  Õ“ ëî  Õ” ëî  Õ‘ ëî  Õ’ ëî  Õ÷ ëî  Õ◊ ëî  Õÿ ëî  ÕŸ ëî  Õ⁄ ëî  Õ€ ëî  Õ‹ ëî  Õ› ëî  Õﬁ ëî  Õﬂ ëî  Õ‡ ëî  Õ· ëî  Õ‚ ëî  Õ„ ëî  Õ‰ ëî  ÕÂ ëî  ÕÊ ëî  ÕÁ ëî  ÕË ëî  ÕÈ ëî  ÕÍ ëî  ÕÎ ëî  ÕÏ ëî  ÕÌ ëî  ÕÓ ëî  ÕÔ ëî  Õ ëî  ÕÒ ëî  ÕÚ ëî  ÕÛ ëî  ÕÙ ëî  Õı ëî  Õˆ ëî  Õ˜ ëî  Õ¯ ëî  Õ˘ ëî  Õ˙ ëî  Õ˚ ëî  Õ¸ ëî  Õ˝ ëî  Õ˛ ëî  Õˇ ëî  Õ  ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ	 ëî  Õ
 ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ  ëî  Õ! ëî  Õ" ëî  Õ# ëî  Õ$ ëî  Õ% ëî  Õ& ëî  Õ' ëî  Õ( ëî  Õ) ëî  Õ* ëî  Õ+ ëî  Õ, ëî  Õ- ëî  Õ. ëî  Õ/ ëî  Õ0 ëî  Õ1 ëî  Õ2 ëî  Õ3 ëî  Õ4 ëî  Õ5 ëî  Õ6 ëî  Õ7 ëî  Õ8 ëî  Õ9 ëî  Õ: ëî  Õ; ëî  Õ< ëî  Õ= ëî  Õ> ëî  Õ? ëî  Õ@ ëî  ÕA ëî  ÕB ëî  ÕC ëî  ÕD ëî  ÕE ëî  ÕF ëî  ÕG ëî  ÕH ëî  ÕI ëî  ÕJ ëî  ÕK ëî  ÕL ëî  ÕM ëî  ÕN ëî  ÕO ëî  ÕP ëî  ÕQ ëî  ÕR ëî  ÕS ëî  ÕT ëî  ÕU ëî  ÕV ëî  ÕW ëî  ÕX ëî  ÕY ëî  ÕZ ëî  Õ[ ëî  Õ\ ëî  Õ] ëî  Õ^ ëî  Õ_ ëî  Õ` ëî  Õa ëî  Õb ëî  Õc ëî  Õd ëî  Õe ëî  Õf ëî  Õg ëî  Õh ëî  Õi ëî  Õj ëî  Õk ëî  Õl ëî  Õm ëî  Õn ëî  Õo ëî  Õp ëî  Õq ëî  Õr ëî  Õs ëî  Õt ëî  Õu ëî  Õv ëî  Õw ëî  Õx ëî  Õy ëî  Õz ëî  Õ{ ëî  Õ| ëî  Õ} ëî  Õ~ ëî  Õ ëî  ÕÄ ëî  ÕÅ ëî  ÕÇ ëî  ÕÉ ëî  ÕÑ ëî  ÕÖ ëî  ÕÜ ëî  Õá ëî  Õà ëî  Õâ ëî  Õä ëî  Õã ëî  Õå ëî  Õç ëî  Õé ëî  Õè ëî  Õê ëî  Õë ëî  Õí ëî  Õì ëî  Õî ëî  Õï ëî  Õñ ëî  Õó ëî  Õò ëî  Õô ëî  Õö ëî  Õõ ëî  Õú ëî  Õù ëî  Õû ëî  Õü ëî  Õ† ëî  Õ° ëî  Õ¢ ëî  Õ£ ëî  Õ§ ëî  Õ• ëî  Õ¶ ëî  Õß ëî  Õ® ëî  Õ© ëî  Õ™ ëî  Õ´ ëî  Õ¨ ëî  Õ≠ ëî  ÕÆ ëî  ÕØ ëî  Õ∞ ëî  Õ± ëî  Õ≤ ëî  Õ≥ ëî  Õ¥ ëî  Õµ ëî  Õ∂ ëî  Õ∑ ëî  Õ∏ ëî  Õπ ëî  Õ∫ ëî  Õª ëî  Õº ëî  ÕΩ ëî  Õæ ëî  Õø ëî  Õ¿ ëî  Õ¡ ëî  Õ¬ ëî  Õ√ ëî  Õƒ ëî  Õ≈ ëî  Õ∆ ëî  Õ« ëî  Õ» ëî  Õ… ëî  Õ  ëî  ÕÀ ëî  ÕÃ ëî  ÕÕ ëî  ÕŒ ëî  Õœ ëî  Õ– ëî  Õ— ëî  Õ“ ëî  Õ” ëî  Õ‘ ëî  Õ’ ëî  Õ÷ ëî  Õ◊ ëî  Õÿ ëî  ÕŸ ëî  Õ⁄ ëî  Õ€ ëî  Õ‹ ëî  Õ› ëî  Õﬁ ëî  Õﬂ ëî  Õ‡ ëî  Õ· ëî  Õ‚ ëî  Õ„ ëî  Õ‰ ëî  ÕÂ ëî  ÕÊ ëî  ÕÁ ëî  ÕË ëî  ÕÈ ëî  ÕÍ ëî  ÕÎ ëî  ÕÏ ëî  ÕÌ ëî  ÕÓ ëî  ÕÔ ëî  Õ ëî  ÕÒ ëî  ÕÚ ëî  ÕÛ ëî  ÕÙ ëî  Õı ëî  Õˆ ëî  Õ˜ ëî  Õ¯ ëî  Õ˘ ëî  Õ˙ ëî  Õ˚ ëî  Õ¸ ëî  Õ˝ ëî  Õ˛ ëî  Õˇ ëî  Õ  ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ	 ëî  Õ
 ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ ëî  Õ  ëî  Õ! ëî  Õ" ëî  Õ# ëî  Õ$ ëî  Õ% ëî  Õ& ëî  Õ' ëî  Õ( ëî  Õ) ëî  Õ* ëî  Õ+ ëî  Õ, ëî  Õ- ëî  Õ. ëî  Õ/ ëî  Õ0 ëî  Õ1 ëî  Õ2 ëî  Õ3 ëî  Õ4 ëî  Õ5 ‘rHíßmissing¶plugin√¶genAbc¬ê‘  ‘rIî≤dynamicImportCacheπexportAllDeclarationCacheªexportNamedDeclarationCache´importCacheêêë‘rJñ§type•start£end´declaration™specifiers¶source∂ExportNamedDeclarationÕÊÕ¨‘rKô§type•start£end¢id™expression©generator•async¶params§body≥FunctionDeclarationÕÌÕ¨‘rLî§type•start£end§name™IdentifierÕ¸Õ §axis¬¬√íL™IdentifierÕÕ•chartL™IdentifierÕÕ¶option‘rMî§type•start£end§bodyÆBlockStatementÕÕ¨ö‘rNî§type•start£end™expression≥ExpressionStatementÕàÕπ‘rOñ§type•start£end®operator§left•right¥AssignmentExpressionÕàÕ∏°=L™IdentifierÕàÕò∞callbackSendable‘rPñ§type•start£end§left®operator•right±LogicalExpressionÕõÕ∏‘rQó§type•start£end¶object®property®computed®optional∞MemberExpressionÕõÕ≤L™IdentifierÕõÕ†•chartL™IdentifierÕ°Õ≤±sendableTestClass¬¬¢||‘rRî§type•start£end™properties∞ObjectExpressionÕ∂Õ∏ê‘rSï§type•start£end¨declarations§kind≥VariableDeclarationÕøÕÂë‘rTï§type•start£end¢id§init≤VariableDeclaratorÕ√Õ‰R≠ObjectPatternÕ√Õ€ì‘rUô§type•start£end¶method©shorthand®computed£key§kind•value®PropertyÕ≈Õ ¬√¬L™IdentifierÕ≈Õ •xAxis§initL™IdentifierÕ≈Õ •xAxisU®PropertyÕÃÕ—¬√¬L™IdentifierÕÃÕ—•yAxis§initL™IdentifierÕÃÕ—•yAxisU®PropertyÕ”ÕŸ¬√¬L™IdentifierÕ”ÕŸ¶series§initL™IdentifierÕ”ÕŸ¶seriesL™IdentifierÕﬁÕ‰¶option£letS≥VariableDeclarationÕÎÕ¸ëT≤VariableDeclaratorÕÔÕ˚L™IdentifierÕÔÕˆßallAxis‘rVî§type•start£end®elementsØArrayExpressionÕ˘Õ˚ê£let‘rWñ§type•start£end§test™consequent©alternate´IfStatementÕ$ÕgP±LogicalExpressionÕ(Õ@P±LogicalExpressionÕ(Õ6L™IdentifierÕ(Õ-•xAxis¢&&L™IdentifierÕ1Õ6•yAxis¢&&L™IdentifierÕ:Õ@¶seriesMÆBlockStatementÕBÕgöN≥ExpressionStatementÕMÕpO¥AssignmentExpressionÕMÕo°=L™IdentifierÕMÕTßallAxis‘rXñ§type•start£end¶callee©arguments®optionalÆCallExpressionÕWÕoL™IdentifierÕWÕa™getAllAxisíL™IdentifierÕbÕg•xAxisL™IdentifierÕiÕn•yAxis¬N≥ExpressionStatementÕzÕ§O¥AssignmentExpressionÕzÕ£°=L™IdentifierÕzÕÅßallAxisXÆCallExpressionÕÑÕ£L™IdentifierÕÑÕö∂mergeDefaultAxisConfigëL™IdentifierÕõÕ¢ßallAxis¬N≥ExpressionStatementÕÆÕ€O¥AssignmentExpressionÕÆÕ⁄°=L™IdentifierÕÆÕµßallAxisXÆCallExpressionÕ∏Õ⁄Q∞MemberExpressionÕ∏Õ∆L™IdentifierÕ∏ÕøßallAxisL™IdentifierÕ¿Õ∆¶filter¬¬ëK∑ArrowFunctionExpressionÕ«ÕŸ¿√¬¬ëR≠ObjectPatternÕ»Õ–ëU®PropertyÕ ÕŒ¬√¬L™IdentifierÕ ÕŒ§show§initL™IdentifierÕ ÕŒ§showL™IdentifierÕ’ÕŸ§show¬N≥ExpressionStatementÕÂÕO¥AssignmentExpressionÕÂÕ°=L™IdentifierÕÂÕÏßallAxisXÆCallExpressionÕÔÕL™IdentifierÕÔÕ∑mergeDefaultBoundaryGapëL™IdentifierÕÕßallAxis¬N≥ExpressionStatementÕÕIO¥AssignmentExpressionÕÕH°=L™IdentifierÕÕ!ßallAxisXÆCallExpressionÕ$ÕHL™IdentifierÕ$Õ8¥calcAxisLinePositioníL™IdentifierÕ9Õ@ßallAxisL™IdentifierÕBÕG•chart¬N≥ExpressionStatementÕSÕáO¥AssignmentExpressionÕSÕÜ°=L™IdentifierÕSÕZßallAxisXÆCallExpressionÕ]ÕÜL™IdentifierÕ]Õn±calcAxisLabelDataìL™IdentifierÕoÕvßallAxisL™IdentifierÕxÕ~¶seriesL™IdentifierÕÄÕÖ•chart¬N≥ExpressionStatementÕëÕ¥O¥AssignmentExpressionÕëÕ≥°=L™IdentifierÕëÕòßallAxisXÆCallExpressionÕõÕ≥L™IdentifierÕõÕ™ØsetAxisPositionëL™IdentifierÕ´Õ≤ßallAxis¬N≥ExpressionStatementÕæÕÌO¥AssignmentExpressionÕæÕÏ°=L™IdentifierÕæÕ≈ßallAxisXÆCallExpressionÕ»ÕÏL™IdentifierÕ»Õ‹¥calcAxisTickPositioníL™IdentifierÕ›Õ‰ßallAxisL™IdentifierÕÊÕÎ•chart¬N≥ExpressionStatementÕ˜Õ&O¥AssignmentExpressionÕ˜Õ%°=L™IdentifierÕ˜Õ˛ßallAxisXÆCallExpressionÕÕ%L™IdentifierÕÕ¥calcAxisNamePositioníL™IdentifierÕÕßallAxisL™IdentifierÕÕ$•chart¬N≥ExpressionStatementÕ0Õ`O¥AssignmentExpressionÕ0Õ_°=L™IdentifierÕ0Õ7ßallAxisXÆCallExpressionÕ:Õ_L™IdentifierÕ:ÕOµcalcSplitLinePositioníL™IdentifierÕPÕWßallAxisL™IdentifierÕYÕ^•chart¬¿N≥ExpressionStatementÕmÕ˙XÆCallExpressionÕmÕ˘L™IdentifierÕmÕu®doUpdateëR∞ObjectExpressionÕvÕ¯î‘rYô§type•start£end¶method©shorthand®computed£key•value§kind®PropertyÕÅÕè¬¬¬‘rZï§type•start£end•value£rawßLiteralÕÅÕà•chartß'chart'L™IdentifierÕäÕè•chart§initY®PropertyÕöÕ´¬¬¬ZßLiteralÕöÕ¢¶series®'series'L™IdentifierÕ§Õ´ßallAxis§initY®PropertyÕ∂Õ«¬¬¬ZßLiteralÕ∂Õª£key•'key'ZßLiteralÕΩÕ«®axisLine™'axisLine'§initY®PropertyÕ“ÕÒ¬¬¬ZßLiteralÕ“Õ‚ÆgetGraphConfig∞'getGraphConfig'L™IdentifierÕ‰ÕÒ≠getLineConfig§init¬N≥ExpressionStatementÕNÕÃXÆCallExpressionÕNÕÀL™IdentifierÕNÕV®doUpdateëR∞ObjectExpressionÕWÕ îU®PropertyÕbÕg¬√¬L™IdentifierÕbÕg•chart§initL™IdentifierÕbÕg•chartY®PropertyÕrÕÅ¬¬¬L™IdentifierÕrÕx¶seriesL™IdentifierÕzÕÅßallAxis§initY®PropertyÕåÕõ¬¬¬L™IdentifierÕåÕè£keyZßLiteralÕëÕõ®axisTick™'axisTick'§initY®PropertyÕ¶Õ√¬¬¬L™IdentifierÕ¶Õ¥ÆgetGraphConfigL™IdentifierÕ∂Õ√≠getTickConfig§init¬N≥ExpressionStatementÕ Õ†XÆCallExpressionÕ ÕüL™IdentifierÕ Õ(®doUpdateëR∞ObjectExpressionÕ)ÕûîU®PropertyÕ4Õ9¬√¬L™IdentifierÕ4Õ9•chart§initL™IdentifierÕ4Õ9•chartY®PropertyÕDÕS¬¬¬L™IdentifierÕDÕJ¶seriesL™IdentifierÕLÕSßallAxis§initY®PropertyÕ^Õn¬¬¬L™IdentifierÕ^Õa£keyZßLiteralÕcÕn©axisLabel´'axisLabel'§initY®PropertyÕyÕó¬¬¬L™IdentifierÕyÕáÆgetGraphConfigL™IdentifierÕâÕóÆgetLabelConfig§init¬N≥ExpressionStatementÕÙÕrXÆCallExpressionÕÙÕqL™IdentifierÕÙÕ¸®doUpdateëR∞ObjectExpressionÕ˝ÕpîU®PropertyÕÕ¬√¬L™IdentifierÕÕ•chart§initL™IdentifierÕÕ•chartY®PropertyÕÕ'¬¬¬L™IdentifierÕÕ¶seriesL™IdentifierÕ Õ'ßallAxis§initY®PropertyÕ2ÕA¬¬¬L™IdentifierÕ2Õ5£keyZßLiteralÕ7ÕA®axisName™'axisName'§initY®PropertyÕLÕi¬¬¬L™IdentifierÕLÕZÆgetGraphConfigL™IdentifierÕ\Õi≠getNameConfig§init¬N≥ExpressionStatementÕ∆Õ	JXÆCallExpressionÕ∆Õ	IL™IdentifierÕ∆ÕŒ®doUpdateëR∞ObjectExpressionÕœÕ	HîU®PropertyÕ⁄Õﬂ¬√¬L™IdentifierÕ⁄Õﬂ•chart§initL™IdentifierÕ⁄Õﬂ•chartY®PropertyÕÍÕ˘¬¬¬L™IdentifierÕÍÕ¶seriesL™IdentifierÕÚÕ˘ßallAxis§initY®PropertyÕ	Õ	¬¬¬L™IdentifierÕ	Õ	£keyZßLiteralÕ		Õ	©splitLine´'splitLine'§initY®PropertyÕ	Õ	A¬¬¬L™IdentifierÕ	Õ	-ÆgetGraphConfigL™IdentifierÕ	/Õ	A≤getSplitLineConfig§init¬N≥ExpressionStatementÕêÕ©O¥AssignmentExpressionÕêÕ®°=Q∞MemberExpressionÕêÕûL™IdentifierÕêÕï•chartL™IdentifierÕñÕû®axisData¬¬L™IdentifierÕ°Õ®ßallAxisê¿ï‘r[ï§type•start£end™specifiers¶source±ImportDeclaration 2ë‘r\ï§type•start£end®imported•localØImportSpecifier	L™Identifier	®doUpdateL™Identifier	®doUpdateZßLiteral1∂../class/updater.class∏'../class/updater.class'[±ImportDeclaration4Ãií\ØImportSpecifier=ÃHL™Identifier=ÃH´xAxisConfigL™Identifier=ÃH´xAxisConfig\ØImportSpecifierÃJÃUL™IdentifierÃJÃU´yAxisConfigL™IdentifierÃJÃU´yAxisConfigZßLiteralÃ]Ãh©../config´'../config'[±ImportDeclarationÃkÃ·ó\ØImportSpecifierÃtÃÉL™IdentifierÃtÃÉØfilterNonNumberL™IdentifierÃtÃÉØfilterNonNumber\ØImportSpecifierÃÖÃéL™IdentifierÃÖÃé©deepMergeL™IdentifierÃÖÃé©deepMerge\ØImportSpecifierÃêÃ¢L™IdentifierÃêÃ¢≤mergeSameStackDataL™IdentifierÃêÃ¢≤mergeSameStackData\ØImportSpecifierÃ§Ã≠L™IdentifierÃ§Ã≠©drawTextsL™IdentifierÃ§Ã≠©drawTexts\ØImportSpecifierÃØÃºL™IdentifierÃØÃº≠drawBreakTextL™IdentifierÃØÃº≠drawBreakText\ØImportSpecifierÃæÃ»L™IdentifierÃæÃ»™getIndicesL™IdentifierÃæÃ»™getIndices\ØImportSpecifierÃ ÃœL™IdentifierÃ Ãœ•px2vpL™IdentifierÃ Ãœ•px2vpZßLiteralÃ◊Ã‡ß../util©'../util'[±ImportDeclarationÃ„Õí\ØImportSpecifierÃÏÃıL™IdentifierÃÏÃı©deepCloneL™IdentifierÃÏÃı©deepClone\ØImportSpecifierÃ˜ÕL™IdentifierÃ˜ÕØgetFormatterValL™IdentifierÃ˜ÕØgetFormatterValZßLiteralÕÕÆ../util/common∞'../util/common'[±ImportDeclarationÕ!ÕNë‘r]î§type•start£end•local∂ImportDefaultSpecifierÕ(Õ/L™IdentifierÕ(Õ/ßdrawingZßLiteralÕ5ÕM∂@ohos.graphics.drawing∏"@ohos.graphics.drawing"