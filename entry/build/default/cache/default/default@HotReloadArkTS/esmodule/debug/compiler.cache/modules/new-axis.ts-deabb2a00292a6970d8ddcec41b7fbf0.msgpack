Ôr@Ÿªassertions¤code´customTransformCache¬dependencies¢id¤meta±moduleSideEffects¬originalCode±originalSourcemap«resolvedIds®sourcemapChainµsyntheticNamedExportsµtransformDependencies®transformFiles¨cacheAstÔrAÚvæimport { doUpdate } from '../class/updater.class';
import { xAxisConfig, yAxisConfig } from '../config';
import { filterNonNumber, deepMerge, mergeSameStackData, drawTexts, drawBreakText, getIndices, px2vp } from '../util';
import { deepClone, getFormatterVal } from '../util/common';
import drawing from "@ohos.graphics.drawing";
const axisConfig = { xAxisConfig, yAxisConfig };
const { min, max, abs, pow } = Math;
let callbackSendable = null;
let font = new drawing.Font();
export async function axis(chart, option) {
    // let dataZoom = {
    //   show: false,
    //   start: 0,
    //   end: 0,
    //   num: 1
    // }
    callbackSendable = chart.sendableTestClass || {};
    let { xAxis, yAxis, series } = option;
    let allAxis = [];
    // dataZoom = chart.dataZoom
    if (xAxis && yAxis && series) {
        allAxis = getAllAxis(xAxis, yAxis);
        allAxis = mergeDefaultAxisConfig(allAxis);
        allAxis = allAxis.filter(({ show }) => show);
        allAxis = mergeDefaultBoundaryGap(allAxis);
        allAxis = calcAxisLinePosition(allAxis, chart);
        allAxis = calcAxisLabelData(allAxis, series, chart);
        allAxis = setAxisPosition(allAxis);
        allAxis = calcAxisTickPosition(allAxis, chart);
        allAxis = calcAxisNamePosition(allAxis, chart);
        allAxis = calcSplitLinePosition(allAxis, chart);
    }
    doUpdate({
        'chart': chart,
        'series': allAxis,
        'key': 'axisLine',
        'getGraphConfig': getLineConfig
    });
    // const time52 = Date.now()
    // console.log('æ—¶é—´5.2', time52-time51)
    doUpdate({
        chart,
        series: allAxis,
        key: 'axisTick',
        getGraphConfig: getTickConfig
    });
    // const time53 = Date.now()
    // console.log('æ—¶é—´5.3', time53-time52)
    doUpdate({
        chart,
        series: allAxis,
        key: 'axisLabel',
        getGraphConfig: getLabelConfig
    });
    // const time54 = Date.now()
    // console.log('æ—¶é—´5.4', time54-time53)
    doUpdate({
        chart,
        series: allAxis,
        key: 'axisName',
        getGraphConfig: getNameConfig
    });
    // const time55 = Date.now()
    // console.log('æ—¶é—´5.5', time55-time54)
    doUpdate({
        chart,
        series: allAxis,
        key: 'splitLine',
        getGraphConfig: getSplitLineConfig
    });
    // await Promise.all([
    //   doUpdate({
    //     'chart': chart,
    //     'series': allAxis,
    //     'key': 'axisLine',
    //     'getGraphConfig': getLineConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'axisTick',
    //     getGraphConfig: getTickConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'axisLabel',
    //     getGraphConfig: getLabelConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'axisName',
    //     getGraphConfig: getNameConfig
    //   }),
    //   doUpdate({
    //     chart,
    //     series: allAxis,
    //     key: 'splitLine',
    //     getGraphConfig: getSplitLineConfig
    //   })
    // ]);
    chart.axisData = allAxis;
}
function asyncTask(callBack) {
    return callBack();
}
function getAllAxis(xAxis, yAxis) {
    let [allXAxis, allYAxis] = [[], []];
    if (xAxis instanceof Array) {
        allXAxis.push(...xAxis);
    }
    else {
        allXAxis.push(xAxis);
    }
    if (yAxis instanceof Array) {
        allYAxis.push(...yAxis);
    }
    else {
        allYAxis.push(yAxis);
    }
    allXAxis.splice(2);
    allYAxis.splice(2);
    allXAxis = allXAxis.map((axis, i) => ({ ...axis, index: i, axis: 'x' }));
    allYAxis = allYAxis.map((axis, i) => ({ ...axis, index: i, axis: 'y' }));
    return [...allXAxis, ...allYAxis];
}
function mergeDefaultAxisConfig(allAxis) {
    let xAxis = allAxis.filter(({ axis }) => axis === 'x');
    let yAxis = allAxis.filter(({ axis }) => axis === 'y');
    xAxis = xAxis.map(axis => deepMerge(deepClone(xAxisConfig), axis));
    yAxis = yAxis.map(axis => deepMerge(deepClone(yAxisConfig), axis));
    return [...xAxis, ...yAxis];
}
function mergeDefaultBoundaryGap(allAxis) {
    const valueAxis = allAxis.filter(({ type }) => type === 'value');
    const labelAxis = allAxis.filter(({ type }) => type !== 'value');
    valueAxis.forEach(axis => {
        if (typeof axis.boundaryGap === 'boolean')
            return;
        axis.boundaryGap = false;
    });
    labelAxis.forEach(axis => {
        if (typeof axis.boundaryGap === 'boolean')
            return;
        axis.boundaryGap = true;
    });
    return [...valueAxis, ...labelAxis];
}
function calcAxisLabelData(allAxis, series, chart) {
    const { dataZoom } = chart;
    let valueAxis = allAxis.filter(({ type }) => type === 'value');
    let labelAxis = allAxis.filter(({ data }) => data instanceof Array);
    valueAxis = calcValueAxisLabelData(valueAxis, series, dataZoom);
    labelAxis = calcLabelAxisLabelData(labelAxis, dataZoom);
    return [...valueAxis, ...labelAxis];
}
function calcValueAxisLabelData(valueAxis, series, dataZoom) {
    return valueAxis.map(axis => {
        const minMaxValue = getValueAxisMaxMinValue(axis, series, dataZoom);
        const [min, max] = getTrueMinMax(axis, minMaxValue);
        const interval = getValueInterval(min, max, axis);
        const { axisLabel: { formatter } } = axis;
        let label = [];
        if (min < 0 && max > 0) {
            label = getValueAxisLabelFromZero(min, max, interval, axis);
        }
        else {
            label = getValueAxisLabelFromMin(min, max, interval);
        }
        label = label.map(l => parseFloat(l.toFixed(2)));
        return {
            ...axis,
            labelData: label,
            maxValue: label.slice(-1)[0],
            minValue: label[0],
            label: getAfterFormatterLabel(dataZoom, label, formatter)
        };
    });
}
// // æ¥è®¡ç®—ç»™å®šæ•°ç»„ä¸­æ¯å¯¹è¿ç»­å…ƒç´ ä¹‹é—´çš„å·®å€¼
// function calculateDifferences(arr) {
//   let differences = [];
//   for (let i = 0; i < arr.length - 1; i++) {
//     differences.push(Number(arr[i + 1]) - Number(arr[i]));
//   }
//   return differences;
// }
function getValueAxisMaxMinValue(axis, series, dataZoom) {
    series = series.filter(({ show, type }) => {
        if (show === false)
            return false;
        if (type === 'pie')
            return false;
        return true;
    });
    if (series.length === 0)
        return [0, 0];
    const { index, axis: axisType } = axis;
    series = mergeStackData(series, dataZoom);
    const axisName = axisType + 'Axis';
    let valueSeries = series.filter(s => s[axisName] === index);
    if (!valueSeries.length)
        valueSeries = series;
    return getSeriesMinMaxValue(valueSeries, dataZoom);
}
function getSeriesMinMaxValue(series, dataZoom) {
    if (!series)
        return;
    const dataZoomValue = function (data) {
        if (dataZoom && dataZoom.show) {
            data = data.filter((item, i) => (i >= dataZoom.start && i <= dataZoom.end));
        }
        return data;
    };
    let seriesData = [];
    series
        .map(({ data }) => {
        if (data && data.length) {
            // data = dataZoomValue(data)
            seriesData = [...seriesData, ...filterNonNumber(data)];
        }
        else {
            seriesData = [...seriesData, 0];
        }
    });
    const minValue = Math.min(...seriesData, 0);
    const maxValue = Math.max(...seriesData, 10);
    return [minValue, maxValue];
}
function mergeStackData(series, dataZoom) {
    const seriesCloned = JSON.parse(JSON.stringify(series));
    seriesCloned.forEach((item, i) => {
        if (dataZoom && dataZoom.show) {
            item.data = item.data.slice(dataZoom.start, dataZoom.end + 1);
        }
        const data = mergeSameStackData(item, series);
        item.data = data;
    });
    return seriesCloned;
}
function getTrueMinMax(axisJson, minMaxValue) {
    let { min, max, axis, splitNumber } = axisJson;
    let [minValue, maxValue] = minMaxValue;
    if (min === null) {
        min = '20%';
    }
    if (max === null) {
        max = '20%';
    }
    let [minType, maxType] = [typeof min, typeof max];
    if (!testMinMaxType(min)) {
        min = axisConfig[axis + 'AxisConfig'].min;
        minType = 'string';
    }
    if (!testMinMaxType(max)) {
        max = axisConfig[axis + 'AxisConfig'].max;
        maxType = 'string';
    }
    if (minType === 'string') {
        min = Number(String(minValue - abs(minValue * parseFloat(min) / 100)));
        const lever = getValueLever(min);
        min = Math.min(parseFloat((min / lever).toFixed(1)) * lever, 0);
        min = Math.floor(min / splitNumber) * splitNumber;
    }
    if (maxType === 'string') {
        max = Number(maxValue + abs(maxValue * parseFloat(max) / 100));
        const lever = getValueLever(max);
        max = parseFloat((max / lever).toFixed(1)) * lever;
        max = Math.ceil(max / splitNumber) * splitNumber;
    }
    return [min, max];
}
function getValueLever(value) {
    const valueString = abs(parseInt(value)).toString();
    const valueLength = valueString.length;
    const firstZeroIndex = valueString.replace(/0*$/g, '').indexOf('0');
    let pow10Num = valueLength - 1;
    if (firstZeroIndex !== -1)
        pow10Num -= firstZeroIndex;
    return pow(10, pow10Num);
}
function testMinMaxType(val) {
    const valType = typeof val;
    const isValidString = (valType === 'string' && /^\d+%$/.test(val));
    const isValidNumber = valType === 'number';
    return isValidString || isValidNumber;
}
function getValueAxisLabelFromZero(min, max, interval, axis) {
    let [negative, positive] = [[], []];
    let [currentNegative, currentPositive] = [0, 0];
    do {
        currentNegative -= interval;
        if (axis.min) {
            currentNegative = Math.max(min, currentNegative);
        }
        negative.push(currentNegative);
    } while (currentNegative > min);
    do {
        currentPositive += interval;
        if (axis.max) {
            currentPositive = Math.min(max, currentPositive);
        }
        positive.push(currentPositive);
    } while (currentPositive < max);
    return [...negative.reverse(), 0, ...positive];
}
function getValueAxisLabelFromMin(min, max, interval) {
    let [label, currentValue] = [[min], min];
    do {
        currentValue += interval;
        label.push(Math.min(currentValue, max));
    } while (currentValue < max);
    return label;
}
function getAfterFormatterLabel(dataZoom, label, formatter, type = 'val') {
    if (!formatter) {
        return getDataZoomLabel(type, label, dataZoom);
    }
    label = getDataZoomLabel(type, label, dataZoom);
    if (typeof formatter === 'string')
        label = label.map(l => getFormatterVal(callbackSendable, formatter, l));
    if (typeof formatter === 'function')
        label = label.map((value, index) => formatter(value, dataZoom && dataZoom.show ? dataZoom.start + index : index));
    return label;
}
function getDataZoomLabel(type, label, dataZoom) {
    if (dataZoom && dataZoom.show && type === 'label') {
        label = label.slice(dataZoom.start, dataZoom.end + 1);
    }
    return label;
}
function calcLabelAxisLabelData(labelAxis, dataZoom) {
    return labelAxis.map(axis => {
        const { data, axisLabel: { formatter } } = axis;
        return Object.assign({}, axis, { label: getAfterFormatterLabel(dataZoom, data, formatter, 'label') });
    });
}
function getValueInterval(min, max, axis) {
    let { interval, minInterval, maxInterval, splitNumber, axis: axisType } = axis;
    const config = axisConfig[axisType + 'AxisConfig'];
    if (typeof interval !== 'number')
        interval = config.interval;
    if (typeof minInterval !== 'number')
        minInterval = config.minInterval;
    if (typeof maxInterval !== 'number')
        maxInterval = config.maxInterval;
    if (typeof splitNumber !== 'number')
        splitNumber = config.splitNumber;
    if (typeof interval === 'number')
        return interval;
    let valueInterval = parseInt(String((max - min) / (splitNumber)));
    // if (valueInterval.toString().length > 1) valueInterval = parseInt(valueInterval.toString().replace(/\d$/, '0'))
    if (valueInterval === 0)
        valueInterval = 1;
    if (typeof minInterval === 'number' && valueInterval < minInterval)
        return minInterval;
    if (typeof maxInterval === 'number' && valueInterval > maxInterval)
        return maxInterval;
    return valueInterval;
}
function setAxisPosition(allAxis) {
    const xAxis = allAxis.filter(({ axis }) => axis === 'x');
    const yAxis = allAxis.filter(({ axis }) => axis === 'y');
    if (xAxis[0] && !xAxis[0].position)
        xAxis[0].position = xAxisConfig.position;
    if (xAxis[1] && !xAxis[1].position) {
        xAxis[1].position = xAxis[0].position === 'bottom' ? 'top' : 'bottom';
    }
    if (yAxis[0] && !yAxis[0].position)
        yAxis[0].position = yAxisConfig.position;
    if (yAxis[1] && !yAxis[1].position) {
        yAxis[1].position = yAxis[0].position === 'left' ? 'right' : 'left';
    }
    return [...xAxis, ...yAxis];
}
function calcAxisLinePosition(allAxis, chart) {
    const { x, y, w, h } = chart.gridArea;
    allAxis = allAxis.map(axis => {
        const { position } = axis;
        let linePosition = [];
        if (position === 'left') {
            linePosition = [[x, y], [x, y + h]].reverse();
        }
        else if (position === 'right') {
            linePosition = [[x + w, y], [x + w, y + h]].reverse();
        }
        else if (position === 'top') {
            linePosition = [[x, y], [x + w, y]];
        }
        else if (position === 'bottom') {
            linePosition = [[x, y + h], [x + w, y + h]];
        }
        return {
            ...axis,
            linePosition
        };
    });
    return allAxis;
}
function calcAxisTickPosition(allAxis, chart) {
    const { render, dataZoom } = chart;
    return allAxis.map((axisItem) => {
        let { type, axis, linePosition, position, label, labelData, max, min, boundaryGap, axisTick, minValue, maxValue, axisLabel: { formatter, style, interval, overflow, fontSize, width } } = axisItem;
        if (typeof boundaryGap !== 'boolean')
            boundaryGap = axisConfig[axis + 'AxisConfig'].boundaryGap;
        let labelNum = label.length;
        const [[startX, startY], [endX, endY]] = linePosition;
        const gapLength = axis === 'x' ? endX - startX : endY - startY;
        let gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1);
        const ratio = (maxValue - minValue) === 0 ? (abs(gapLength) / (maxValue - minValue)) : 0;
        // å¦‚æœæ˜¯æ»šåŠ¨æ¨¡å¼, ä¸”xè½´
        if (type === 'data' && dataZoom && dataZoom.show) {
            labelNum = Math.min(dataZoom.num, labelNum);
            gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1);
            axisItem.dataZoom = dataZoom;
        }
        else {
            axisItem.dataZoom = {};
        }
        const tickPosition = new Array(labelNum)
            .fill(0)
            .map((foo, i) => {
            if (axis === 'x') {
                if (type === 'data') {
                    return [startX + gap * (boundaryGap ? (i + 0.5) : i), startY];
                }
                else {
                    return [startX + (labelData[i] - minValue) * ratio, startY];
                }
            }
            if (type === 'data') {
                return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)];
            }
            else {
                if (min !== null || max !== null) {
                    return [startX, startY - (labelData[i] - minValue) * ratio];
                }
                else {
                    return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)];
                }
            }
        });
        if (type === 'data') {
            if (overflow && overflow !== 'none') {
                let overflowW = width ? width : axis === 'x' ? gap : startX;
                // è®¡ç®—å½“å‰æ–‡æœ¬æ˜¯å¦éœ€è¦è®¾ç½®è‡ªåŠ¨æ¢è¡Œæˆ–è€…æˆªå–
                axisItem.label = label.map((labelItem, index) => {
                    // ctx.font = `${fontSize}px`;
                    font.setSize(fontSize);
                    labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem);
                    let textI = labelItem.length;
                    if (overflow === 'truncate') {
                        textI = drawTexts(font, labelItem, overflowW);
                        labelItem = labelItem.substring(0, textI) + (textI !== labelItem.length ? '...' : '');
                    }
                    else if (overflow === 'breakAll') {
                        labelItem = drawBreakText(font, labelItem, overflowW);
                    }
                    return labelItem;
                });
            }
            // è®¡ç®—æ˜¯å¦éœ€è¦é—´éš”æ˜¾ç¤º
            interval = interval === null ? 'auto' : interval;
            if (interval === 'auto') {
                let labelTotalW = 0;
                let maxNum = 0;
                let maxText = '';
                axisItem.label.forEach((labelItem, index) => {
                    labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem);
                    if (labelItem.length > maxNum) {
                        maxNum = labelItem.length;
                        maxText = labelItem;
                    }
                });
                font.setSize(fontSize);
                const txtW = px2vp(font.measureText(String(maxText), drawing.TextEncoding.TEXT_ENCODING_UTF8));
                labelTotalW = txtW * axisItem.label.length;
                let flag = (txtW > gap) || (labelTotalW > gapLength);
                // axisItem.label.forEach((labelItem, index) => {
                //   ctx.font = `${fontSize}px`;
                //   labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
                //   // const txtW = ctx.measureText(labelItem).width; // è·å–æ–‡å­—çš„é•¿åº¦
                //   // const txtW = MeasureText.measureText({ // å»ºè®®ä½¿ç”¨ this.getUIContext().getMeasureUtils().measureText()æ¥å£
                //   //   textContent: labelItem,
                //   //   fontSize: `${fontSize}px`
                //   // }); // è·å–æ–‡å­—çš„é•¿åº¦
                //   font.setSize(fontSize);
                //   const txtW = px2vp(font.measureText(labelItem, drawing.TextEncoding.TEXT_ENCODING_UTF8))
                //   // console.log('txtW', px2vp(txtW))
                //   if (txtW > gap) {
                //     flag = true
                //   }
                //   labelTotalW += txtW
                // })
                // return result;
                if (flag) {
                    interval = Math.max(Math.round(labelTotalW / (gapLength)), 1);
                }
            }
        }
        // console.log('interval', interval)
        if (!isNaN(interval)) {
            let indices = getIndices(0, axisItem.label.length, interval);
            // if (dataZoom.show && type === 'data' &&  axis === 'x') {
            //   indices = getIndices(dataZoom.start, dataZoom.num, interval)
            // }
            // console.log('indicesindices1', JSON.stringify(indices), axis, JSON.stringify(axisItem.label))
            axisItem.label = axisItem.label.map((item, index) => {
                if (!indices.includes(index)) {
                    item = '';
                }
                return item;
            });
        }
        const tickLinePosition = getTickLinePosition(axis, boundaryGap, position, tickPosition, gap, axisTick);
        return {
            ...axisItem,
            tickPosition,
            tickLinePosition,
            tickGap: gap
        };
    });
}
function getTickLinePosition(axisType, boundaryGap, position, tickPosition, gap, axisTick) {
    let index = axisType === 'x' ? 1 : 0;
    let { length: plus = 5 } = axisTick;
    // let plus = 10
    if (axisType === 'x' && position === 'top')
        plus = -5;
    if (axisType === 'y' && position === 'left')
        plus = -5;
    let tickLinePosition = tickPosition.map(lineStart => {
        const lineEnd = deepClone(lineStart);
        lineEnd[index] += plus;
        return [deepClone(lineStart), lineEnd];
    });
    if (!boundaryGap)
        return tickLinePosition;
    index = axisType === 'x' ? 0 : 1;
    plus = gap / 2;
    tickLinePosition.forEach(([lineStart, lineEnd]) => {
        lineStart[index] += plus;
        lineEnd[index] += plus;
    });
    return tickLinePosition;
}
function calcAxisNamePosition(allAxis, chart) {
    return allAxis.map(axisItem => {
        let { nameGap, nameLocation, position, linePosition } = axisItem;
        const [lineStart, lineEnd] = linePosition;
        let namePosition = [...lineStart];
        if (nameLocation === 'end')
            namePosition = [...lineEnd];
        if (nameLocation === 'center') {
            namePosition[0] = (lineStart[0] + lineEnd[0]) / 2;
            namePosition[1] = (lineStart[1] + lineEnd[1]) / 2;
        }
        let index = 0;
        if (position === 'top' && nameLocation === 'center')
            index = 1;
        if (position === 'bottom' && nameLocation === 'center')
            index = 1;
        if (position === 'left' && nameLocation !== 'center')
            index = 1;
        if (position === 'right' && nameLocation !== 'center')
            index = 1;
        let plus = nameGap;
        if (position === 'top' && nameLocation !== 'end')
            plus *= -1;
        if (position === 'left' && nameLocation !== 'start')
            plus *= -1;
        if (position === 'bottom' && nameLocation === 'start')
            plus *= -1;
        if (position === 'right' && nameLocation === 'end')
            plus *= -1;
        namePosition[index] += plus;
        return {
            ...axisItem,
            namePosition
        };
    });
}
function calcSplitLinePosition(allAxis, chart) {
    const { w, h } = chart.gridArea;
    return allAxis.map(axisItem => {
        const { tickLinePosition, position, boundaryGap } = axisItem;
        let [index, plus] = [0, w];
        if (position === 'top' || position === 'bottom')
            index = 1;
        if (position === 'top' || position === 'bottom')
            plus = h;
        if (position === 'right' || position === 'bottom')
            plus *= -1;
        const splitLinePosition = tickLinePosition.map(([startPoint]) => {
            const endPoint = [...startPoint];
            endPoint[index] += plus;
            return [[...startPoint], endPoint];
        });
        if (!boundaryGap)
            splitLinePosition.shift();
        return {
            ...axisItem,
            splitLinePosition
        };
    });
}
function getLineConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    return [{
            name: 'polyline',
            index: rLevel,
            visible: axisItem.axisLine.show,
            animationCurve,
            animationFrame: 0,
            shape: getLineShape(axisItem),
            style: getLineStyle(axisItem)
        }];
}
function getLineShape(axisItem) {
    const { linePosition } = axisItem;
    return {
        points: linePosition
    };
}
function getLineStyle(axisItem) {
    setLineWidth(axisItem.axisLine.lineStyle);
    return axisItem.axisLine.lineStyle;
}
function getTickConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    const shapes = getTickShapes(axisItem);
    const style = getTickStyle(axisItem);
    return shapes.map(shape => ({
        name: 'polyline',
        index: rLevel,
        visible: axisItem.axisTick.show,
        animationCurve,
        animationFrame: 0,
        shape,
        style
    }));
}
function getTickShapes(axisItem) {
    const { tickLinePosition } = axisItem;
    return tickLinePosition.map(points => ({ points }));
}
function getTickStyle(axisItem) {
    setLineWidth(axisItem.axisTick.lineStyle);
    return axisItem.axisTick.lineStyle;
}
function getLabelConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel, axis, dataZoom } = axisItem;
    const shapes = getLabelShapes(axisItem);
    const styles = getLabelStyle(axisItem, shapes);
    return shapes.map((shape, i) => {
        let visible = shape.content && axisItem.axisLabel.show;
        // if (dataZoom.show) {
        //   visible = i >= dataZoom.start && i <= dataZoom.end
        // }
        return {
            name: 'text',
            index: rLevel,
            visible,
            animationCurve,
            animationFrame: 0,
            shape,
            style: styles[i],
            setGraphCenter: () => (void 0)
        };
    });
}
function getLabelShapes(axisItem) {
    const { label, tickPosition, position, axisLabel, axisTick } = axisItem;
    return tickPosition.map((point, i) => ({
        position: getLabelRealPosition(point, position, axisLabel, axisTick),
        content: label[i].toString(),
    }));
}
function getLabelRealPosition(points, position, axisLabel, axisTick) {
    let { margin: plus = 10 } = axisLabel;
    let { length } = axisTick;
    let index = 0;
    if (position === 'top' || position === 'bottom')
        index = 1;
    if (position === 'top' || position === 'left')
        plus *= -1;
    if (position === 'top' || position === 'left')
        length *= -1;
    points = deepClone(points);
    points[index] += (plus + length);
    return points;
}
function getLabelStyle(axisItem, shapes) {
    const { position } = axisItem;
    let { color, fontSize, rotate, fontWeight, fontFamily, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY } = axisItem.axisLabel;
    let style = {
        fill: color,
        fontSize,
        rotate,
        fontWeight,
        fontFamily,
        shadowColor,
        shadowBlur,
        shadowOffsetX,
        shadowOffsetY
    };
    const align = getAxisLabelRealAlign(position);
    style = deepMerge(align, style);
    const styles = shapes.map(({ position }) => ({
        ...style,
        graphCenter: position
    }));
    return styles;
}
function getAxisLabelRealAlign(position) {
    if (position === 'left')
        return {
            textAlign: 'right',
            textBaseline: 'middle'
        };
    if (position === 'right')
        return {
            textAlign: 'left',
            textBaseline: 'middle'
        };
    if (position === 'top')
        return {
            textAlign: 'center',
            textBaseline: 'bottom'
        };
    if (position === 'bottom')
        return {
            textAlign: 'center',
            textBaseline: 'top'
        };
}
function getNameConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    return [{
            name: 'text',
            index: rLevel,
            animationCurve,
            animationFrame: 0,
            shape: getNameShape(axisItem),
            style: getNameStyle(axisItem)
        }];
}
function getNameShape(axisItem) {
    const { name, namePosition } = axisItem;
    return {
        content: name,
        position: namePosition
    };
}
function getNameStyle(axisItem) {
    const { nameLocation, position, nameTextStyle: style } = axisItem;
    const align = getNameRealAlign(position, nameLocation);
    // style.fill = style.color
    return deepMerge(align, {
        fill: style.color,
        fontWeight: style.fontWeight,
        fontFamily: style.fontFamily,
        fontSize: style.fontSize
    });
}
function getNameRealAlign(position, location) {
    if ((position === 'top' && location === 'start') ||
        (position === 'bottom' && location === 'start') ||
        (position === 'left' && location === 'center'))
        return {
            textAlign: 'right',
            textBaseline: 'middle'
        };
    if ((position === 'top' && location === 'end') ||
        (position === 'bottom' && location === 'end') ||
        (position === 'right' && location === 'center'))
        return {
            textAlign: 'left',
            textBaseline: 'middle'
        };
    if ((position === 'top' && location === 'center') ||
        (position === 'left' && location === 'end') ||
        (position === 'right' && location === 'end'))
        return {
            textAlign: 'center',
            textBaseline: 'bottom'
        };
    if ((position === 'bottom' && location === 'center') ||
        (position === 'left' && location === 'start') ||
        (position === 'right' && location === 'start'))
        return {
            textAlign: 'center',
            textBaseline: 'top'
        };
}
function getSplitLineConfig(axisItem) {
    const { animationCurve, animationFrame, rLevel } = axisItem;
    const shapes = getSplitLineShapes(axisItem);
    const style = getSplitLineStyle(axisItem);
    return shapes.map(shape => ({
        name: 'polyline',
        index: rLevel,
        visible: axisItem.splitLine.show,
        animationCurve,
        animationFrame: 0,
        shape,
        style
    }));
}
function getSplitLineShapes(axisItem) {
    const { splitLinePosition } = axisItem;
    return splitLinePosition.map(points => ({ points }));
}
function getSplitLineStyle(axisItem) {
    setLineWidth(axisItem.splitLine.lineStyle);
    return axisItem.splitLine.lineStyle;
}
function setLineWidth(data) {
    data.lineWidth = data.width;
}
//# sourceMappingURL=axis.js.mapÂ•Ù…D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\class\updater.class.tsÙ~D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\config\index.tsÙ|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\index.tsÙ}D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\common.tsÙ† hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.graphics.drawing.d.tsÙ{D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\core\axis.tsÔrB˜±isLocalDependency¯isNodeEntryFile§pkgPath§pkgNameªpkgVersion±belongProjectPath±dependencyPkgInfo¬shouldEmitJsÂÂÙZD:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts®@mcui/mccharts¥2.8.9ºD:\apps\deveco\tzb2025jbgsÔrC’§pkgNameªpkgVersion®@mcui/mccharts¥2.8.9ÃÃÚg„import { doUpdate } from '../class/updater.class'

import { xAxisConfig, yAxisConfig } from '../config'

import { filterNonNumber, deepMerge, mergeSameStackData, drawTexts, drawBreakText, getIndices, px2vp } from '../util'

import { deepClone, getFormatterVal } from '../util/common'
import { drawing } from '@kit.ArkGraphics2D';
const axisConfig = { xAxisConfig, yAxisConfig }

const { min, max, abs, pow } = Math

let callbackSendable = null
let font = new drawing.Font();
export async function axis (chart, option?) {
  // let dataZoom = {
  //   show: false,
  //   start: 0,
  //   end: 0,
  //   num: 1
  // }

  callbackSendable = chart.sendableTestClass || {}
  let { xAxis, yAxis, series } = option
  let allAxis = []
  // dataZoom = chart.dataZoom
  if (xAxis && yAxis && series) {
    allAxis = getAllAxis(xAxis, yAxis)
    allAxis = mergeDefaultAxisConfig(allAxis)
    allAxis = allAxis.filter(({ show }) => show)
    allAxis = mergeDefaultBoundaryGap(allAxis)
    allAxis = calcAxisLinePosition(allAxis, chart)
    allAxis = calcAxisLabelData(allAxis, series, chart)
    allAxis = setAxisPosition(allAxis)
    allAxis = calcAxisTickPosition(allAxis, chart)
    allAxis = calcAxisNamePosition(allAxis, chart)
    allAxis = calcSplitLinePosition(allAxis, chart)
  }


  doUpdate({
    'chart': chart,
    'series': allAxis,
    'key': 'axisLine',
    'getGraphConfig': getLineConfig
  })
  // const time52 = Date.now()
  // console.log('æ—¶é—´5.2', time52-time51)
  doUpdate({
    chart,
    series: allAxis,
    key: 'axisTick',
    getGraphConfig: getTickConfig
  })
  // const time53 = Date.now()
  // console.log('æ—¶é—´5.3', time53-time52)
  doUpdate({
    chart,
    series: allAxis,
    key: 'axisLabel',
    getGraphConfig: getLabelConfig
  })
  // const time54 = Date.now()
  // console.log('æ—¶é—´5.4', time54-time53)
  doUpdate({
    chart,
    series: allAxis,
    key: 'axisName',
    getGraphConfig: getNameConfig
  })
  // const time55 = Date.now()
  // console.log('æ—¶é—´5.5', time55-time54)
  doUpdate({
    chart,
    series: allAxis,
    key: 'splitLine',
    getGraphConfig: getSplitLineConfig
  })

  // await Promise.all([
  //   doUpdate({
  //     'chart': chart,
  //     'series': allAxis,
  //     'key': 'axisLine',
  //     'getGraphConfig': getLineConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'axisTick',
  //     getGraphConfig: getTickConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'axisLabel',
  //     getGraphConfig: getLabelConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'axisName',
  //     getGraphConfig: getNameConfig
  //   }),
  //   doUpdate({
  //     chart,
  //     series: allAxis,
  //     key: 'splitLine',
  //     getGraphConfig: getSplitLineConfig
  //   })
  // ]);
  chart.axisData = allAxis
}

function asyncTask(callBack) {
  return callBack();
}

function getAllAxis (xAxis, yAxis) {
  let [allXAxis, allYAxis] = [[], []]

  if (xAxis instanceof Array) {
    allXAxis.push(...xAxis)
  } else {
    allXAxis.push(xAxis)
  }

  if (yAxis instanceof Array) {
    allYAxis.push(...yAxis)
  } else {
    allYAxis.push(yAxis)
  }

  allXAxis.splice(2)
  allYAxis.splice(2)

  allXAxis = allXAxis.map((axis, i) => ({ ...axis, index: i, axis: 'x' }))
  allYAxis = allYAxis.map((axis, i) => ({ ...axis, index: i, axis: 'y' }))

  return [...allXAxis, ...allYAxis]
}

function mergeDefaultAxisConfig (allAxis) {
  let xAxis = allAxis.filter(({ axis }) => axis === 'x')
  let yAxis = allAxis.filter(({ axis }) => axis === 'y')

  xAxis = xAxis.map(axis => deepMerge(deepClone(xAxisConfig), axis))
  yAxis = yAxis.map(axis => deepMerge(deepClone(yAxisConfig), axis))

  return [...xAxis, ...yAxis]
}

function mergeDefaultBoundaryGap (allAxis) {
  const valueAxis = allAxis.filter(({ type }) => type === 'value')
  const labelAxis = allAxis.filter(({ type }) => type !== 'value')

  valueAxis.forEach(axis => {
    if (typeof axis.boundaryGap === 'boolean') return

    axis.boundaryGap = false
  })
  labelAxis.forEach(axis => {
    if (typeof axis.boundaryGap === 'boolean') return

    axis.boundaryGap = true
  })

  return [...valueAxis, ...labelAxis]
}

function calcAxisLabelData (allAxis, series, chart) {
  const { dataZoom } = chart
  let valueAxis = allAxis.filter(({ type }) => type === 'value')
  let labelAxis = allAxis.filter(({ data }) => data instanceof Array)

  valueAxis = calcValueAxisLabelData(valueAxis, series, dataZoom)
  labelAxis = calcLabelAxisLabelData(labelAxis, dataZoom)
  return [...valueAxis, ...labelAxis]
}

function calcValueAxisLabelData (valueAxis, series, dataZoom) {
  return valueAxis.map(axis => {

    const minMaxValue = getValueAxisMaxMinValue(axis, series, dataZoom)
    const [min, max] = getTrueMinMax(axis, minMaxValue)
    const interval = getValueInterval(min, max, axis)
    const { axisLabel: { formatter } } = axis

    let label = []

    if (min < 0 && max > 0) {
      label = getValueAxisLabelFromZero(min, max, interval, axis)
    } else {
      label = getValueAxisLabelFromMin(min, max, interval)
    }

    label = label.map(l => parseFloat(l.toFixed(2)))
    return {
      ...axis,
      labelData: label,
      maxValue: label.slice(-1)[0],
      minValue: label[0],
      label: getAfterFormatterLabel(dataZoom, label, formatter)
    }
  })
}

// // æ¥è®¡ç®—ç»™å®šæ•°ç»„ä¸­æ¯å¯¹è¿ç»­å…ƒç´ ä¹‹é—´çš„å·®å€¼
// function calculateDifferences(arr) {
//   let differences = [];
//   for (let i = 0; i < arr.length - 1; i++) {
//     differences.push(Number(arr[i + 1]) - Number(arr[i]));
//   }
//   return differences;
// }


function getValueAxisMaxMinValue (axis, series, dataZoom) {
  series = series.filter(({ show, type }) => {
    if (show === false) return false

    if (type === 'pie') return false

    return true
  })

  if (series.length === 0) return [0, 0]
  
  const { index, axis: axisType } = axis

  series = mergeStackData(series, dataZoom)

  const axisName = axisType + 'Axis'

  let valueSeries = series.filter(s => s[axisName] === index)

  if (!valueSeries.length) valueSeries = series

  return getSeriesMinMaxValue(valueSeries, dataZoom)
}

function getSeriesMinMaxValue (series, dataZoom) {
  if (!series) return

  const dataZoomValue = function (data) {
    if (dataZoom && dataZoom.show) {
      data = data.filter((item, i) => (i >= dataZoom.start && i <= dataZoom.end))
    }
    return data
  }

  let seriesData = []
  series
    .map(({ data }) => {
      if (data && data.length) {
        // data = dataZoomValue(data)
        seriesData = [...seriesData, ...filterNonNumber(data)]
      } else {
        seriesData = [...seriesData, 0]
      }
    })
  const minValue = Math.min(...seriesData, 0)

  const maxValue = Math.max(...seriesData, 10)

  return [minValue, maxValue]
}

function mergeStackData (series, dataZoom) {

  const seriesCloned = JSON.parse(JSON.stringify(series))

  seriesCloned.forEach((item, i) => {
    if (dataZoom && dataZoom.show) {
      item.data = item.data.slice(dataZoom.start, dataZoom.end + 1)
    }
    const data = mergeSameStackData(item, series)
    item.data = data
  })

  return seriesCloned
}

function getTrueMinMax (axisJson, minMaxValue) {
  let { min, max, axis, splitNumber } = axisJson
  let  [minValue, maxValue] = minMaxValue
  if (min === null) {
    min = '20%'
  }
  if (max === null) {
    max = '20%'
  }
  let [minType, maxType] = [typeof min, typeof max]
  if (!testMinMaxType(min)) {
    min = axisConfig[axis + 'AxisConfig'].min
    minType = 'string'
  }

  if (!testMinMaxType(max)) {
    max = axisConfig[axis + 'AxisConfig'].max
    maxType = 'string'
  }

  if (minType === 'string') {
    min = Number(String(minValue - abs(minValue * parseFloat(min) / 100)))

    const lever = getValueLever(min)

    min = Math.min(parseFloat((min / lever).toFixed(1)) * lever, 0)

    min = Math.floor(min / splitNumber) * splitNumber;
  }

  if (maxType === 'string') {
    max = Number(maxValue + abs(maxValue * parseFloat(max) / 100))

    const lever = getValueLever(max)

    max = parseFloat((max / lever).toFixed(1)) * lever

    max = Math.ceil(max / splitNumber) * splitNumber;
  }

  return [min, max]
}

function getValueLever (value) {
  const valueString = abs(parseInt(value)).toString()

  const valueLength = valueString.length

  const firstZeroIndex = valueString.replace(/0*$/g, '').indexOf('0')

  let pow10Num = valueLength - 1

  if (firstZeroIndex !== -1) pow10Num -= firstZeroIndex

  return pow(10, pow10Num)
}

function testMinMaxType (val) {
  const valType = typeof val

  const isValidString = (valType === 'string' && /^\d+%$/.test(val))
  const isValidNumber = valType === 'number'

  return isValidString || isValidNumber
}

function getValueAxisLabelFromZero (min, max, interval, axis) {
  let [negative, positive] = [[], []]
  let [currentNegative, currentPositive] = [0, 0]

  do {
    currentNegative -= interval
    if (axis.min) {
      currentNegative = Math.max(min, currentNegative)
    }
    negative.push(currentNegative)
  } while (currentNegative > min)

  do {
    currentPositive += interval
    if (axis.max) {
      currentPositive = Math.min(max, currentPositive)
    }
    positive.push(currentPositive)
  } while (currentPositive < max)

  return [...negative.reverse(), 0, ...positive]
}

function getValueAxisLabelFromMin (min, max, interval) {
  let [label, currentValue] = [[min], min]

  do {
    currentValue += interval
    label.push(Math.min(currentValue, max))
  } while (currentValue < max)

  return label
}

function getAfterFormatterLabel (dataZoom, label, formatter, type = 'val') {

  if (!formatter) {
    return getDataZoomLabel(type, label, dataZoom)
  }

  label = getDataZoomLabel(type, label, dataZoom)

  if (typeof formatter === 'string') label = label.map(l => getFormatterVal(callbackSendable, formatter, l))
  if (typeof formatter === 'function') label = label.map((value, index) => formatter(value, dataZoom && dataZoom.show ? dataZoom.start + index : index))

  return label
}

function getDataZoomLabel (type, label, dataZoom) {
  if (dataZoom && dataZoom.show && type === 'label') {
    label = label.slice(dataZoom.start, dataZoom.end + 1)
  }
  return label
}

function calcLabelAxisLabelData (labelAxis, dataZoom) {
  return labelAxis.map(axis => {
    const { data, axisLabel: { formatter } } = axis

    return Object.assign({}, axis, { label: getAfterFormatterLabel(dataZoom, data, formatter, 'label') })
  })
}

function getValueInterval (min, max, axis) {
  let { interval, minInterval, maxInterval, splitNumber, axis: axisType } = axis

  const config = axisConfig[axisType + 'AxisConfig']

  if (typeof interval !== 'number') interval = config.interval
  if (typeof minInterval !== 'number') minInterval = config.minInterval
  if (typeof maxInterval !== 'number') maxInterval = config.maxInterval
  if (typeof splitNumber !== 'number') splitNumber = config.splitNumber

  if (typeof interval === 'number') return interval

  let valueInterval = parseInt(String((max - min) / (splitNumber)))

  // if (valueInterval.toString().length > 1) valueInterval = parseInt(valueInterval.toString().replace(/\d$/, '0'))

  if (valueInterval === 0) valueInterval = 1

  if (typeof minInterval === 'number' && valueInterval < minInterval) return minInterval

  if (typeof maxInterval === 'number' && valueInterval > maxInterval) return maxInterval

  return valueInterval
}

function setAxisPosition (allAxis) {
  const xAxis = allAxis.filter(({ axis }) => axis === 'x')
  const yAxis = allAxis.filter(({ axis }) => axis === 'y')

  if (xAxis[0] && !xAxis[0].position) xAxis[0].position = xAxisConfig.position
  if (xAxis[1] && !xAxis[1].position) {
    xAxis[1].position = xAxis[0].position === 'bottom' ? 'top' : 'bottom'
  }

  if (yAxis[0] && !yAxis[0].position) yAxis[0].position = yAxisConfig.position
  if (yAxis[1] && !yAxis[1].position) {
    yAxis[1].position = yAxis[0].position === 'left' ? 'right' : 'left'
  }

  return [...xAxis, ...yAxis]
}

function calcAxisLinePosition (allAxis, chart) {
  const { x, y, w, h } = chart.gridArea

  allAxis = allAxis.map(axis => {
    const { position } = axis

    let linePosition = []

    if (position === 'left') {
      linePosition = [[x, y], [x, y + h]].reverse()
    } else if (position === 'right') {
      linePosition = [[x + w, y], [x + w, y + h]].reverse()
    } else if (position === 'top') {
      linePosition = [[x, y], [x + w, y]]
    } else if (position === 'bottom') {
      linePosition = [[x, y + h], [x + w, y + h]]
    }

    return {
      ...axis,
      linePosition
    }
  })

  return allAxis
}

function calcAxisTickPosition (allAxis, chart) {
  const { render, dataZoom } = chart
  return allAxis.map((axisItem) => {
    let {
      type,
      axis,
      linePosition,
      position,
      label,
      labelData,
      max,
      min,
      boundaryGap,
      axisTick,
      minValue,
      maxValue,
      axisLabel: {
        formatter,
        style,
        interval,
        overflow,
        fontSize,
        width
      }
    } = axisItem
    if (typeof boundaryGap !== 'boolean') boundaryGap = axisConfig[axis + 'AxisConfig'].boundaryGap

    let labelNum = label.length

    const [[startX, startY], [endX, endY]] = linePosition

    const gapLength = axis === 'x' ? endX - startX : endY - startY

    let gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1)

    const ratio = (maxValue - minValue) === 0 ? (abs(gapLength) / (maxValue - minValue)) : 0;

    // å¦‚æœæ˜¯æ»šåŠ¨æ¨¡å¼, ä¸”xè½´
    if (type === 'data' && dataZoom && dataZoom.show) {
      labelNum = Math.min(dataZoom.num, labelNum)
      gap = gapLength / Math.max((boundaryGap ? labelNum : labelNum - 1), 1)
      axisItem.dataZoom = dataZoom
    } else {
      axisItem.dataZoom = {}
    }

    const tickPosition = new Array(labelNum)
      .fill(0)
      .map((foo, i) => {
        if (axis === 'x') {
          if (type === 'data') {
            return [startX + gap * (boundaryGap ? (i + 0.5) : i), startY]
          } else {
            return [startX +  (labelData[i] - minValue) * ratio, startY]
          }
        }
        if (type === 'data') {
          return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)]
        } else {
          if (min !== null || max !== null) {
            return [startX, startY - (labelData[i] - minValue) * ratio]
          } else {
            return [startX, startY + gap * (boundaryGap ? (i + 0.5) : i)]
          }
        }
      })
    if (type === 'data') {
      if (overflow && overflow !== 'none') {
        let overflowW = width ? width : axis === 'x' ? gap : startX
        // è®¡ç®—å½“å‰æ–‡æœ¬æ˜¯å¦éœ€è¦è®¾ç½®è‡ªåŠ¨æ¢è¡Œæˆ–è€…æˆªå–
        axisItem.label = label.map((labelItem, index) => {
          // ctx.font = `${fontSize}px`;
          font.setSize(fontSize);
          labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
          let textI = labelItem.length
          if (overflow === 'truncate') {
            textI = drawTexts(font, labelItem, overflowW)
            labelItem = labelItem.substring(0, textI) + (textI !== labelItem.length ? '...' : '')
          } else if (overflow === 'breakAll') {
            labelItem = drawBreakText(font, labelItem, overflowW)
          }
          return labelItem
        })
      }

      // è®¡ç®—æ˜¯å¦éœ€è¦é—´éš”æ˜¾ç¤º
      interval = interval === null ? 'auto' : interval
      if (interval === 'auto') {
        let labelTotalW = 0
        let maxNum = 0
        let maxText = ''
        axisItem.label.forEach((labelItem, index) => {
          labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
          if (labelItem.length > maxNum) {
            maxNum = labelItem.length
            maxText = labelItem
          }
        })
        font.setSize(fontSize);
        const txtW = px2vp(font.measureText(String(maxText), drawing.TextEncoding.TEXT_ENCODING_UTF8))
        labelTotalW = txtW * axisItem.label.length
        let flag = (txtW > gap) || (labelTotalW > gapLength)
        // axisItem.label.forEach((labelItem, index) => {
        //   ctx.font = `${fontSize}px`;
        //   labelItem = String(formatter ? getFormatterVal(callbackSendable, formatter, labelItem, index) : labelItem)
        //   // const txtW = ctx.measureText(labelItem).width; // è·å–æ–‡å­—çš„é•¿åº¦
        //   // const txtW = MeasureText.measureText({ // å»ºè®®ä½¿ç”¨ this.getUIContext().getMeasureUtils().measureText()æ¥å£
        //   //   textContent: labelItem,
        //   //   fontSize: `${fontSize}px`
        //   // }); // è·å–æ–‡å­—çš„é•¿åº¦
        //   font.setSize(fontSize);
        //   const txtW = px2vp(font.measureText(labelItem, drawing.TextEncoding.TEXT_ENCODING_UTF8))
        //   // console.log('txtW', px2vp(txtW))
        //   if (txtW > gap) {
        //     flag = true
        //   }
        //   labelTotalW += txtW
        // })
        // return result;
        if (flag) {
          interval = Math.max(Math.round(labelTotalW / (gapLength)), 1)
        }
      }
    }
    // console.log('interval', interval)
    if (!isNaN(interval)) {
      let indices = getIndices(0, axisItem.label.length, interval)
      // if (dataZoom.show && type === 'data' &&  axis === 'x') {
      //   indices = getIndices(dataZoom.start, dataZoom.num, interval)
      // }
      // console.log('indicesindices1', JSON.stringify(indices), axis, JSON.stringify(axisItem.label))
      axisItem.label = axisItem.label.map((item, index) => {
        if (!indices.includes(index)) {
          item = ''
        }
        return item
      })
    }


    const tickLinePosition = getTickLinePosition(axis, boundaryGap, position, tickPosition, gap, axisTick)

    return {
      ...axisItem,
      tickPosition,
      tickLinePosition,
      tickGap: gap
    }
  })
}

function getTickLinePosition (axisType, boundaryGap, position, tickPosition, gap, axisTick) {
  let index = axisType === 'x' ? 1 : 0
  let {length: plus = 5} = axisTick
  // let plus = 10

  if (axisType === 'x' && position === 'top') plus = -5
  if (axisType === 'y' && position === 'left') plus = -5

  let tickLinePosition = tickPosition.map(lineStart => {
    const lineEnd = deepClone(lineStart)

    lineEnd[index] += plus

    return [deepClone(lineStart), lineEnd]
  })

  if (!boundaryGap) return tickLinePosition

  index = axisType === 'x' ? 0 : 1
  plus = gap / 2

  tickLinePosition.forEach(([lineStart, lineEnd]) => {
    lineStart[index] += plus
    lineEnd[index] += plus
  })

  return tickLinePosition
}

function calcAxisNamePosition (allAxis, chart) {
  return allAxis.map(axisItem => {
    let { nameGap, nameLocation, position, linePosition } = axisItem

    const [lineStart, lineEnd] = linePosition

    let namePosition = [...lineStart]

    if (nameLocation === 'end') namePosition = [...lineEnd]

    if (nameLocation === 'center') {
      namePosition[0] = (lineStart[0] + lineEnd[0]) / 2
      namePosition[1] = (lineStart[1] + lineEnd[1]) / 2
    }

    let index = 0

    if (position === 'top' && nameLocation === 'center') index = 1
    if (position === 'bottom' && nameLocation === 'center') index = 1
    if (position === 'left' && nameLocation !== 'center') index = 1
    if (position === 'right' && nameLocation !== 'center') index = 1

    let plus = nameGap

    if (position === 'top' && nameLocation !== 'end') plus *= -1
    if (position === 'left' && nameLocation !== 'start') plus *= -1
    if (position === 'bottom' && nameLocation === 'start') plus *= -1
    if (position === 'right' && nameLocation === 'end') plus *= -1

    namePosition[index] += plus

    return {
      ...axisItem,
      namePosition
    }
  })
}

function calcSplitLinePosition (allAxis, chart) {
  const { w, h } = chart.gridArea

  return allAxis.map(axisItem => {
    const { tickLinePosition, position, boundaryGap } = axisItem

    let [index, plus] = [0, w]

    if (position === 'top' || position === 'bottom') index = 1

    if (position === 'top' || position === 'bottom') plus = h

    if (position === 'right' || position === 'bottom') plus *= -1

    const splitLinePosition = tickLinePosition.map(([startPoint]) => {
      const endPoint = [...startPoint]
      endPoint[index] += plus

      return [[...startPoint], endPoint]
    })

    if (!boundaryGap) splitLinePosition.shift()

    return {
      ...axisItem,
      splitLinePosition
    }
  })
}

function getLineConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem

  return [{
    name: 'polyline',
    index: rLevel,
    visible: axisItem.axisLine.show,
    animationCurve,
    animationFrame: 0,
    shape: getLineShape(axisItem),
    style: getLineStyle(axisItem)
  }]
}

function getLineShape (axisItem) {
  const { linePosition } = axisItem

  return {
    points: linePosition
  }
}

function getLineStyle (axisItem) {
  setLineWidth(axisItem.axisLine.lineStyle)
  return axisItem.axisLine.lineStyle
}

function getTickConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem
  const shapes = getTickShapes(axisItem)
  const style = getTickStyle(axisItem)
  return shapes.map(shape => ({
    name: 'polyline',
    index: rLevel,
    visible: axisItem.axisTick.show,
    animationCurve,
    animationFrame: 0,
    shape,
    style
  }))
}

function getTickShapes (axisItem) {
  const { tickLinePosition } = axisItem

  return tickLinePosition.map(points => ({ points }))
}

function getTickStyle (axisItem) {
  setLineWidth(axisItem.axisTick.lineStyle)
  return axisItem.axisTick.lineStyle
}

function getLabelConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel, axis, dataZoom } = axisItem

  const shapes = getLabelShapes(axisItem)
  const styles = getLabelStyle(axisItem, shapes)

  return shapes.map((shape, i) => {
    let visible = shape.content && axisItem.axisLabel.show
    // if (dataZoom.show) {
    //   visible = i >= dataZoom.start && i <= dataZoom.end
    // }
    return {
      name: 'text',
      index: rLevel,
      visible,
      animationCurve,
      animationFrame: 0,
      shape,
      style: styles[i],
      setGraphCenter: () => (void 0)
    }
  })
}

function getLabelShapes (axisItem) {
  const { label, tickPosition, position, axisLabel, axisTick } = axisItem

  return tickPosition.map((point, i) => ({
    position: getLabelRealPosition(point, position, axisLabel, axisTick),
    content: label[i].toString(),
  }))
}

function getLabelRealPosition (points, position, axisLabel, axisTick) {
  let {margin: plus = 10} = axisLabel
  let { length } = axisTick
  let index = 0

  if (position === 'top' || position === 'bottom') index = 1
  if (position === 'top' || position === 'left') plus *= -1
  if (position === 'top' || position === 'left') length *= -1

  points = deepClone(points)
  points[index] += (plus + length)

  return points
}

function getLabelStyle (axisItem, shapes) {
  const { position } = axisItem

  let { color, fontSize, rotate, fontWeight, fontFamily, shadowColor, shadowBlur, shadowOffsetX, shadowOffsetY } = axisItem.axisLabel
  let style = {
    fill: color,
    fontSize,
    rotate,
    fontWeight,
    fontFamily,
    shadowColor,
    shadowBlur,
    shadowOffsetX,
    shadowOffsetY
  }
  const align = getAxisLabelRealAlign(position)

  style = deepMerge(align, style)

  const styles = shapes.map(({ position }) => ({
    ...style,
    graphCenter: position
  }))

  return styles
}

function getAxisLabelRealAlign (position) {
  if (position === 'left') return {
    textAlign: 'right',
    textBaseline: 'middle'
  }

  if (position === 'right') return {
    textAlign: 'left',
    textBaseline: 'middle'
  }

  if (position === 'top') return {
    textAlign: 'center',
    textBaseline: 'bottom'
  }

  if (position === 'bottom') return {
    textAlign: 'center',
    textBaseline: 'top'
  }
}

function getNameConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem

  return [{
    name: 'text',
    index: rLevel,
    animationCurve,
    animationFrame: 0,
    shape: getNameShape(axisItem),
    style: getNameStyle(axisItem)
  }]
}

function getNameShape (axisItem) {
  const { name, namePosition } = axisItem

  return {
    content: name,
    position: namePosition
  }
}

function getNameStyle (axisItem) {
  const { nameLocation, position, nameTextStyle: style } = axisItem

  const align = getNameRealAlign(position, nameLocation)
  // style.fill = style.color
  return deepMerge(align, {
    fill: style.color,
    fontWeight: style.fontWeight,
    fontFamily: style.fontFamily,
    fontSize: style.fontSize
  })
}

function getNameRealAlign (position, location) {
  if (
    (position === 'top' && location === 'start') ||
    (position === 'bottom' && location === 'start') ||
    (position === 'left' && location === 'center')
  ) return {
    textAlign: 'right',
    textBaseline: 'middle'
  }

  if (
    (position === 'top' && location === 'end') ||
    (position === 'bottom' && location === 'end') ||
    (position === 'right' && location === 'center')
  ) return {
    textAlign: 'left',
    textBaseline: 'middle'
  }

  if (
    (position === 'top' && location === 'center') ||
    (position === 'left' && location === 'end') ||
    (position === 'right' && location === 'end')
  ) return {
    textAlign: 'center',
    textBaseline: 'bottom'
  }

  if (
    (position === 'bottom' && location === 'center') ||
    (position === 'left' && location === 'start') ||
    (position === 'right' && location === 'start')
  ) return {
    textAlign: 'center',
    textBaseline: 'top'
  }
}

function getSplitLineConfig (axisItem) {
  const { animationCurve, animationFrame, rLevel } = axisItem

  const shapes = getSplitLineShapes(axisItem)
  const style = getSplitLineStyle(axisItem)

  return shapes.map(shape => ({
    name: 'polyline',
    index: rLevel,
    visible: axisItem.splitLine.show,
    animationCurve,
    animationFrame: 0,
    shape,
    style
  }))
}

function getSplitLineShapes (axisItem) {
  const { splitLinePosition } = axisItem

  return splitLinePosition.map(points => ({ points }))
}

function getSplitLineStyle (axisItem) {
  setLineWidth(axisItem.splitLine.lineStyle)
  return axisItem.splitLine.lineStyle
}

function setLineWidth (data) {
  data.lineWidth = data.width
}
ÀÔrD•¶@ohos.graphics.drawing¶../class/updater.class§../util©../config®../util/commonÔrE—ªassertions¨external¢id¤meta±moduleSideEffectsªresolvedByµsyntheticNamedExportsAÃÙ† hvigor_ignore_D:_apps_deveco_devecostudio-windows-5.1.0.828_DevEco Studio_sdk_default_openharmony_ets_api_@ohos.graphics.drawing.d.tsAÃªoh-resolveÂEAÂÙ…D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\class\updater.class.tsAÃªoh-resolveÂEAÂÙ|D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\index.tsAÃªoh-resolveÂEAÂÙ~D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\config\index.tsAÃªoh-resolveÂEAÂÙ}D:\apps\deveco\tzb2025jbgs\oh_modules\.ohpm\@mcui+mccharts@2.8.9\oh_modules\@mcui\mccharts\src\main\ets\mcCore\util\common.tsAÃªoh-resolveÂ“ÔrF–§version¤fileªsourceRoot§sources¥names¨mappings§axis.js ‘§axis.tsÜ5˜”    ”  ”	  	”  ”  ”  ”1  1”2  1š”   ” ”	 	” ” ”! !”# #”) )”4 4”5 4Ü ”   ” ”	 	” ” ”# #”% %”7 7”9 9”ÌB ÌB”ÌD ÌD”ÌQ ÌQ”ÌS ÌS”Ì] Ì]”Ì_ Ì_”Ìd Ìd”Ìf Ìf”Ìl Ìl”Ìu Ìu”Ìv Ìuš”   ” ”	 	” ” ”# #”% %”+ +”; ;”< ;–”   ” 	” ” ”, ,”- -š”   ” ” ” ” ”   ”" "”- -”/ /”0 /”  
 ” 
” 
” 
” 
” 
” 
” 
” 
” 
” 
” 
”# 
#”$ 
#–”   ” ” ” ” ” š”   ” ” ” ” ” ” ” ” ” š”   ” ” ” ” ” ” ”  !”" #”( *’” ” ’” ” ’” ” ’” ” ’” ” ’” ” ™” ” ” ” ” ”. ,”2 0”4 2”5 2œ” ” ”
 ” ” ” ” ” ”  ”# !”) '”* '–” ” ” ” ” ” ’” ”  ˜” ” ” ” ” ” ”  ”"  š” ” ” ” ” ”" ”$  ”) %”* &”+ &˜” ” ” ”( $”) %”0 ,”1 -”2 -Ü ” ” ” ” ” ”  ”! ”" ”$  ”( $”* &”, (”. *”/ +”3 /”4 0”5 0˜” ” ” ”) %”* &”1 -”2 .”3 .š” ” ” ”& "”' #”. *”0 ,”5 1”6 2”7 2œ”  ”  ”  ”#  ”$   ”+  '”-  )”3  /”5  1”:  6”;  7”<  7˜” !” !” !”! !”" !”) !%”* !&”+ !&š” "” "” "”& ""”' "#”. "*”0 ",”5 "1”6 "2”7 "2š” #” #” #”& #"”' ##”. #*”0 #,”5 #1”6 #2”7 #2š” $” $” $”' $#”( $$”/ $+”1 $-”6 $2”7 $3”8 $3‘” %“” (” (
” (”” )” )” )” )”” *” *” *” *”” +” +	” +” +”” ,” ,” ,”' ,#“” -” -” -’” .”  .’” /”* /(“” 0” 0
” 0’” 1” 1	”” 2” 2
” 2” 2”” 3” 3” 3	” 3”” 4” 4” 4”% 4!“” 5” 5” 5’” 6”  6’” 7”* 7(“” 8” 8
” 8’” 9” 9	”” :” :
” :” :”” ;” ;” ;	” ;”” <” <” <”& <"“” =” =” =’” >”  >’” ?”* ?(“” Ì@” Ì@
” Ì@’” ÌA” ÌA	”” ÌB” ÌB
” ÌB” ÌB”” ÌC” ÌC” ÌC	” ÌC”” ÌD” ÌD” ÌD”% ÌD!“” ÌE” ÌE” ÌE’” ÌF”  ÌF’” ÌG”* ÌG(“” ÌH” ÌH
” ÌH’” ÌI” ÌI	”” ÌJ” ÌJ
” ÌJ” ÌJ”” ÌK” ÌK” ÌK	” ÌK”” ÌL” ÌL” ÌL”* ÌL&“” ÌM” ÌM” ÌM’” ÌO” ÌO’” ÌP” ÌP’” ÌQ” ÌQ’” ÌR” ÌR’” ÌS” ÌS’” ÌT”* ÌT(’” ÌU” ÌU
’” ÌV” ÌV’” ÌW” ÌW’” ÌX” ÌX’” ÌY” ÌY’” ÌZ”( ÌZ&’” Ì[” Ì[
’” Ì\” Ì\’” Ì]” Ì]’” Ì^” Ì^’” Ì_” Ì_’” Ì`”) Ì`'’” Ìa” Ìa
’” Ìb” Ìb’” Ìc” Ìc’” Ìd” Ìd’” Ìe” Ìe’” Ìf”( Ìf&’” Ìg” Ìg
’” Ìh” Ìh’” Ìi” Ìi’” Ìj” Ìj’” Ìk” Ìk’” Ìl”- Ìl+’” Ìm” Ìm	’” Ìn”
 Ìn—” Ìo”	 Ìo”
 Ìo” Ìo” Ìo” Ìo” Ìo’”  Ìp ” Ìp•”  Ìr ”	 Ìr	” Ìr” Ìr” Ìr•” Ìs” Ìs	” Ìs” Ìs” Ìs’”  Ìt ” Ìt—”  Ìv ”	 Ìv	” Ìv” Ìv” Ìv” Ìv”  Ìv!” Ìw” Ìw”	 Ìw” Ìw” Ìw” Ìw” Ìw” Ìw”  Ìw”" Ìw ”$ Ìw"”& Ìw$”' Ìw%”( Ìw%–” Ìy” Ìy” Ìy” Ìy” Ìy”  Ìy™” Ìz” Ìz” Ìz” Ìz” Ìz” Ìz” Ìz” Ìz”  Ìz‘” Ì{‘”	 Ì{	˜” Ì|” Ì|” Ì|” Ì|” Ì|” Ì|” Ì|” Ì|‘” Ì}–” Ì” Ì” Ì” Ì” Ì”  Ì™” Ì€” Ì€” Ì€” Ì€” Ì€” Ì€” Ì€” Ì€”  Ì€‘” Ì‘”	 Ì	˜” Ì‚” Ì‚” Ì‚” Ì‚” Ì‚” Ì‚” Ì‚” Ì‚‘” Ìƒ˜” Ì…” Ì…
” Ì…” Ì…” Ì…” Ì…” Ì…” Ì…˜” Ì†” Ì†
” Ì†” Ì†” Ì†” Ì†” Ì†” Ì†Ü ” Ìˆ” Ìˆ
” Ìˆ” Ìˆ” Ìˆ” Ìˆ” Ìˆ” Ìˆ”! Ìˆ”# Ìˆ!”$ Ìˆ"”& Ìˆ$”( Ìˆ&”) Ìˆ'”* Ìˆ(”, Ìˆ*”/ Ìˆ-”3 Ìˆ1”5 Ìˆ3”: Ìˆ8”< Ìˆ:”= Ìˆ;”? Ìˆ=”ÌC ÌˆÌA”ÌE ÌˆÌC”ÌH ÌˆÌF”ÌJ ÌˆÌH”ÌK ÌˆÌI”ÌL ÌˆÌJ”ÌM ÌˆÌJÜ ” Ì‰” Ì‰
” Ì‰” Ì‰” Ì‰” Ì‰” Ì‰” Ì‰”! Ì‰”# Ì‰!”$ Ì‰"”& Ì‰$”( Ì‰&”) Ì‰'”* Ì‰(”, Ì‰*”/ Ì‰-”3 Ì‰1”5 Ì‰3”: Ì‰8”< Ì‰:”= Ì‰;”? Ì‰=”ÌC Ì‰ÌA”ÌE Ì‰ÌC”ÌH Ì‰ÌF”ÌJ Ì‰ÌH”ÌK Ì‰ÌI”ÌL Ì‰ÌJ”ÌM Ì‰ÌJš” Ì‹” Ì‹	” Ì‹
” Ì‹” Ì‹” Ì‹” Ì‹”$ Ì‹"”% Ì‹#”& Ì‹#’”  ÌŒ ” ÌŒ•”  Ì ”	 Ì	” Ì”  Ì!”' Ì(Ü ” Ì” Ì” Ì” Ì” Ì” Ì” Ì” Ì”  Ì”" Ì ”& Ì$”( Ì&”* Ì(”, Ì*”- Ì+”1 Ì/”6 Ì4”9 Ì7”: Ì8”; Ì8Ü ” Ì” Ì” Ì” Ì” Ì” Ì” Ì” Ì”  Ì”" Ì ”& Ì$”( Ì&”* Ì(”, Ì*”- Ì+”1 Ì/”6 Ì4”9 Ì7”: Ì8”; Ì8Ü ” Ì’”	 Ì’” Ì’
” Ì’” Ì’” Ì’” Ì’” Ì’” Ì’” Ì’” Ì’”' Ì’%”( Ì’&”1 Ì’/”2 Ì’0”= Ì’;”> Ì’<”Ì@ Ì’>”ÌD Ì’ÌB”ÌE Ì’ÌC”ÌF Ì’ÌD”ÌG Ì’ÌDÜ ” Ì“”	 Ì“” Ì“
” Ì“” Ì“” Ì“” Ì“” Ì“” Ì“” Ì“” Ì“”' Ì“%”( Ì“&”1 Ì“/”2 Ì“0”= Ì“;”> Ì“<”Ì@ Ì“>”ÌD Ì“ÌB”ÌE Ì“ÌC”ÌF Ì“ÌD”ÌG Ì“ÌDš” Ì•” Ì•	” Ì•
” Ì•” Ì•” Ì•” Ì•” Ì•” Ì•”  Ì•’”  Ì– ” Ì–•”  Ì˜ ”	 Ì˜	”  Ì˜ ”! Ì˜"”( Ì˜)Ü ” Ì™”
 Ì™” Ì™” Ì™” Ì™” Ì™”$ Ì™"”% Ì™#”& Ì™$”( Ì™&”, Ì™*”. Ì™,”0 Ì™.”2 Ì™0”3 Ì™1”7 Ì™5”< Ì™:”ÌC Ì™ÌA”ÌD Ì™ÌB”ÌE Ì™ÌBÜ ” Ìš”
 Ìš” Ìš” Ìš” Ìš” Ìš”$ Ìš"”% Ìš#”& Ìš$”( Ìš&”, Ìš*”. Ìš,”0 Ìš.”2 Ìš0”3 Ìš1”7 Ìš5”< Ìš:”ÌC ÌšÌA”ÌD ÌšÌB”ÌE ÌšÌB˜” Ìœ” Ìœ” Ìœ” Ìœ” Ìœ” Ìœ” Ìœ” Ìœ˜” Ì” Ì” Ì” Ì” Ì”# Ì”( Ì$”1 Ì-’” Ì/” Ì5—” ÌŸ” ÌŸ” ÌŸ	” ÌŸ” ÌŸ”  ÌŸ”! ÌŸ”” Ì ” Ì ” Ì ” Ì ˜” Ì¡” Ì¡” Ì¡” Ì¡” Ì¡” Ì¡” Ì¡” Ì¡˜” Ì¢” Ì¢” Ì¢” Ì¢” Ì¢”# Ì¢”( Ì¢$”1 Ì¢-’” Ì¢/” Ì¢5—” Ì¤” Ì¤” Ì¤	” Ì¤” Ì¤” Ì¤”  Ì¤”” Ì¥” Ì¥” Ì¥” Ì¥š” Ì§” Ì§	” Ì§
” Ì§” Ì§” Ì§” Ì§”& Ì§$”' Ì§%”( Ì§%’”  Ì¨ ” Ì¨™”  Ìª ”	 Ìª	” Ìª” Ìª”" Ìª#”$ Ìª%”* Ìª+”, Ìª-”1 Ìª2˜” Ì«”
 Ì«” Ì«
” Ì«” Ì«” Ì«” Ì«” Ì«Ü ” Ì¬” Ì¬” Ì¬” Ì¬” Ì¬” Ì¬”" Ì¬ ”# Ì¬!”$ Ì¬"”& Ì¬$”* Ì¬(”, Ì¬*”. Ì¬,”0 Ì¬.”1 Ì¬/”5 Ì¬3”: Ì¬8”ÌA Ì¬?”ÌB Ì¬Ì@”ÌC Ì¬Ì@Ü ” Ì­” Ì­” Ì­” Ì­” Ì­” Ì­”" Ì­ ”# Ì­!”$ Ì­"”& Ì­$”* Ì­(”, Ì­*”. Ì­,”0 Ì­.”1 Ì­/”5 Ì­3”ÌA Ì­?”ÌF Ì­ÌD”ÌG Ì­ÌE”ÌH Ì­ÌEœ” Ì¯” Ì¯” Ì¯”& Ì¯$”' Ì¯%”0 Ì¯.”2 Ì¯0”8 Ì¯6”: Ì¯8”ÌB Ì¯Ì@”ÌC Ì¯ÌA”ÌD Ì¯ÌAš” Ì°” Ì°” Ì°”& Ì°$”' Ì°%”0 Ì°.”2 Ì°0”: Ì°8”; Ì°9”< Ì°9š” Ì±” Ì±	” Ì±
” Ì±” Ì±” Ì±” Ì±”& Ì±$”' Ì±%”( Ì±%’”  Ì² ” Ì²™”  Ì´ ”	 Ì´	” Ì´”  Ì´!”) Ì´*”+ Ì´,”1 Ì´2”3 Ì´4”; Ì´<™” Ìµ” Ìµ	” Ìµ” Ìµ” Ìµ” Ìµ” Ìµ” Ìµ”  Ìµ” Ì·” Ì·
” Ì·” Ì·”3 Ì·/”4 Ì·0”8 Ì·4”: Ì·6”Ì@ Ì·<”ÌB Ì·>”ÌJ Ì·ÌF”ÌK Ì·ÌG”ÌL Ì·ÌGŸ” Ì¸” Ì¸
” Ì¸” Ì¸” Ì¸” Ì¸” Ì¸” Ì¸”( Ì¸$”) Ì¸%”- Ì¸)”/ Ì¸+”: Ì¸6”; Ì¸7”< Ì¸7” Ì¹” Ì¹
” Ì¹” Ì¹”) Ì¹%”* Ì¹&”- Ì¹)”/ Ì¹+”2 Ì¹.”4 Ì¹0”8 Ì¹4”9 Ì¹5”: Ì¹5œ” Ìº” Ìº
” Ìº” Ìº” Ìº” Ìº”& Ìº"”( Ìº$”* Ìº&”- Ìº)”1 Ìº-”2 Ìº-–” Ì¼” Ì¼” Ì¼” Ì¼” Ì¼” Ì¼š” Ì¾” Ì¾” Ì¾” Ì¾” Ì¾” Ì¾” Ì¾” Ì¾” Ì¾”  Ì¾” Ì¿” Ì¿” Ì¿”- Ì¿'”. Ì¿(”1 Ì¿+”3 Ì¿-”6 Ì¿0”8 Ì¿2”Ì@ Ì¿:”ÌB Ì¿<”ÌF Ì¿Ì@”ÌG Ì¿ÌA”ÌH Ì¿ÌA‘”	 ÌÀ‘” ÌÀœ” ÌÁ” ÌÁ” ÌÁ”, ÌÁ&”- ÌÁ'”0 ÌÁ*”2 ÌÁ,”5 ÌÁ/”7 ÌÁ1”? ÌÁ9”Ì@ ÌÁ:”ÌA ÌÁ:‘”	 ÌÂÜ ” ÌÄ” ÌÄ	” ÌÄ” ÌÄ” ÌÄ” ÌÄ” ÌÄ” ÌÄ” ÌÄ” ÌÄ” ÌÄ”) ÌÄ%”* ÌÄ&”+ ÌÄ'”, ÌÄ(”3 ÌÄ/”4 ÌÄ0”5 ÌÄ1”6 ÌÄ2”7 ÌÄ3”8 ÌÄ4”9 ÌÄ4’” ÌÅ” ÌÅ“” ÌÆ” ÌÆ	” ÌÆ”” ÌÇ” ÌÇ” ÌÇ” ÌÇ” ÌÈ” ÌÈ” ÌÈ” ÌÈ” ÌÈ”! ÌÈ”" ÌÈ”# ÌÈ”$ ÌÈ”% ÌÈ”& ÌÈ ”' ÌÈ!”( ÌÈ"—” ÌÉ” ÌÉ” ÌÉ” ÌÉ” ÌÉ” ÌÉ” ÌÉ›” ÌÊ” ÌÊ” ÌÊ”) ÌÊ#”* ÌÊ$”2 ÌÊ,”4 ÌÊ.”9 ÌÊ3”; ÌÊ5”ÌD ÌÊ>”ÌE ÌÊ?’”	 ÌË”
 ÌË”” ÌÌ” ÌÌ” ÌÌ” ÌÌ’”  ÌÍ ” ÌÍ’”  ÌÏ ” ÌÏ’”  ÌĞ ”' ÌĞ'’”  ÌÑ ” ÌÑ’”  ÌÒ ”/ ÌÒ/’”  ÌÓ ”= ÌÓ=’”  ÌÔ ” ÌÔ’”  ÌÕ ” ÌÕ’”  ÌÖ ” ÌÖ™”  ÌÙ ”	 ÌÙ	”  ÌÙ ”! ÌÙ"”% ÌÙ&”' ÌÙ(”- ÌÙ.”/ ÌÙ0”7 ÌÙ8Ÿ” ÌÚ”
 ÌÚ” ÌÚ” ÌÚ” ÌÚ” ÌÚ” ÌÚ” ÌÚ” ÌÚ”" ÌÚ ”$ ÌÚ"”( ÌÚ&”* ÌÚ(”, ÌÚ*”. ÌÚ,•” ÌÛ” ÌÛ” ÌÛ” ÌÛ” ÌÛ”” ÌÛ” ÌÛ” ÌÛ$” ÌÛ$•” Ìİ” Ìİ” Ìİ” Ìİ” Ìİ”” Ìİ” Ìİ” Ìİ$” Ìİ$”” Ìß” Ìß” Ìß” Ìß”” Ìà” Ìà” Ìà” Ìà—” Ìâ” Ìâ” Ìâ” Ìâ” Ìâ” Ìâ” Ìâ˜” Ìâ” Ìâ"” Ìâ#” Ìâ$” Ìâ&” Ìâ'” Ìâ(” Ìâ(œ” Ìä”
 Ìä” Ìä
” Ìä” Ìä” Ìä” Ìä”! Ìä”# Ìä!”& Ìä$”* Ìä(”+ Ìä(š” Ìæ”
 Ìæ” Ìæ” Ìæ” Ìæ”" Ìæ ”$ Ìæ"”, Ìæ*”- Ìæ+”. Ìæ+˜” Ìè”
 Ìè” Ìè” Ìè” Ìè”  Ìè”& Ìè$”' Ìè$Ü ” Ìê” Ìê” Ìê” Ìê” Ìê” Ìê”# Ìê!”$ Ìê"”% Ìê#”& Ìê$”( Ìê&”) Ìê'”* Ìê(”+ Ìê)”3 Ìê1”4 Ìê2”9 Ìê7”> Ìê<”? Ìê=”Ì@ Ìê=–” Ìì” Ìì”	 Ìì” Ìì” Ìì” Ìì•” Ìì” Ìì&” Ìì)” Ìì/” Ìì/™” Ìî” Ìî	” Ìî”  Ìî”+ Ìî)”- Ìî+”5 Ìî3”6 Ìî4”7 Ìî4’”  Ìï ” Ìï—”  Ìñ ”	 Ìñ	” Ìñ” Ìñ”$ Ìñ%”& Ìñ'”. Ìñ/”” Ìò” Ìò”	 Ìò” Ìò’” Ìò” Ìò–” Ìô”
 Ìô” Ìô” Ìô”$ Ìô"”( Ìô&˜” Ìõ” Ìõ” Ìõ” Ìõ”  Ìõ”! Ìõ”% Ìõ!”' Ìõ#Ü ” Ìö” Ìö
” Ìö” Ìö” Ìö” Ìö” Ìö”  Ìö”$ Ìö”& Ìö ”' Ìö!”) Ìö#”+ Ìö%”, Ìö&”- Ìö'”. Ìö(”2 Ìö,”: Ìö4”; Ìö5”Ì@ Ìö:”ÌD Ìö>”ÌE Ìö?”ÌI ÌöÌC”ÌQ ÌöÌK”ÌR ÌöÌL”ÌU ÌöÌO”ÌV ÌöÌP”ÌW ÌöÌQ”ÌX ÌöÌQ‘”	 Ì÷”” Ìø” Ìø” Ìø” Ìø“” Ìù” Ìù” Ìù–” Ìû” Ìû” Ìû” Ìû” Ìû” Ìû’” Ìü”
 Ìü™”	 Ìı” Ìı” Ìı	” Ìı
” Ìı” Ìı” Ìı” Ìı” Ìı˜” Ìş” Ìş
” Ìş” Ìş” Ìş” Ìş” Ìş”! Ìş’” Ìÿ”) Ìÿ%” Í ” Í ” Í ” Í ” Í ”' Í #”) Í %”, Í (”; Í 7”< Í 8”Ì@ Í <”ÌA Í =”ÌB Í >”ÌC Í >‘”	 Í‘” Íš” Í” Í” Í” Í” Í”' Í#”) Í%”* Í&”+ Í'”, Í'‘”	 Í”” Í” Í” Í” Í” Í”
 Í” Í” Í” Í” Í” Í” Í”! Í”+ Í)”- Í+”. Í,”/ Í-”0 Í-” Í”
 Í” Í” Í” Í” Í” Í” Í”! Í”+ Í)”- Í+”/ Í-”0 Í.”1 Í.˜” Í	” Í		” Í	
” Í	” Í	” Í	” Í	”  Í	’”  Í
 ” Í
—”  Í ”	 Í	” Í” Í” Í”  Í!”( Í)Ü ” Í”
 Í” Í” Í” Í” Í”# Í!”$ Í"”( Í&”) Í'”2 Í0”3 Í1”9 Í7”: Í8”; Í9”< Í9›” Í” Í” Í” Í” Í” Í” Í”  Í”! Í”# Í!”% Í#˜” Í” Í” Í” Í”  Í”! Í”% Í!”' Í#Ü ” Í” Í
” Í” Í” Í” Í” Í”! Í”" Í”' Í!”( Í"”0 Í*”1 Í+”6 Í0”8 Í2”Ì@ Í:”ÌA Í;”ÌD Í>”ÌG ÍÌA”ÌH ÍÌB”ÌI ÍÌC”ÌJ ÍÌC‘”	 Í›” Í” Í
” Í” Í”' Í#”( Í$”, Í(”. Í*”4 Í0”5 Í1”6 Í1—” Í” Í” Í	” Í” Í” Í” Í”” Í” Í” Í” Í”” Í” Í	” Í” Í’”  Í ” Í—”  Í ”	 Í	” Í” Í” Í ”! Í"”, Í-” Í” Í”
 Í” Í” Í” Í” Í” Í” Í”% Í#”' Í%”* Í(”2 Í0”3 Í0š” Í” Í”	 Í” Í” Í” Í” Í” Í”* Í)”+ Í)–” Í” Í” Í	” Í” Í” Í•” Í” Í” Í
” Í” Í‘” Í –” Í!” Í!” Í!	” Í!” Í!” Í!•” Í"” Í"” Í"
” Í"” Í"‘” Í#Ü ” Í$” Í$”	 Í$” Í$” Í$” Í$” Í$” Í$” Í$”% Í$#”( Í$&”* Í$(”1 Í$/”4 Í$2”5 Í$3”6 Í$3˜” Í%” Í%”	 Í%” Í%” Í%” Í%” Í%” Í%œ” Í&” Í&” Í&
” Í&” Í&” Í&”  Í&”, Í&(”- Í&)”. Í&*”1 Í&-”2 Í&-•” Í'” Í'” Í'” Í'” Í'‘” Í(˜” Í*” Í*”	 Í*” Í*” Í*” Í*” Í*” Í*œ” Í+” Í+” Í+
” Í+” Í+” Í+”  Í+”, Í+(”- Í+)”. Í+*”1 Í+-”2 Í+-•” Í,” Í,” Í,” Í,” Í,‘” Í-–” Í/” Í/” Í/” Í/” Í/” Í/Ü ” Í0” Í0” Í0
” Í0” Í0” Í0” Í0”$ Í0 ”' Í0#”* Í0&”+ Í0'”3 Í0/”6 Í02”Ì@ Í0<”ÌA Í0=”ÌD Í0Ì@”ÌE Í0ÌA”ÌH Í0ÌD”ÌK Í0ÌG”ÌL Í0ÌH”ÌM Í0ÌI”ÌN Í0ÌJ”ÌO Í0ÌJ™” Í2” Í2
” Í2” Í2”# Í2”$ Í2 ”' Í2#”( Í2$”) Í2$Ü ” Í4” Í4” Í4
” Í4” Í4” Í4” Í4”! Í4”" Í4”# Í4”& Í4"”) Í4%”. Í4*”/ Í4+”0 Í4,”7 Í43”8 Í44”9 Í45”: Í46”; Í47”> Í4:”ÌC Í4?”ÌE Í4ÌA”ÌF Í4ÌB”ÌG Í4ÌC”ÌH Í4ÌC” Í6” Í6” Í6
” Í6” Í6” Í6” Í6” Í6” Í6”* Í6&”+ Í6'”. Í6*”9 Í65”: Í66‘” Í7–” Í9” Í9” Í9” Í9” Í9” Í9Ü ” Í:” Í:” Í:
” Í:” Í:” Í:”  Í:”# Í:”$ Í: ”, Í:(”/ Í:+”9 Í:5”: Í:6”= Í:9”> Í::”ÌA Í:=”ÌD Í:Ì@”ÌE Í:ÌA”ÌF Í:ÌB”ÌG Í:ÌB™” Í<” Í<
” Í<” Í<”# Í<”$ Í< ”' Í<#”( Í<$”) Í<$Ü ” Í>” Í>” Í>
” Í>” Í>” Í>” Í>”  Í>”% Í>!”& Í>"”' Í>#”. Í>*”/ Í>+”0 Í>,”1 Í>-”2 Í>.”5 Í>1”: Í>6”; Í>6” Í@” Í@” Í@
” Í@” Í@” Í@” Í@” Í@” Í@”) Í@%”* Í@&”- Í@)”8 Í@4”9 Í@5‘” ÍA˜” ÍC” ÍC	” ÍC
” ÍC” ÍC” ÍC” ÍC” ÍC’”  ÍD ” ÍD•”  ÍF ”	 ÍF	” ÍF” ÍF” ÍFŸ” ÍG”
 ÍG” ÍG” ÍG” ÍG” ÍG”$ ÍG"”% ÍG#”* ÍG(”+ ÍG)”, ÍG*”- ÍG+”5 ÍG3”7 ÍG5”8 ÍG5˜” ÍI”
 ÍI” ÍI” ÍI”# ÍI!”$ ÍI"”* ÍI(”+ ÍI(Ü ” ÍK”
 ÍK” ÍK” ÍK”& ÍK$”' ÍK%”. ÍK,”/ ÍK-”5 ÍK3”7 ÍK5”9 ÍK7”: ÍK8”; ÍK9”ÌB ÍKÌ@”ÌC ÍKÌA”ÌF ÍKÌD”ÌG ÍKÌE”ÌH ÍKÌE˜” ÍM” ÍM” ÍM” ÍM” ÍM”! ÍM”" ÍM ”# ÍM –” ÍO” ÍO” ÍO” ÍO” ÍO” ÍO•” ÍO” ÍO%” ÍO)”" ÍO7”# ÍO7™” ÍQ” ÍQ	” ÍQ” ÍQ” ÍQ” ÍQ” ÍQ” ÍQ” ÍQ’”  ÍR ” ÍR•”  ÍT ”	 ÍT	” ÍT” ÍT” ÍT—” ÍU”
 ÍU” ÍU” ÍU” ÍU” ÍU” ÍUÜ ” ÍW”
 ÍW” ÍW” ÍW” ÍW”" ÍW ”' ÍW%”/ ÍW-”3 ÍW1”; ÍW9”< ÍW:”Ì@ ÍW>”ÌA ÍW?”ÌD ÍWÌB”ÌE ÍWÌC”ÌF ÍWÌD”ÌG ÍWÌD˜” ÍX”
 ÍX” ÍX” ÍX”! ÍX”& ÍX$”. ÍX,”/ ÍX,–” ÍZ” ÍZ	” ÍZ” ÍZ”) ÍZ'”* ÍZ'’”  Í[ ” Í[›”  Í] ”	 Í]	”" Í]"”# Í]$”& Í]'”( Í])”+ Í],”- Í].”5 Í]6”7 Í]8”; Í]<” Í^” Í^”	 Í^” Í^” Í^” Í^” Í^” Í^”  Í^”" Í^ ”$ Í^"”& Í^$”' Í^%”( Í^%” Í_” Í_”	 Í_” Í_” Í_”) Í_'”* Í_(”- Í_+”. Í_,”/ Í_-”1 Í_/”2 Í_0”3 Í_1”4 Í_1’” Ía” Ía•” Íb” Íb” Íb”# Íb”$ Íb–” Íc” Íc” Íc” Íc” Íc” Ícœ” Íd” Íd” Íd”" Íd”# Íd”& Íd ”' Íd!”* Íd$”, Íd&”; Íd5”< Íd6”= Íd6‘”	 Íe˜” Íf” Íf” Íf” Íf” Íf”% Íf!”& Íf"”' Íf"–” Íg” Íg” Íg” Íg”" Íg ”$ Íg!’” Íi” Íi•” Íj” Íj” Íj”# Íj”$ Íj–” Ík” Ík” Ík” Ík” Ík” Íkœ” Íl” Íl” Íl”" Íl”# Íl”& Íl ”' Íl!”* Íl$”, Íl&”; Íl5”< Íl6”= Íl6‘”	 Ím˜” Ín” Ín” Ín” Ín” Ín”% Ín!”& Ín"”' Ín"–” Ío” Ío” Ío” Ío”" Ío ”$ Ío!Ÿ” Íq” Íq	” Íq
” Íq” Íq” Íq” Íq”! Íq”# Íq!”$ Íq"”& Íq$”) Íq'”1 Íq/”2 Íq0”3 Íq0’”  Ír ” Ír™”  Ít ”	 Ít	”! Ít!”" Ít#”% Ít&”' Ít(”* Ít+”, Ít-”4 Ít5Ü ” Íu” Íu”	 Íu” Íu” Íu” Íu” Íu”  Íu”! Íu”" Íu ”% Íu#”& Íu$”( Íu&”+ Íu)”, Íu*”- Íu*’” Íw” Íw•” Íx” Íx” Íx”  Íx”! ÍxŸ” Íy” Íy	” Íy
” Íy” Íy” Íy” Íy” Íy” Íy”( Íy$”* Íy&”- Íy)”. Íy*”/ Íy+”0 Íy+–” Íz” Íz” Íz” Íz” Íz”! Íz”” Í|” Í|	” Í|” Í|’”  Í} ” Í}”  Í ”	 Í	” Í”  Í!”( Í)”* Í+”/ Í0”1 Í2”: Í;”< Í=”Ì@ ÍÌA”ÌC ÍÌD”ÌH ÍÌI•” Í” Í”	 Í” Í” Í›” Í‚” Í‚” Í‚”  Í‚”$ Í‚ ”& Í‚"”+ Í‚'”- Í‚)”5 Í‚1”6 Í‚2”7 Í‚2‘” Íƒœ” Í…”	 Í…” Í…
” Í…” Í…”! Í…”# Í…!”( Í…&”* Í…(”2 Í…0”3 Í…1”4 Í…1–” Í‡” Í‡” Í‡” Í‡” Í‡”% Í‡#Ü ” Í‡%” Í‡*” Í‡-” Í‡2” Í‡3” Í‡6” Í‡7” Í‡8” Í‡9” Í‡;” Í‡<”. Í‡ÌK”/ Í‡ÌL”? Í‡Ì\”ÌA Í‡Ì^”ÌJ Í‡Ìg”ÌL Í‡Ìi”ÌM Í‡Ìj”ÌN Í‡Ìk”ÌO Í‡Ìl”ÌP Í‡Ìl–” Íˆ” Íˆ” Íˆ” Íˆ” Íˆ”' Íˆ%Ü &” Íˆ'” Íˆ,” Íˆ/” Íˆ4” Íˆ5” Íˆ8” Íˆ9” Íˆ:”  Íˆ?”" ÍˆÌA”' ÍˆÌF”) ÍˆÌH”+ ÍˆÌJ”, ÍˆÌK”5 ÍˆÌT”6 ÍˆÌU”; ÍˆÌZ”= ÍˆÌ\”ÌE ÍˆÌd”ÌI ÍˆÌh”ÌQ ÍˆÌp”ÌR ÍˆÌq”ÌV ÍˆÌu”ÌW ÍˆÌv”ÌX ÍˆÌw”ÌY ÍˆÌx”Ìa ÍˆÌ€”Ìb ÍˆÌ”Ìg ÍˆÌ†”Ìj ÍˆÌ‰”Ìo ÍˆÌ”Ìp ÍˆÌ”Ìq ÍˆÌ”Ìr ÍˆÌ‘”Ìw ÍˆÌ–”Ìx ÍˆÌ—”Ìy ÍˆÌ˜”Ìz ÍˆÌ˜”” ÍŠ” ÍŠ	” ÍŠ” ÍŠ’”  Í‹ ” Í‹™”  Í ”	 Í	” Í” Í” Í”  Í!”% Í&”' Í(”/ Í0œ” Í” Í” Í” Í” Í” Í”! Í”% Í#”) Í'”. Í,”5 Í3”7 Í5Ü ” Í” Í	” Í” Í” Í” Í” Í”$ Í ”% Í!”* Í&”, Í(”4 Í0”5 Í1”8 Í4”; Í7”< Í8”= Í9”> Í9‘” Í”” Í‘” Í‘	” Í‘” Í‘’”  Í’ ” Í’—”  Í” ”	 Í”	” Í””  Í”!”) Í”*”+ Í”,”3 Í”4™” Í•” Í•	” Í•” Í•” Í•” Í•” Í•” Í•”  Í•” Í–” Í–
” Í–” Í–” Í–” Í–”! Í–”# Í–”, Í–(”. Í–*”0 Í–,”3 Í–/”7 Í–3”8 Í–3Ü ” Í˜” Í˜” Í˜” Í˜” Í˜” Í˜” Í˜”! Í˜”% Í˜!”' Í˜#”) Í˜%”. Í˜*”0 Í˜,”ÌF Í˜ÌB”ÌG Í˜ÌC”ÌO Í˜ÌK”ÌQ Í˜ÌM”ÌU Í˜ÌQ”ÌW Í˜ÌS”Ì` Í˜Ì\”Ìb Í˜Ì^”Ìi Í˜Ìe”Ìj Í˜Ìf”Ìl Í˜Ìh”Ìm Í˜Ìi”Ìn Í˜Ìi”” Í™” Í™” Í™” Í™’”  Íš ” Íš™”  Íœ ”	 Íœ	” Íœ” Íœ” Íœ” Íœ ”" Íœ#”$ Íœ%”( Íœ)Ü ” Í” Í”
 Í” Í” Í” Í”! Í”, Í*”. Í,”9 Í7”; Í9”? Í=”ÌA Í?”ÌI ÍÌG”ÌK ÍÌI”ÌN ÍÌL”ÌR ÍÌP”ÌS ÍÌP›” ÍŸ”
 ÍŸ” ÍŸ” ÍŸ” ÍŸ” ÍŸ”& ÍŸ$”) ÍŸ'”5 ÍŸ3”6 ÍŸ4”7 ÍŸ4–” Í¡” Í¡” Í¡” Í¡” Í¡”$ Í¡"—” Í¡$” Í¡,” Í¡/” Í¡5” Í¡6”" Í¡>”# Í¡>–” Í¢” Í¢” Í¢” Í¢” Í¢”' Í¢%—” Í¢'” Í¢2” Í¢5” Í¢;” Í¢<”( Í¢ÌG”) Í¢ÌG–” Í£” Í£” Í£” Í£” Í£”' Í£%—” Í£'” Í£2” Í£5” Í£;” Í£<”( Í£ÌG”) Í£ÌG–” Í¤” Í¤” Í¤” Í¤” Í¤”' Í¤%—” Í¤'” Í¤2” Í¤5” Í¤;” Í¤<”( Í¤ÌG”) Í¤ÌG–” Í¦” Í¦” Í¦” Í¦” Í¦”$ Í¦"”” Í¦$” Í¦+” Í¦3” Í¦3Ü ” Í¨” Í¨” Í¨” Í¨”  Í¨”! Í¨”' Í¨%”( Í¨&”) Í¨'”, Í¨*”/ Í¨-”2 Í¨0”3 Í¨1”6 Í¨4”7 Í¨5”ÌB Í¨Ì@”ÌC Í¨ÌA”ÌD Í¨ÌB”ÌE Í¨ÌC”ÌF Í¨ÌC’” Íª”Ìv ÍªÌt•” Í¬” Í¬” Í¬” Í¬” Í¬•” Í¬” Í¬(” Í¬+” Í¬,” Í¬,š” Í®” Í®” Í®” Í®” Í®”' Í®%”+ Í®)”8 Í®6”; Í®9”ÌF Í®ÌD”” Í®ÌF” Í®ÌM” Í®ÌX” Í®ÌXš” Í°” Í°” Í°” Í°” Í°”' Í°%”+ Í°)”8 Í°6”; Í°9”ÌF Í°ÌD”” Í°ÌF” Í°ÌM” Í°ÌX” Í°ÌX”” Í²” Í²	” Í²” Í²’”  Í³ ” Í³•”  Íµ ”	 Íµ	” Íµ” Íµ”  Íµ!Ü ” Í¶”
 Í¶” Í¶” Í¶” Í¶” Í¶”  Í¶”! Í¶”" Í¶ ”$ Í¶"”( Í¶&”* Í¶(”, Í¶*”. Í¶,”/ Í¶-”3 Í¶1”8 Í¶6”; Í¶9”< Í¶:”= Í¶:Ü ” Í·”
 Í·” Í·” Í·” Í·” Í·”  Í·”! Í·”" Í· ”$ Í·"”( Í·&”* Í·(”, Í·*”. Í·,”/ Í·-”3 Í·1”8 Í·6”; Í·9”< Í·:”= Í·:” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹” Í¹”& Í¹$œ” Í¹&” Í¹+” Í¹,” Í¹-” Í¹.” Í¹/” Í¹7” Í¹:”' Í¹ÌE”( Í¹ÌF”0 Í¹ÌN”1 Í¹ÌNŸ” Íº” Íº” Íº” Íº” Íº” Íº” Íº” Íº” Íº” Íº” Íº” Íº” Íº”& Íº$”( Íº&Ü ” Í»” Í»	” Í»
” Í»” Í»” Í»” Í»” Í»”! Í»”" Í»”# Í»”$ Í» ”% Í»!”- Í»)”2 Í».”: Í»6”; Í»7”< Í»8”= Í»9”ÌB Í»>”ÌC Í»?”ÌD Í»Ì@”ÌE Í»ÌA”ÌM Í»ÌI”ÌN Í»ÌI‘” Í¼” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾”& Í¾$œ” Í¾&” Í¾+” Í¾,” Í¾-” Í¾.” Í¾/” Í¾7” Í¾:”' Í¾ÌE”( Í¾ÌF”0 Í¾ÌN”1 Í¾ÌNŸ” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿” Í¿”& Í¿$”( Í¿&Ü ” ÍÀ” ÍÀ	” ÍÀ
” ÍÀ” ÍÀ” ÍÀ” ÍÀ” ÍÀ”! ÍÀ”" ÍÀ”# ÍÀ”$ ÍÀ ”% ÍÀ!”- ÍÀ)”2 ÍÀ.”8 ÍÀ4”9 ÍÀ5”: ÍÀ6”; ÍÀ7”ÌB ÍÀ>”ÌC ÍÀ?”ÌD ÍÀÌ@”ÌE ÍÀÌA”ÌK ÍÀÌG”ÌL ÍÀÌG‘” ÍÁš” ÍÃ” ÍÃ	” ÍÃ
” ÍÃ” ÍÃ” ÍÃ” ÍÃ” ÍÃ” ÍÃ”  ÍÃ’”  ÍÄ ” ÍÄ—”  ÍÆ ”	 ÍÆ	” ÍÆ” ÍÆ”% ÍÆ&”' ÍÆ(”, ÍÆ-Ü ” ÍÇ”
 ÍÇ” ÍÇ
” ÍÇ” ÍÇ” ÍÇ” ÍÇ” ÍÇ” ÍÇ” ÍÇ” ÍÇ” ÍÇ”  ÍÇ”! ÍÇ”) ÍÇ'”* ÍÇ'š” ÍÉ” ÍÉ	” ÍÉ” ÍÉ” ÍÉ” ÍÉ” ÍÉ” ÍÉ” ÍÉ”! ÍÉ˜” ÍÊ” ÍÊ
” ÍÊ” ÍÊ” ÍÊ” ÍÊ”! ÍÊ”" ÍÊ–” ÍÌ” ÍÌ” ÍÌ” ÍÌ” ÍÌ” ÍÌ–” ÍÎ” ÍÎ” ÍÎ” ÍÎ” ÍÎ”! ÍÎÜ ” ÍÏ” ÍÏ” ÍÏ” ÍÏ” ÍÏ” ÍÏ”  ÍÏ”! ÍÏ”" ÍÏ”$ ÍÏ”% ÍÏ”& ÍÏ ”( ÍÏ"”) ÍÏ#”, ÍÏ&”- ÍÏ'”. ÍÏ(”/ ÍÏ)”0 ÍÏ*”7 ÍÏ1”9 ÍÏ3”: ÍÏ3‘”	 ÍĞ–” ÍĞ” ÍĞ” ÍĞ” ÍĞ”% ÍĞ#”' ÍĞ%Ü ” ÍÑ” ÍÑ” ÍÑ” ÍÑ” ÍÑ” ÍÑ”! ÍÑ”" ÍÑ”$ ÍÑ”% ÍÑ”& ÍÑ ”( ÍÑ"”) ÍÑ#”* ÍÑ$”- ÍÑ'”. ÍÑ(”0 ÍÑ*”1 ÍÑ+”4 ÍÑ.”5 ÍÑ/”6 ÍÑ0”7 ÍÑ1”8 ÍÑ2”? ÍÑ9”ÌA ÍÑ;”ÌB ÍÑ;‘”	 ÍÒ–” ÍÒ” ÍÒ” ÍÒ” ÍÒ”# ÍÒ!”% ÍÒ#Ü ” ÍÓ” ÍÓ” ÍÓ” ÍÓ” ÍÓ” ÍÓ”  ÍÓ”! ÍÓ”" ÍÓ”$ ÍÓ”% ÍÓ”& ÍÓ ”) ÍÓ#”* ÍÓ$”, ÍÓ&”- ÍÓ'”. ÍÓ(”/ ÍÓ)”0 ÍÓ)‘”	 ÍÔ–” ÍÔ” ÍÔ” ÍÔ” ÍÔ”& ÍÔ$”( ÍÔ&Ü ” ÍÕ” ÍÕ” ÍÕ” ÍÕ” ÍÕ” ÍÕ”  ÍÕ”! ÍÕ”$ ÍÕ”% ÍÕ”& ÍÕ ”( ÍÕ"”) ÍÕ#”* ÍÕ$”- ÍÕ'”. ÍÕ(”0 ÍÕ*”1 ÍÕ+”4 ÍÕ.”5 ÍÕ/”6 ÍÕ0”7 ÍÕ1”8 ÍÕ1‘”	 ÍÖ’” ÍØ” ÍØ“” ÍÙ” ÍÙ	” ÍÙ’” ÍÚ” ÍÚ’”	 ÍÛ”
 ÍÛ”” ÍÜ” ÍÜ” ÍÜ” ÍÜ”” ÍŞ” ÍŞ	” ÍŞ” ÍŞ’”  Íß ” Íß—”  Íá ”	 Íá	” Íá” Íá”% Íá&”' Íá(”, Íá-š” Íâ”
 Íâ” Íâ
” Íâ” Íâ” Íâ” Íâ”! Íâ”& Íâ$”' Íâ$š” Íã” Íã	” Íã” Íã” Íã” Íã” Íã”  Íã”" Íã ”$ Íã"Ü .” Íä” Íä” Íå” Íå
” Íæ” Íæ
” Íç”& Íç”( Íè”0 Íè”2 Íé”7 Íé”9 Íê”ÌB Íê”ÌD Íë”ÌG Íë	”ÌI Íì”ÌL Íì	”ÌN Íí”ÌY Íí”Ì[ Íî”Ìc Íî”Ìe Íï”Ìm Íï”Ìo Íğ”Ìw Íğ”Ìy Íñ”Ì‚ Íñ”Ì„ Íñ”Ì† Íò”Ì Íò”Ì‘ Íó”Ì– Íó”Ì˜ Íô”Ì  Íô”Ì¢ Íõ”Ìª Íõ”Ì¬ Íö”Ì´ Íö”Ì¶ Í÷”Ì» Í÷”Ì½ Íø”Ì¿ Íù”ÌÂ Íù”ÌÊ Íù”ÌË Íù–” Íú” Íú” Íú” Íú”# Íú”, Íú(œ” Íú*” Íú5” Íú8”$ ÍúÌB”% ÍúÌC”) ÍúÌG”, ÍúÌJ”8 ÍúÌV”9 ÍúÌW”: ÍúÌX”ÌE ÍúÌc”ÌF ÍúÌc˜” Íü” Íü” Íü” Íü” Íü” Íü”# Íü”$ ÍüÜ ” Íş” Íş
” Íş” Íş” Íş” Íş” Íş” Íş”! Íş”" Íş”& Íş"”( Íş$”, Íş(”- Íş)”. Íş*”1 Íş-”= Íş9”> Íş9Ü ” Í ” Í 
” Í ” Í ” Í ”# Í ”& Í "”' Í #”( Í $”) Í %”- Í )”0 Í ,”6 Í 2”7 Í 3”8 Í 4”9 Í 5”= Í 9”Ì@ Í <”ÌF Í ÌB”ÌG Í ÌBÜ ” Í” Í” Í” Í” Í” Í”" Í”# Í”& Í"”' Í#”( Í$”3 Í/”4 Í0”5 Í1”6 Í2”> Í:”? Í;”Ì@ Í<”ÌA Í=”ÌI ÍÌE”ÌL ÍÌH”ÌM ÍÌI”ÌN ÍÌJ”ÌP ÍÌL”ÌQ ÍÌM”ÌR ÍÌN”ÌS ÍÌNÜ ” Í” Í
” Í” Í” Í” Í”" Í”* Í&”+ Í'”0 Í,”1 Í-”2 Í.”3 Í/”4 Í0”5 Í1”8 Í4”9 Í5”ÌB Í>”ÌC Í?”ÌF ÍÌB”ÌG ÍÌC”ÌO ÍÌK”ÌR ÍÌN”ÌZ ÍÌV”Ì[ ÍÌW”Ì\ ÍÌX”Ì] ÍÌY”Ì^ ÍÌZ”Ì_ ÍÌ[”Ì` ÍÌ\”Ìa ÍÌ]’” Í” Íœ” Í” Í” Í” Í” Í” Í”' Í#”+ Í'”3 Í/”4 Í0”8 Í4”: Í6” Í” Í” Í” Í” Í” Í”  Í”( Í"”) Í#”, Í&”. Í(”6 Í0”7 Í1”8 Í1Ü ” Í	” Í		” Í	” Í	” Í	”" Í	”# Í	”& Í	 ”' Í	!”( Í	"”3 Í	-”4 Í	.”5 Í	/”6 Í	0”> Í	8”? Í	9”Ì@ Í	:”ÌA Í	;”ÌI Í	ÌC”ÌL Í	ÌF”ÌM Í	ÌG”ÌN Í	ÌH”ÌP Í	ÌJ”ÌQ Í	ÌK”ÌR Í	ÌL”ÌS Í	ÌL—” Í
” Í
” Í
” Í
”  Í
”( Í
"”) Í
"‘”	 Í‘” Í—” Í” Í” Í” Í”  Í”" Í”# Í‘”	 Í™” Í” Í
” Í” Í”! Í”& Í"”' Í#”/ Í+”0 Í,•” Í” Í” Í” Í” Í™” Í” Í
” Í” Í” Í” Í” Í” Í” Í–” Í” Í” Í” Í” Í” Í–” Í
” Í” Í” Í”# Í”% ÍÜ ” Í” Í” Í”" Í”% Í”( Í ”+ Í#”, Í$”7 Í/”8 Í0”9 Í1”: Í2”; Í3”< Í4”? Í7”ÌB Í:”ÌC Í;”ÌD Í<”ÌE Í=”ÌF Í>”ÌG Í?”ÌH ÍÌ@”ÌJ ÍÌB”ÌP ÍÌH”ÌQ ÍÌI”ÌR ÍÌI‘” Í‘” ÍÜ ” Í” Í” Í”" Í”% Í”& Í”/ Í(”0 Í)”1 Í*”2 Í+”5 Í.”= Í6”> Í7”ÌA Í:”ÌF Í?”ÌH ÍÌA”ÌN ÍÌG”ÌO ÍÌH”ÌP ÍÌH‘” Í‘” Í	–” Í” Í” Í” Í” Í”! ÍÜ ” Í
” Í” Í” Í”  Í”& Í ”) Í#”, Í&”/ Í)”0 Í*”; Í5”< Í6”= Í7”> Í8”? Í9”Ì@ Í:”ÌC Í=”ÌF ÍÌ@”ÌG ÍÌA”ÌH ÍÌB”ÌI ÍÌC”ÌJ ÍÌD”ÌK ÍÌE”ÌL ÍÌF”ÌM ÍÌG”ÌN ÍÌG‘” Í	‘” Íš” Í
” Í” Í” Í”  Í”$ Í”' Í!”, Í&”0 Í*”2 Í,Ü ” Í” Í” Í”" Í”$ Í”* Í"”- Í%”. Í&”7 Í/”8 Í0”9 Í1”: Í2”= Í5”ÌE Í=”ÌF Í>”ÌI ÍÌA”ÌN ÍÌF”ÌO ÍÌG”ÌP ÍÌG‘” Í‘” ÍÜ ” Í” Í” Í”" Í”$ Í”* Í"”- Í%”0 Í(”3 Í+”4 Í,”? Í7”Ì@ Í8”ÌA Í9”ÌB Í:”ÌC Í;”ÌD Í<”ÌG Í?”ÌJ ÍÌB”ÌK ÍÌC”ÌL ÍÌD”ÌM ÍÌE”ÌN ÍÌF”ÌO ÍÌG”ÌP ÍÌH”ÌQ ÍÌI”ÌR ÍÌI‘” Í ‘” Í!	”” Í"”	 Í"”
 Í"” Í"–” Í#” Í#” Í#” Í#” Í#” Í#˜” Í$” Í$
” Í$” Í$”$ Í$”) Í$#”/ Í$)”1 Í$+Ü ” Í%” Í%” Í%”  Í%”% Í%”& Í%”' Í%”( Í% ”- Í%%”. Í%&”/ Í%'”0 Í%(”4 Í%,”9 Í%1”< Í%4”= Í%5”> Í%6”? Í%7”ÌB Í%:”ÌC Í%;”ÌD Í%<”ÌE Í%=”ÌK Í%ÌC”ÌL Í%ÌC’” Í&”' Í&Ÿ” Í'” Í'” Í'” Í'”! Í'”& Í'”' Í'”* Í'"”+ Í'#”, Í'$”5 Í'-”7 Í'/”< Í'4”> Í'6”Ì@ Í'8’” Í(
”2 Í((˜” Í)
” Í)” Í)”  Í)”! Í)”) Í)”* Í) ”+ Í)!Ü ” Í*
” Í*”  Í*”& Í*”' Í*”0 Í*&”1 Í*'”2 Í*(”3 Í*)”ÌB Í*8”ÌC Í*9”ÌS Í*ÌI”ÌU Í*ÌK”Ì^ Í*ÌT”Ì` Í*ÌV”Ìi Í*Ì_”Ìk Í*Ìa”Ìp Í*Ìf”Ìq Í*Ìg”Ìr Í*Ìh”Ìs Í*Ìi”Ìt Í*Ìj”Ì} Í*Ìs”Ì~ Í*Ìt”Ì Í*Ìt˜” Í+
” Í+” Í+”  Í+”) Í+”* Í+ ”0 Í+&”1 Í+&–” Í,
” Í,”  Í,”% Í,”/ Í,%”1 Í,'œ” Í-” Í-”  Í-”) Í-”* Í-”. Í-"”0 Í-$”9 Í--”; Í-/”ÌD Í-8”ÌE Í-9”ÌF Í-9Ü ” Í.”! Í.”$ Í.”- Í.!”. Í."”7 Í.+”8 Í.,”9 Í.-”; Í./”Ì@ Í.4”ÌA Í.5”ÌD Í.8”ÌE Í.9”ÌJ Í.>”ÌO Í.ÌC”ÌX Í.ÌL”ÌY Í.ÌM”Ì_ Í.ÌS”Ì` Í.ÌT”Ìa Í.ÌU”Ìb Í.ÌV”Ìg Í.Ì[”Ìh Í.Ì\”Ìi Í.Ì]”Ìj Í.Ì^”Ìl Í.Ì`”Ìm Í.Ìa”Ìn Í.Ìa‘” Í/–” Í/” Í/”% Í/”* Í/"”4 Í/,”6 Í/.œ” Í0”! Í0”$ Í0”1 Í0%”2 Í0&”6 Í0*”8 Í0,”ÌA Í05”ÌC Í07”ÌL Í0Ì@”ÌM Í0ÌA”ÌN Í0ÌA‘” Í1”” Í2
” Í2”$ Í2”% Í2”” Í3” Í3	” Í3
” Í3
‘” Í4’” Í6” Í6Ÿ” Í7” Í7” Í7” Í7”$ Í7”( Í7"”) Í7#”* Í7$”+ Í7%”1 Í7+”2 Í7,”3 Í7-”4 Í7.”< Í76”= Í76–” Í8” Í8
” Í8” Í8”# Í8”% Í8–” Í9” Í9” Í9”" Í9”# Í9”$ Í9–” Í:” Í:” Í:” Í:” Í:” Í:–” Í;” Í;” Í;” Í;”  Í;”! Í;” Í<” Í<” Í<” Í<” Í<”& Í<”' Í<”( Í< ”1 Í<)”3 Í<+”8 Í<0”: Í<2”< Í<4Ü ” Í=
” Í=”  Í=”& Í=”' Í=”0 Í=&”1 Í='”2 Í=(”3 Í=)”ÌB Í=8”ÌC Í=9”ÌS Í=ÌI”ÌU Í=ÌK”Ì^ Í=ÌT”Ì` Í=ÌV”Ìi Í=Ì_”Ìk Í=Ìa”Ìp Í=Ìf”Ìq Í=Ìg”Ìr Í=Ìh”Ìs Í=Ìi”Ìt Í=Ìj”Ì} Í=Ìs”Ì~ Í=Ìt”Ì Í=Ìt˜” Í>
” Í>”! Í>”" Í>”( Í>”+ Í>!”1 Í>'”3 Í>)—” Í?” Í?”! Í?”* Í?”+ Í?”1 Í?%”2 Í?%•” Í@” Í@”" Í@”+ Í@”, Í@‘” ÍA”” ÍB” ÍB	” ÍB
” ÍB
˜” ÍC” ÍC” ÍC” ÍC” ÍC”% ÍC”& ÍC”' ÍCÜ ” ÍD” ÍD” ÍD” ÍD”" ÍD”# ÍD”' ÍD”( ÍD ”3 ÍD+”4 ÍD,”: ÍD2”; ÍD3”ÌB ÍD:”ÌC ÍD;”ÌE ÍD=”ÌL ÍDÌD”ÌM ÍDÌE”ÌY ÍDÌQ”ÌZ ÍDÌR”Ìl ÍDÌd”Ìm ÍDÌe”Ìn ÍDÌf”Ìo ÍDÌf›” ÍE” ÍE” ÍE”" ÍE”% ÍE”- ÍE%”. ÍE&”3 ÍE+”4 ÍE,”: ÍE2”; ÍE2Ü ” ÍF” ÍF” ÍF” ÍF” ÍF”  ÍF”# ÍF”& ÍF”' ÍF”+ ÍF#”, ÍF$”7 ÍF/”: ÍF2”ÌC ÍF;”ÌD ÍF<”ÌE ÍF<’” ÍG”ÌA ÍG9’” ÍH”0 ÍH(’” ÍI”Ì ÍIÌw’” ÍJ”ÌQ ÍJÌI’” ÍK”Ì| ÍKÌt’” ÍL”1 ÍL)’” ÍM”3 ÍM+’” ÍN”& ÍN’” ÍO”, ÍO$’” ÍP”Ìm ÍPÌe’” ÍQ”8 ÍQ0’” ÍR”& ÍR’” ÍS”" ÍS’” ÍT” ÍT’” ÍU”( ÍU ’” ÍV” ÍV’” ÍW”! ÍW”” ÍX” ÍX” ÍX” ÍXÜ ” ÍY
” ÍY” ÍY”# ÍY”$ ÍY”' ÍY”( ÍY”, ÍY"”- ÍY#”2 ÍY(”3 ÍY)”> ÍY4”ÌA ÍY7”ÌB ÍY8”ÌK ÍYÌA”ÌL ÍYÌB”ÌM ÍYÌC”ÌO ÍYÌE”ÌP ÍYÌF”ÌQ ÍYÌG”ÌR ÍYÌG‘” ÍZ	‘” Í[‘”	 Í\’” Í]”, Í](˜” Í^” Í^” Í^	” Í^” Í^” Í^” Í^” Í^Ü ” Í_” Í_
” Í_” Í_”$ Í_”% Í_”& Í_ ”( Í_"”0 Í_*”1 Í_+”6 Í_0”7 Í_1”= Í_7”? Í_9”ÌG Í_ÌA”ÌH Í_ÌB”ÌI Í_ÌB’” Í`”ÌG Í`ÌA’” Ía”ÌM ÍaÌG’” Íb” Íb
’” Íc”Ìl ÍcÌfÜ ” Íd” Íd” Íd” Íd” Íd”% Íd”& Íd ”+ Íd%”, Íd&”/ Íd)”0 Íd*”1 Íd+”5 Íd/”7 Íd1”< Íd6”> Íd8”Ì@ Íd:š” Íe” Íe” Íe” Íe” Íe”% Íe”& Íe”+ Íe#”, Íe$”. Íe&•” Íf
” Íf” Íf” Íf” Íf‘” Íg	”” Íh” Íh” Íh” Íh”” Íi” Íi” Íi” Íi‘”	 ÍjÜ ” Ím” Ím
” Ím”! Ím”4 Ím0”5 Ím1”9 Ím5”; Ím7”ÌF ÍmÌB”ÌH ÍmÌD”ÌP ÍmÌL”ÌR ÍmÌN”Ì^ ÍmÌZ”Ì` ÍmÌ\”Ìc ÍmÌ_”Ìe ÍmÌa”Ìm ÍmÌi”Ìn ÍmÌj”Ìo ÍmÌj’” Ío” Ío“” Íp” Íp	” Íp’” Íq” Íq’” Ír” Ír”” Ís” Ís” Ís” Ís’”	 Ít”
 Ít”” Íu” Íu” Íu” Íu’”  Ív ” ÍvŸ”  Íx ”	 Íx	” Íx” Íx”% Íx&”' Íx(”2 Íx3”4 Íx5”< Íx=”> Íx?”ÌJ ÍxÌK”ÌL ÍxÌM”ÌO ÍxÌP”ÌQ ÍxÌR”ÌY ÍxÌZÜ ” Íy” Íy” Íy” Íy” Íy” Íy”  Íy”! Íy”" Íy ”# Íy!”$ Íy"”% Íy#”& Íy$”' Íy%”( Íy&”) Íy&œ” Íz” Íz”
 Íz” Íz” Íz” Íz” Íz” Íz” Íz” Íz”' Íz#”( Íz#’” Í{” Í{™” Í}” Í}” Í}” Í}” Í}” Í}”$ Í}"”) Í}'”. Í},–” Í}.” Í}2” Í}5” Í}6” Í}7” Í}7™” Í~” Í~” Í~” Í~” Í~” Í~”$ Í~"”) Í~'”/ Í~-–” Í~/” Í~3” Í~6” Í~7” Í~8” Í~8›” Í€” Í€” Í€” Í€”' Í€%”( Í€&”+ Í€)”, Í€*”5 Í€3”6 Í€4”8 Í€6™” Í” Í
” Í” Í”! Í”" Í”+ Í'”, Í(”- Í(˜” Íƒ” Íƒ” Íƒ” Íƒ” Íƒ” Íƒ” Íƒ” Íƒ›” Í…” Í…” Í…” Í…” Í…”# Í…”$ Í… ”& Í…"”- Í…)”. Í…*”/ Í…*”” Í†” Í†” Í†” Í†”” Íˆ” Íˆ”	 Íˆ” Íˆ”” Íˆ” Íˆ” Íˆ+”  Íˆ+Ÿ” ÍŠ”	 ÍŠ” ÍŠ
” ÍŠ” ÍŠ” ÍŠ” ÍŠ” ÍŠ” ÍŠ”  ÍŠ”! ÍŠ”" ÍŠ ”# ÍŠ!”$ ÍŠ"”% ÍŠ"—” Í‹” Í‹” Í‹	” Í‹” Í‹” Í‹” Í‹” Í” Í” Í” Í” Í” Í” Í”( Í&”* Í(”1 Í/”2 Í0”4 Í2”6 Í4˜” Í” Í” Í” Í” Í” Í”  Í”! Í˜” Í” Í” Í” Í” Í” Í” Í” Í”” Í” Í” Í” Í”” Í’” Í’	” Í’” Í’’”  Í“ ” Í“—”  Í• ”	 Í•	” Í•” Í•”% Í•&”' Í•(”, Í•-™” Í–” Í–	” Í–” Í–” Í–” Í–” Í–”  Í–”" Í– ” Í—” Í—” Í—
” Í—” Í—”# Í—”% Í—!”- Í—)”/ Í—+”; Í—7”= Í—9”Ì@ Í—<”ÌH Í—ÌD”ÌI Í—ÌDš” Í™” Í™
” Í™” Í™” Í™”! Í™”" Í™”% Í™!”1 Í™-”2 Í™-™” Í›” Í›” Í›” Í›” Í›” Í›”( Í›$”) Í›%”* Í›%•” Í” Í” Í” Í”" Í˜” Í ” Í,” Í/” Í0” Í3”& Í:”' Í;”( Í;–” ÍŸ” ÍŸ” ÍŸ” ÍŸ”% ÍŸ!”' ÍŸ#Ü ” Í ” Í ” Í ” Í ” Í ” Í ” Í ”( Í "”) Í #”* Í $”+ Í %”. Í (”5 Í /”6 Í 0”7 Í 1”8 Í 2”9 Í 3”< Í 6”= Í 7”> Í 7Ü ” Í¡” Í¡” Í¡” Í¡” Í¡” Í¡” Í¡”( Í¡"”) Í¡#”* Í¡$”+ Í¡%”. Í¡(”5 Í¡/”6 Í¡0”7 Í¡1”8 Í¡2”9 Í¡3”< Í¡6”= Í¡7”> Í¡7‘”	 Í¢–” Í¤” Í¤” Í¤” Í¤” Í¤” Í¤™” Í¦” Í¦” Í¦” Í¦” Í¦”" Í¦”. Í¦*”3 Í¦/”; Í¦7•” Í¦9” Í¦>” Í¦ÌA” Í¦ÌB” Í¦ÌB™” Í§” Í§” Í§” Í§”! Í§”% Í§!”1 Í§-”6 Í§2”> Í§:•” Í§<” Í§ÌA” Í§ÌD” Í§ÌE” Í§ÌE™” Í¨” Í¨” Í¨” Í¨” Í¨”# Í¨”/ Í¨+”4 Í¨0”< Í¨8•” Í¨:” Í¨?” Í¨ÌB” Í¨ÌC” Í¨ÌC™” Í©” Í©” Í©” Í©”  Í©”$ Í© ”0 Í©,”5 Í©1”= Í©9•” Í©;” Í©Ì@” Í©ÌC” Í©ÌD” Í©ÌD–” Í«” Í«” Í«” Í«” Í«” Í«™” Í­” Í­” Í­” Í­” Í­”" Í­”. Í­*”3 Í­/”8 Í­4–” Í­6” Í­:” Í­>” Í­?” Í­Ì@” Í­Ì@™” Í®” Í®” Í®” Í®” Í®”# Í®”/ Í®+”4 Í®0”; Í®7–” Í®9” Í®=” Í®ÌA” Í®ÌB” Í®ÌC” Í®ÌC™” Í¯” Í¯” Í¯” Í¯”! Í¯”% Í¯!”1 Í¯-”6 Í¯2”= Í¯9–” Í¯;” Í¯?” Í¯ÌC” Í¯ÌD” Í¯ÌE” Í¯ÌE™” Í°” Í°” Í°” Í°”  Í°”$ Í° ”0 Í°,”5 Í°1”: Í°6–” Í°8” Í°<” Í°Ì@” Í°ÌA” Í°ÌB” Í°ÌB˜” Í²” Í²” Í²” Í²” Í²” Í²”# Í²”$ Í²’” Í´” Í´“” Íµ” Íµ	” Íµ’” Í¶” Í¶’”	 Í·”
 Í·”” Í¸” Í¸” Í¸” Í¸’”  Í¹ ” Í¹—”  Í» ”	 Í»	” Í»” Í» ”& Í»'”( Í»)”- Í».œ” Í¼”
 Í¼” Í¼
” Í¼” Í¼” Í¼” Í¼” Í¼” Í¼” Í¼”# Í¼!”$ Í¼!™” Í¾” Í¾	” Í¾” Í¾” Í¾” Í¾” Í¾”  Í¾”" Í¾ œ” Í¿” Í¿
” Í¿”  Í¿”" Í¿”* Í¿&”, Í¿(”7 Í¿3”9 Í¿5”< Í¿8”ÌD Í¿Ì@”ÌE Í¿Ì@” ÍÁ” ÍÁ” ÍÁ	” ÍÁ” ÍÁ” ÍÁ” ÍÁ” ÍÁ” ÍÁ” ÍÁ”  ÍÁ”! ÍÁ”" ÍÁ”# ÍÁ™” ÍÃ” ÍÃ” ÍÃ” ÍÃ” ÍÃ”" ÍÃ”* ÍÃ&”/ ÍÃ+”7 ÍÃ3•” ÍÃ5” ÍÃ:” ÍÃ=” ÍÃ>” ÍÃ>™” ÍÅ” ÍÅ” ÍÅ” ÍÅ” ÍÅ”" ÍÅ”* ÍÅ&”/ ÍÅ+”7 ÍÅ3•” ÍÅ5” ÍÅ9” ÍÅ<” ÍÅ=” ÍÅ=™” ÍÇ” ÍÇ” ÍÇ” ÍÇ”  ÍÇ”$ ÍÇ ”, ÍÇ(”1 ÍÇ-”9 ÍÇ5–” ÍÇ7” ÍÇ;” ÍÇ?” ÍÇÌ@” ÍÇÌA” ÍÇÌA” ÍÉ” ÍÉ
” ÍÉ”" ÍÉ”2 ÍÉ.”3 ÍÉ/”6 ÍÉ2”7 ÍÉ3”8 ÍÉ4”9 ÍÉ5”ÌC ÍÉ?”ÌD ÍÉÌ@”ÌF ÍÉÌB”ÌH ÍÉÌD™” ÍÊ” ÍÊ” ÍÊ” ÍÊ” ÍÊ”! ÍÊ”+ ÍÊ%”, ÍÊ&”- ÍÊ&˜” ÍË” ÍË” ÍË” ÍË” ÍË” ÍË”# ÍË”$ ÍË›” ÍÍ” ÍÍ” ÍÍ” ÍÍ” ÍÍ”" ÍÍ”# ÍÍ”% ÍÍ”- ÍÍ'”. ÍÍ(”/ ÍÍ(”” ÍÎ”	 ÍÎ”
 ÍÎ” ÍÎ”” ÍĞ” ÍĞ” ÍĞ	” ÍĞ–” ÍĞ” ÍĞ'” ÍĞ(”# ÍĞ-”% ÍĞ/”& ÍĞ/’” ÍÒ” ÍÒ“” ÍÓ” ÍÓ	” ÍÓ’” ÍÔ” ÍÔ’”	 ÍÕ”
 ÍÕ”” ÍÖ” ÍÖ” ÍÖ” ÍÖ’”  Í× ” Í×•”  ÍÙ ”	 ÍÙ	” ÍÙ” ÍÙ” ÍÙ œ” ÍÚ”
 ÍÚ” ÍÚ
” ÍÚ” ÍÚ”* ÍÚ(”, ÍÚ*”2 ÍÚ0”4 ÍÚ2”7 ÍÚ5”? ÍÚ=”Ì@ ÍÚ=“” ÍÜ” ÍÜ	” ÍÜ
”” Íİ” Íİ” Íİ
” Íİ”” ÍŞ” ÍŞ	” ÍŞ” ÍŞ˜” Íß” Íß” Íß” Íß” Íß”& Íß”' Íß”+ Íß#’” Íà” Íà”” Íá” Íá” Íá” Íá—” Íâ” Íâ	” Íâ” Íâ”  Íâ”( Íâ ”) Íâ!—” Íã” Íã	” Íã” Íã”  Íã”( Íã ”) Íã!“”	 Íä”
 Íä” Íä’”  Íå ” Íå•”  Íç ”	 Íç	” Íç” Íç” Íç˜” Íè”
 Íè” Íè
” Íè” Íè” Íè”% Íè#”& Íè#’” Íê” Íê	”” Íë” Íë
” Íë” Íë’” Íì” Íì’”  Íí ” Íí•”  Íï ”	 Íï	” Íï” Íï” Íïš” Íğ” Íğ” Íğ” Íğ” Íğ”" Íğ ”# Íğ!”, Íğ*”- Íğ+”. Íğ+˜” Íñ” Íñ	” Íñ” Íñ” Íñ” Íñ”& Íñ$”' Íñ$’”  Íò ” Íò•”  Íô ”	 Íô	” Íô” Íô” Íô œ” Íõ”
 Íõ” Íõ
” Íõ” Íõ”* Íõ(”, Íõ*”2 Íõ0”4 Íõ2”7 Íõ5”? Íõ=”Ì@ Íõ=™” Íö”
 Íö” Íö” Íö”  Íö”! Íö”) Íö'”* Íö(”+ Íö(™” Í÷”
 Í÷” Í÷” Í÷” Í÷” Í÷”' Í÷%”( Í÷&”) Í÷&›” Íø” Íø	” Íø” Íø” Íø” Íø” Íø” Íø” Íø” Íø”  Íø”” Íù” Íù” Íù
” Íù”” Íú” Íú	” Íú” Íú˜” Íû” Íû” Íû” Íû” Íû”" Íû”# Íû”' Íû#’” Íü” Íü”” Íı” Íı” Íı” Íı’” Íş” Íş	’” Íÿ” Íÿ	”” Í ” Í ” Í ” Í ’”  Í ” Í•”  Í ”	 Í	” Í” Í” Í ˜” Í”
 Í” Í
” Í” Í”! Í”) Í'”* Í'Ü ” Í” Í	” Í” Í” Í”  Í”& Í$”' Í%”) Í'”* Í(”+ Í)”- Í+”3 Í1”5 Í3”6 Í4”7 Í5”8 Í5’”  Í ” Í•”  Í	 ”	 Í		” Í	” Í	” Í	š” Í
” Í
” Í
” Í
” Í
”" Í
 ”# Í
!”, Í
*”- Í
+”. Í
+˜” Í” Í	” Í” Í” Í” Í”& Í$”' Í$’”  Í ” Í•”  Í ”	 Í	” Í” Í”  Í!Ü ” Í”
 Í” Í
” Í” Í”* Í(”, Í*”2 Í0”4 Í2”8 Í6”: Í8”ÌB ÍÌ@”ÌD ÍÌB”ÌG ÍÌE”ÌO ÍÌM”ÌP ÍÌM™” Í”
 Í” Í” Í”! Í”" Í ”* Í(”+ Í)”, Í)›” Í”
 Í” Í” Í”  Í”! Í”) Í'”+ Í)”1 Í/”2 Í0”3 Í0œ” Í” Í	” Í” Í” Í” Í” Í” Í” Í” Í”! Í”# Í!” Í” Í” Í” Í” Í” Í”# Í”' Í#”/ Í+”0 Í,”9 Í5”: Í6”> Í:”? Í:’” Í” Í’” Í”? Í;’” Í” Í’” Í” Í”” Í” Í
” Í” Í”” Í” Í” Í” Í’” Í” Í’” Í” Í”” Í” Í” Í” Í’” Í” Í—” Í ” Í ” Í ” Í ” Í ” Í ” Í š” Í!” Í!” Í!” Í!”! Í!”" Í!”# Í!”( Í!"”) Í!#”* Í!$’”	 Í"”
 Í"”” Í#” Í#” Í#” Í#’”  Í$ ” Í$•”  Í& ”	 Í&	” Í&” Í&”  Í&!Ü ” Í'”
 Í'” Í'
” Í'” Í'” Í'”! Í'”) Í''”+ Í')”4 Í'2”6 Í'4”> Í'<”Ì@ Í'>”ÌC Í'ÌA”ÌK Í'ÌI”ÌL Í'ÌI” Í)” Í)	” Í)” Í)” Í)” Í)” Í)”" Í) ”$ Í)"”% Í)#”' Í)%”) Í)'”* Í)(”+ Í))” Í*” Í*” Í*”& Í*"”' Í*#”, Í*(”. Í**”6 Í*2”8 Í*4”ÌA Í*=”ÌC Í*?”ÌK Í*ÌG”ÌL Í*ÌHš” Í+” Í+” Í+” Í+” Í+” Í+” Í+” Í+”" Í+”$ Í+ ”” Í,” Í,” Í,” Í,’”  Í- ” Í-›”  Í/ ”	 Í/	” Í/” Í/”$ Í/%”& Í/'”. Í//”0 Í/1”9 Í/:”; Í/<”ÌC Í/ÌDœ” Í0” Í0”
 Í0” Í0” Í0” Í0” Í0” Í0” Í0”  Í0”) Í0%”* Í0%˜” Í1” Í1”
 Í1” Í1” Í1” Í1” Í1” Í1–” Í2” Í2” Í2” Í2” Í2” Í2™” Í4” Í4” Í4” Í4” Í4” Í4”& Í4$”+ Í4)”3 Í41•” Í43” Í48” Í4;” Í4<” Í4<™” Í5” Í5” Í5” Í5” Í5” Í5”& Í5$”+ Í5)”1 Í5/–” Í51” Í55” Í59” Í5:” Í5;” Í5;™” Í6” Í6” Í6” Í6” Í6” Í6”& Í6$”+ Í6)”1 Í6/–” Í61” Í67” Í6;” Í6<” Í6=” Í6=˜” Í8”
 Í8” Í8” Í8” Í8” Í8” Í8” Í8œ” Í9”
 Í9” Í9	” Í9” Í9” Í9” Í9” Í9” Í9”# Í9!”$ Í9"”% Í9"”” Í;” Í;	” Í;” Í;’”  Í< ” Í<—”  Í> ”	 Í>	” Í>” Í>” Í> ”! Í>"”' Í>(˜” Í?”
 Í?” Í?
” Í?” Í?” Í?”! Í?”" Í?Ü ” ÍA” ÍA”
 ÍA” ÍA” ÍA” ÍA” ÍA”! ÍA”# ÍA!”- ÍA+”/ ÍA-”9 ÍA7”; ÍA9”ÌF ÍAÌD”ÌH ÍAÌF”ÌR ÍAÌP”ÌT ÍAÌR”Ìa ÍAÌ_”Ìc ÍAÌa”Ìp ÍAÌn”Ìr ÍAÌp”Ìu ÍAÌs”Ì} ÍAÌ{”Ì~ ÍAÌ|”Ì‡ ÍAÌ…”Ìˆ ÍAÌ…”” ÍB” ÍB” ÍB” ÍB”” ÍC” ÍC” ÍC
” ÍC’” ÍD” ÍD’” ÍE” ÍE
’” ÍF” ÍF’” ÍG” ÍG’” ÍH” ÍH’” ÍI” ÍI’” ÍJ” ÍJ’” ÍK” ÍK’” ÍL” ÍL™” ÍM”
 ÍM” ÍM” ÍM”' ÍM%”( ÍM&”0 ÍM.”1 ÍM/”2 ÍM/š” ÍO”	 ÍO” ÍO
” ÍO” ÍO” ÍO” ÍO”" ÍO ”# ÍO!”$ ÍO!Ü ” ÍQ”
 ÍQ” ÍQ” ÍQ” ÍQ” ÍQ” ÍQ” ÍQ” ÍQ”! ÍQ”) ÍQ'”+ ÍQ)”- ÍQ+”/ ÍQ-”0 ÍQ.”1 ÍQ/“” ÍR” ÍR” ÍR”” ÍS” ÍS” ÍS” ÍS”” ÍT” ÍT” ÍT” ÍT”” ÍV” ÍV	” ÍV” ÍV’”  ÍW ” ÍW•”  ÍY ”	 ÍY	” ÍY” ÍY ”' ÍY(•” ÍZ” ÍZ” ÍZ” ÍZ” ÍZ’” ÍZ” ÍZ"”” Í[” Í[” Í[” Í[”” Í\” Í\” Í\”" Í\’”	 Í]”
 Í]•” Í_” Í_” Í_” Í_” Í_’” Í_” Í_#”” Í`” Í`” Í`” Í`”” Ía” Ía” Ía”" Ía’”	 Íb”
 Íb•” Íd” Íd” Íd” Íd” Íd’” Íd” Íd!”” Íe” Íe” Íe” Íe”” Íf” Íf” Íf”" Íf’”	 Íg”
 Íg•” Íi” Íi” Íi” Íi” Íi’” Íi” Íi$”” Íj” Íj” Íj” Íj”” Ík” Ík” Ík” Ík’”	 Íl”
 Íl’”  Ím ” Ím•”  Ío ”	 Ío	” Ío” Ío” Ío œ” Íp”
 Íp” Íp
” Íp” Íp”* Íp(”, Íp*”2 Íp0”4 Íp2”7 Íp5”? Íp=”Ì@ Íp=“” Ír” Ír	” Ír
”” Ís” Ís” Ís
” Ís”” Ít” Ít	” Ít” Ít’” Íu” Íu”” Ív” Ív” Ív” Ív—” Íw” Íw	” Íw” Íw”  Íw”( Íw ”) Íw!—” Íx” Íx	” Íx” Íx”  Íx”( Íx ”) Íx!“”	 Íy”
 Íy” Íy’”  Íz ” Íz•”  Í| ”	 Í|	” Í|” Í|” Í|š” Í}”
 Í}” Í}
” Í}” Í}” Í}”  Í}”# Í}!”+ Í})”, Í})’” Í” Í	”” Í€” Í€” Í€” Í€”” Í” Í” Í” Í’” Í‚” Í‚’”  Íƒ ” Íƒ•”  Í… ”	 Í…	” Í…” Í…” Í…” Í†”
 Í†” Í†
” Í†” Í†”" Í† ”$ Í†"”1 Í†/”3 Í†1”8 Í†6”: Í†8”= Í†;”ÌE Í†ÌC”ÌF Í†ÌC›” Íˆ”
 Íˆ” Íˆ” Íˆ”" Íˆ ”# Íˆ!”+ Íˆ)”- Íˆ+”9 Íˆ7”: Íˆ8”; Íˆ8’” Í‰” Í‰–” ÍŠ” ÍŠ	” ÍŠ” ÍŠ” ÍŠ” ÍŠ–” Í‹” Í‹” Í‹
” Í‹” Í‹” Í‹–” ÍŒ” ÍŒ” ÍŒ” ÍŒ” ÍŒ”$ ÍŒ –” Í” Í” Í” Í” Í”$ Í –” Í” Í” Í” Í” Í”  Í“” Í” Í” Í’”  Í ” Í—”  Í’ ”	 Í’	” Í’” Í’”" Í’#”$ Í’%”, Í’-›” Í“” Í””	 Í”” Í”” Í”” Í”” Í””' Í”#”, Í”(”3 Í”/”4 Í”0š” Í•”	 Í•” Í•” Í•” Í•”" Í•”* Í•&”/ Í•+”6 Í•2”7 Í•3š” Í–”	 Í–” Í–” Í–” Í–”  Í–”( Í–$”- Í–)”5 Í–1”6 Í–2’” Í—” Í—”” Í˜” Í˜” Í˜” Í˜”” Í™” Í™” Í™”" Í™’”	 Íš”
 Íš›” Íœ” Í”	 Í” Í” Í” Í” Í”' Í#”, Í(”1 Í-”2 Í.š” Í”	 Í” Í” Í” Í”" Í”* Í&”/ Í+”4 Í0”5 Í1š” ÍŸ”	 ÍŸ” ÍŸ” ÍŸ” ÍŸ”! ÍŸ”) ÍŸ%”. ÍŸ*”6 ÍŸ2”7 ÍŸ3’” Í ” Í ”” Í¡” Í¡” Í¡” Í¡”” Í¢” Í¢” Í¢”" Í¢’”	 Í£”
 Í£›” Í¥” Í¦”	 Í¦” Í¦” Í¦” Í¦” Í¦”' Í¦#”, Í¦(”4 Í¦0”5 Í¦1š” Í§”	 Í§” Í§” Í§” Í§”  Í§”( Í§$”- Í§)”2 Í§.”3 Í§/š” Í¨”	 Í¨” Í¨” Í¨” Í¨”! Í¨”) Í¨%”. Í¨*”3 Í¨/”4 Í¨0’” Í©” Í©”” Íª” Íª” Íª” Íª”” Í«” Í«” Í«”" Í«’”	 Í¬”
 Í¬›” Í®” Í¯”	 Í¯” Í¯” Í¯” Í¯”" Í¯”* Í¯&”/ Í¯+”7 Í¯3”8 Í¯4š” Í°”	 Í°” Í°” Í°” Í°”  Í°”( Í°$”- Í°)”4 Í°0”5 Í°1š” Í±”	 Í±” Í±” Í±” Í±”! Í±”) Í±%”. Í±*”5 Í±1”6 Í±2’” Í²” Í²”” Í³” Í³” Í³” Í³”” Í´” Í´” Í´” Í´’”	 Íµ”
 Íµ’”  Í¶ ” Í¶•”  Í¸ ”	 Í¸	” Í¸” Í¸”$ Í¸%œ” Í¹”
 Í¹” Í¹
” Í¹” Í¹”* Í¹(”, Í¹*”2 Í¹0”4 Í¹2”7 Í¹5”? Í¹=”Ì@ Í¹=™” Í»”
 Í»” Í»” Í»”% Í»#”& Í»$”. Í»,”/ Í»-”0 Í»-™” Í¼”
 Í¼” Í¼” Í¼”# Í¼!”$ Í¼"”, Í¼*”- Í¼+”. Í¼+›” Í¾” Í¾	” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾” Í¾”  Í¾”” Í¿” Í¿” Í¿
” Í¿”” ÍÀ” ÍÀ	” ÍÀ” ÍÀ˜” ÍÁ” ÍÁ” ÍÁ” ÍÁ” ÍÁ”# ÍÁ”$ ÍÁ ”( ÍÁ$’” ÍÂ” ÍÂ”” ÍÃ” ÍÃ” ÍÃ” ÍÃ’” ÍÄ” ÍÄ	’” ÍÅ” ÍÅ	”” ÍÆ” ÍÆ” ÍÆ” ÍÆ’”  ÍÇ ” ÍÇ•”  ÍÉ ”	 ÍÉ	” ÍÉ” ÍÉ”$ ÍÉ%˜” ÍÊ”
 ÍÊ” ÍÊ
” ÍÊ” ÍÊ”" ÍÊ ”* ÍÊ(”+ ÍÊ(Ü ” ÍÌ” ÍÌ	” ÍÌ” ÍÌ”  ÍÌ”! ÍÌ”' ÍÌ%”( ÍÌ&”* ÍÌ(”+ ÍÌ)”, ÍÌ*”. ÍÌ,”4 ÍÌ2”6 ÍÌ4”7 ÍÌ5”8 ÍÌ6”9 ÍÌ6’”  ÍÍ ” ÍÍ•”  ÍÏ ”	 ÍÏ	” ÍÏ” ÍÏ”# ÍÏ$š” ÍĞ” ÍĞ” ÍĞ” ÍĞ” ÍĞ”# ÍĞ!”$ ÍĞ"”- ÍĞ+”. ÍĞ,”/ ÍĞ,˜” ÍÑ” ÍÑ	” ÍÑ” ÍÑ” ÍÑ” ÍÑ”' ÍÑ%”( ÍÑ%’”  ÍÒ ” ÍÒ•”  ÍÔ ”	 ÍÔ	” ÍÔ” ÍÔ” ÍÔ™” ÍÕ” ÍÕ”	 ÍÕ” ÍÕ” ÍÕ” ÍÕ” ÍÕ” ÍÕ”  ÍÕ’”  ÍÖ ” ÍÖÔrG–§version¤file§sources®sourcesContent¥names¨mappingsÀ‘À‘ÀÜ6‘”    ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”  	 ‘”  
 ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”   ‘”    ‘”  ! ‘”  " ‘”  # ‘”  $ ‘”  % ‘”  & ‘”  ' ‘”  ( ‘”  ) ‘”  * ‘”  + ‘”  , ‘”  - ‘”  . ‘”  / ‘”  0 ‘”  1 ‘”  2 ‘”  3 ‘”  4 ‘”  5 ‘”  6 ‘”  7 ‘”  8 ‘”  9 ‘”  : ‘”  ; ‘”  < ‘”  = ‘”  > ‘”  ? ‘”  Ì@ ‘”  ÌA ‘”  ÌB ‘”  ÌC ‘”  ÌD ‘”  ÌE ‘”  ÌF ‘”  ÌG ‘”  ÌH ‘”  ÌI ‘”  ÌJ ‘”  ÌK ‘”  ÌL ‘”  ÌM ‘”  ÌN ‘”  ÌO ‘”  ÌP ‘”  ÌQ ‘”  ÌR ‘”  ÌS ‘”  ÌT ‘”  ÌU ‘”  ÌV ‘”  ÌW ‘”  ÌX ‘”  ÌY ‘”  ÌZ ‘”  Ì[ ‘”  Ì\ ‘”  Ì] ‘”  Ì^ ‘”  Ì_ ‘”  Ì` ‘”  Ìa ‘”  Ìb ‘”  Ìc ‘”  Ìd ‘”  Ìe ‘”  Ìf ‘”  Ìg ‘”  Ìh ‘”  Ìi ‘”  Ìj ‘”  Ìk ‘”  Ìl ‘”  Ìm ‘”  Ìn ‘”  Ìo ‘”  Ìp ‘”  Ìq ‘”  Ìr ‘”  Ìs ‘”  Ìt ‘”  Ìu ‘”  Ìv ‘”  Ìw ‘”  Ìx ‘”  Ìy ‘”  Ìz ‘”  Ì{ ‘”  Ì| ‘”  Ì} ‘”  Ì~ ‘”  Ì ‘”  Ì€ ‘”  Ì ‘”  Ì‚ ‘”  Ìƒ ‘”  Ì„ ‘”  Ì… ‘”  Ì† ‘”  Ì‡ ‘”  Ìˆ ‘”  Ì‰ ‘”  ÌŠ ‘”  Ì‹ ‘”  ÌŒ ‘”  Ì ‘”  Ì ‘”  Ì ‘”  Ì ‘”  Ì‘ ‘”  Ì’ ‘”  Ì“ ‘”  Ì” ‘”  Ì• ‘”  Ì– ‘”  Ì— ‘”  Ì˜ ‘”  Ì™ ‘”  Ìš ‘”  Ì› ‘”  Ìœ ‘”  Ì ‘”  Ì ‘”  ÌŸ ‘”  Ì  ‘”  Ì¡ ‘”  Ì¢ ‘”  Ì£ ‘”  Ì¤ ‘”  Ì¥ ‘”  Ì¦ ‘”  Ì§ ‘”  Ì¨ ‘”  Ì© ‘”  Ìª ‘”  Ì« ‘”  Ì¬ ‘”  Ì­ ‘”  Ì® ‘”  Ì¯ ‘”  Ì° ‘”  Ì± ‘”  Ì² ‘”  Ì³ ‘”  Ì´ ‘”  Ìµ ‘”  Ì¶ ‘”  Ì· ‘”  Ì¸ ‘”  Ì¹ ‘”  Ìº ‘”  Ì» ‘”  Ì¼ ‘”  Ì½ ‘”  Ì¾ ‘”  Ì¿ ‘”  ÌÀ ‘”  ÌÁ ‘”  ÌÂ ‘”  ÌÃ ‘”  ÌÄ ‘”  ÌÅ ‘”  ÌÆ ‘”  ÌÇ ‘”  ÌÈ ‘”  ÌÉ ‘”  ÌÊ ‘”  ÌË ‘”  ÌÌ ‘”  ÌÍ ‘”  ÌÎ ‘”  ÌÏ ‘”  ÌĞ ‘”  ÌÑ ‘”  ÌÒ ‘”  ÌÓ ‘”  ÌÔ ‘”  ÌÕ ‘”  ÌÖ ‘”  Ì× ‘”  ÌØ ‘”  ÌÙ ‘”  ÌÚ ‘”  ÌÛ ‘”  ÌÜ ‘”  Ìİ ‘”  ÌŞ ‘”  Ìß ‘”  Ìà ‘”  Ìá ‘”  Ìâ ‘”  Ìã ‘”  Ìä ‘”  Ìå ‘”  Ìæ ‘”  Ìç ‘”  Ìè ‘”  Ìé ‘”  Ìê ‘”  Ìë ‘”  Ìì ‘”  Ìí ‘”  Ìî ‘”  Ìï ‘”  Ìğ ‘”  Ìñ ‘”  Ìò ‘”  Ìó ‘”  Ìô ‘”  Ìõ ‘”  Ìö ‘”  Ì÷ ‘”  Ìø ‘”  Ìù ‘”  Ìú ‘”  Ìû ‘”  Ìü ‘”  Ìı ‘”  Ìş ‘”  Ìÿ ‘”  Í  ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í	 ‘”  Í
 ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í  ‘”  Í! ‘”  Í" ‘”  Í# ‘”  Í$ ‘”  Í% ‘”  Í& ‘”  Í' ‘”  Í( ‘”  Í) ‘”  Í* ‘”  Í+ ‘”  Í, ‘”  Í- ‘”  Í. ‘”  Í/ ‘”  Í0 ‘”  Í1 ‘”  Í2 ‘”  Í3 ‘”  Í4 ‘”  Í5 ‘”  Í6 ‘”  Í7 ‘”  Í8 ‘”  Í9 ‘”  Í: ‘”  Í; ‘”  Í< ‘”  Í= ‘”  Í> ‘”  Í? ‘”  Í@ ‘”  ÍA ‘”  ÍB ‘”  ÍC ‘”  ÍD ‘”  ÍE ‘”  ÍF ‘”  ÍG ‘”  ÍH ‘”  ÍI ‘”  ÍJ ‘”  ÍK ‘”  ÍL ‘”  ÍM ‘”  ÍN ‘”  ÍO ‘”  ÍP ‘”  ÍQ ‘”  ÍR ‘”  ÍS ‘”  ÍT ‘”  ÍU ‘”  ÍV ‘”  ÍW ‘”  ÍX ‘”  ÍY ‘”  ÍZ ‘”  Í[ ‘”  Í\ ‘”  Í] ‘”  Í^ ‘”  Í_ ‘”  Í` ‘”  Ía ‘”  Íb ‘”  Íc ‘”  Íd ‘”  Íe ‘”  Íf ‘”  Íg ‘”  Íh ‘”  Íi ‘”  Íj ‘”  Ík ‘”  Íl ‘”  Ím ‘”  Ín ‘”  Ío ‘”  Íp ‘”  Íq ‘”  Ír ‘”  Ís ‘”  Ít ‘”  Íu ‘”  Ív ‘”  Íw ‘”  Íx ‘”  Íy ‘”  Íz ‘”  Í{ ‘”  Í| ‘”  Í} ‘”  Í~ ‘”  Í ‘”  Í€ ‘”  Í ‘”  Í‚ ‘”  Íƒ ‘”  Í„ ‘”  Í… ‘”  Í† ‘”  Í‡ ‘”  Íˆ ‘”  Í‰ ‘”  ÍŠ ‘”  Í‹ ‘”  ÍŒ ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í‘ ‘”  Í’ ‘”  Í“ ‘”  Í” ‘”  Í• ‘”  Í– ‘”  Í— ‘”  Í˜ ‘”  Í™ ‘”  Íš ‘”  Í› ‘”  Íœ ‘”  Í ‘”  Í ‘”  ÍŸ ‘”  Í  ‘”  Í¡ ‘”  Í¢ ‘”  Í£ ‘”  Í¤ ‘”  Í¥ ‘”  Í¦ ‘”  Í§ ‘”  Í¨ ‘”  Í© ‘”  Íª ‘”  Í« ‘”  Í¬ ‘”  Í­ ‘”  Í® ‘”  Í¯ ‘”  Í° ‘”  Í± ‘”  Í² ‘”  Í³ ‘”  Í´ ‘”  Íµ ‘”  Í¶ ‘”  Í· ‘”  Í¸ ‘”  Í¹ ‘”  Íº ‘”  Í» ‘”  Í¼ ‘”  Í½ ‘”  Í¾ ‘”  Í¿ ‘”  ÍÀ ‘”  ÍÁ ‘”  ÍÂ ‘”  ÍÃ ‘”  ÍÄ ‘”  ÍÅ ‘”  ÍÆ ‘”  ÍÇ ‘”  ÍÈ ‘”  ÍÉ ‘”  ÍÊ ‘”  ÍË ‘”  ÍÌ ‘”  ÍÍ ‘”  ÍÎ ‘”  ÍÏ ‘”  ÍĞ ‘”  ÍÑ ‘”  ÍÒ ‘”  ÍÓ ‘”  ÍÔ ‘”  ÍÕ ‘”  ÍÖ ‘”  Í× ‘”  ÍØ ‘”  ÍÙ ‘”  ÍÚ ‘”  ÍÛ ‘”  ÍÜ ‘”  Íİ ‘”  ÍŞ ‘”  Íß ‘”  Íà ‘”  Íá ‘”  Íâ ‘”  Íã ‘”  Íä ‘”  Íå ‘”  Íæ ‘”  Íç ‘”  Íè ‘”  Íé ‘”  Íê ‘”  Íë ‘”  Íì ‘”  Íí ‘”  Íî ‘”  Íï ‘”  Íğ ‘”  Íñ ‘”  Íò ‘”  Íó ‘”  Íô ‘”  Íõ ‘”  Íö ‘”  Í÷ ‘”  Íø ‘”  Íù ‘”  Íú ‘”  Íû ‘”  Íü ‘”  Íı ‘”  Íş ‘”  Íÿ ‘”  Í  ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í	 ‘”  Í
 ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í  ‘”  Í! ‘”  Í" ‘”  Í# ‘”  Í$ ‘”  Í% ‘”  Í& ‘”  Í' ‘”  Í( ‘”  Í) ‘”  Í* ‘”  Í+ ‘”  Í, ‘”  Í- ‘”  Í. ‘”  Í/ ‘”  Í0 ‘”  Í1 ‘”  Í2 ‘”  Í3 ‘”  Í4 ‘”  Í5 ‘”  Í6 ‘”  Í7 ‘”  Í8 ‘”  Í9 ‘”  Í: ‘”  Í; ‘”  Í< ‘”  Í= ‘”  Í> ‘”  Í? ‘”  Í@ ‘”  ÍA ‘”  ÍB ‘”  ÍC ‘”  ÍD ‘”  ÍE ‘”  ÍF ‘”  ÍG ‘”  ÍH ‘”  ÍI ‘”  ÍJ ‘”  ÍK ‘”  ÍL ‘”  ÍM ‘”  ÍN ‘”  ÍO ‘”  ÍP ‘”  ÍQ ‘”  ÍR ‘”  ÍS ‘”  ÍT ‘”  ÍU ‘”  ÍV ‘”  ÍW ‘”  ÍX ‘”  ÍY ‘”  ÍZ ‘”  Í[ ‘”  Í\ ‘”  Í] ‘”  Í^ ‘”  Í_ ‘”  Í` ‘”  Ía ‘”  Íb ‘”  Íc ‘”  Íd ‘”  Íe ‘”  Íf ‘”  Íg ‘”  Íh ‘”  Íi ‘”  Íj ‘”  Ík ‘”  Íl ‘”  Ím ‘”  Ín ‘”  Ío ‘”  Íp ‘”  Íq ‘”  Ír ‘”  Ís ‘”  Ít ‘”  Íu ‘”  Ív ‘”  Íw ‘”  Íx ‘”  Íy ‘”  Íz ‘”  Í{ ‘”  Í| ‘”  Í} ‘”  Í~ ‘”  Í ‘”  Í€ ‘”  Í ‘”  Í‚ ‘”  Íƒ ‘”  Í„ ‘”  Í… ‘”  Í† ‘”  Í‡ ‘”  Íˆ ‘”  Í‰ ‘”  ÍŠ ‘”  Í‹ ‘”  ÍŒ ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í‘ ‘”  Í’ ‘”  Í“ ‘”  Í” ‘”  Í• ‘”  Í– ‘”  Í— ‘”  Í˜ ‘”  Í™ ‘”  Íš ‘”  Í› ‘”  Íœ ‘”  Í ‘”  Í ‘”  ÍŸ ‘”  Í  ‘”  Í¡ ‘”  Í¢ ‘”  Í£ ‘”  Í¤ ‘”  Í¥ ‘”  Í¦ ‘”  Í§ ‘”  Í¨ ‘”  Í© ‘”  Íª ‘”  Í« ‘”  Í¬ ‘”  Í­ ‘”  Í® ‘”  Í¯ ‘”  Í° ‘”  Í± ‘”  Í² ‘”  Í³ ‘”  Í´ ‘”  Íµ ‘”  Í¶ ‘”  Í· ‘”  Í¸ ‘”  Í¹ ‘”  Íº ‘”  Í» ‘”  Í¼ ‘”  Í½ ‘”  Í¾ ‘”  Í¿ ‘”  ÍÀ ‘”  ÍÁ ‘”  ÍÂ ‘”  ÍÃ ‘”  ÍÄ ‘”  ÍÅ ‘”  ÍÆ ‘”  ÍÇ ‘”  ÍÈ ‘”  ÍÉ ‘”  ÍÊ ‘”  ÍË ‘”  ÍÌ ‘”  ÍÍ ‘”  ÍÎ ‘”  ÍÏ ‘”  ÍĞ ‘”  ÍÑ ‘”  ÍÒ ‘”  ÍÓ ‘”  ÍÔ ‘”  ÍÕ ‘”  ÍÖ ‘”  Í× ‘”  ÍØ ‘”  ÍÙ ‘”  ÍÚ ‘”  ÍÛ ‘”  ÍÜ ‘”  Íİ ‘”  ÍŞ ‘”  Íß ‘”  Íà ‘”  Íá ‘”  Íâ ‘”  Íã ‘”  Íä ‘”  Íå ‘”  Íæ ‘”  Íç ‘”  Íè ‘”  Íé ‘”  Íê ‘”  Íë ‘”  Íì ‘”  Íí ‘”  Íî ‘”  Íï ‘”  Íğ ‘”  Íñ ‘”  Íò ‘”  Íó ‘”  Íô ‘”  Íõ ‘”  Íö ‘”  Í÷ ‘”  Íø ‘”  Íù ‘”  Íú ‘”  Íû ‘”  Íü ‘”  Íı ‘”  Íş ‘”  Íÿ ‘”  Í  ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í	 ‘”  Í
 ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í ‘”  Í  ‘”  Í! ‘”  Í" ‘”  Í# ‘”  Í$ ‘”  Í% ‘”  Í& ‘”  Í' ‘”  Í( ‘”  Í) ‘”  Í* ‘”  Í+ ‘”  Í, ‘”  Í- ‘”  Í. ‘”  Í/ ‘”  Í0 ‘”  Í1 ‘”  Í2 ‘”  Í3 ‘”  Í4 ‘”  Í5 ÔrH’§missing¦pluginÃ¦genAbcÂÔ  ÔrI”²dynamicImportCache¹exportAllDeclarationCache»exportNamedDeclarationCache«importCache‘ÔrJ–¤type¥start£end«declarationªspecifiers¦source¶ExportNamedDeclarationÍæÍ¬ÔrK™¤type¥start£end¢idªexpression©generator¥async¦params¤body³FunctionDeclarationÍíÍ¬ÔrL”¤type¥start£end¤nameªIdentifierÍüÍ ¤axisÂÂÃ’LªIdentifierÍÍ¥chartLªIdentifierÍÍ¦optionÔrM”¤type¥start£end¤body®BlockStatementÍÍ¬šÔrN”¤type¥start£endªexpression³ExpressionStatementÍˆÍ¹ÔrO–¤type¥start£end¨operator¤left¥right´AssignmentExpressionÍˆÍ¸¡=LªIdentifierÍˆÍ˜°callbackSendableÔrP–¤type¥start£end¤left¨operator¥right±LogicalExpressionÍ›Í¸ÔrQ—¤type¥start£end¦object¨property¨computed¨optional°MemberExpressionÍ›Í²LªIdentifierÍ›Í ¥chartLªIdentifierÍ¡Í²±sendableTestClassÂÂ¢||ÔrR”¤type¥start£endªproperties°ObjectExpressionÍ¶Í¸ÔrS•¤type¥start£end¬declarations¤kind³VariableDeclarationÍ¿Íå‘ÔrT•¤type¥start£end¢id¤init²VariableDeclaratorÍÃÍäR­ObjectPatternÍÃÍÛ“ÔrU™¤type¥start£end¦method©shorthand¨computed£key¤kind¥value¨PropertyÍÅÍÊÂÃÂLªIdentifierÍÅÍÊ¥xAxis¤initLªIdentifierÍÅÍÊ¥xAxisU¨PropertyÍÌÍÑÂÃÂLªIdentifierÍÌÍÑ¥yAxis¤initLªIdentifierÍÌÍÑ¥yAxisU¨PropertyÍÓÍÙÂÃÂLªIdentifierÍÓÍÙ¦series¤initLªIdentifierÍÓÍÙ¦seriesLªIdentifierÍŞÍä¦option£letS³VariableDeclarationÍëÍü‘T²VariableDeclaratorÍïÍûLªIdentifierÍïÍö§allAxisÔrV”¤type¥start£end¨elements¯ArrayExpressionÍùÍû£letÔrW–¤type¥start£end¤testªconsequent©alternate«IfStatementÍ$ÍgP±LogicalExpressionÍ(Í@P±LogicalExpressionÍ(Í6LªIdentifierÍ(Í-¥xAxis¢&&LªIdentifierÍ1Í6¥yAxis¢&&LªIdentifierÍ:Í@¦seriesM®BlockStatementÍBÍgšN³ExpressionStatementÍMÍpO´AssignmentExpressionÍMÍo¡=LªIdentifierÍMÍT§allAxisÔrX–¤type¥start£end¦callee©arguments¨optional®CallExpressionÍWÍoLªIdentifierÍWÍaªgetAllAxis’LªIdentifierÍbÍg¥xAxisLªIdentifierÍiÍn¥yAxisÂN³ExpressionStatementÍzÍ¤O´AssignmentExpressionÍzÍ£¡=LªIdentifierÍzÍ§allAxisX®CallExpressionÍ„Í£LªIdentifierÍ„Íš¶mergeDefaultAxisConfig‘LªIdentifierÍ›Í¢§allAxisÂN³ExpressionStatementÍ®ÍÛO´AssignmentExpressionÍ®ÍÚ¡=LªIdentifierÍ®Íµ§allAxisX®CallExpressionÍ¸ÍÚQ°MemberExpressionÍ¸ÍÆLªIdentifierÍ¸Í¿§allAxisLªIdentifierÍÀÍÆ¦filterÂÂ‘K·ArrowFunctionExpressionÍÇÍÙÀÃÂÂ‘R­ObjectPatternÍÈÍĞ‘U¨PropertyÍÊÍÎÂÃÂLªIdentifierÍÊÍÎ¤show¤initLªIdentifierÍÊÍÎ¤showLªIdentifierÍÕÍÙ¤showÂN³ExpressionStatementÍåÍO´AssignmentExpressionÍåÍ¡=LªIdentifierÍåÍì§allAxisX®CallExpressionÍïÍLªIdentifierÍïÍ·mergeDefaultBoundaryGap‘LªIdentifierÍÍ§allAxisÂN³ExpressionStatementÍÍIO´AssignmentExpressionÍÍH¡=LªIdentifierÍÍ!§allAxisX®CallExpressionÍ$ÍHLªIdentifierÍ$Í8´calcAxisLinePosition’LªIdentifierÍ9Í@§allAxisLªIdentifierÍBÍG¥chartÂN³ExpressionStatementÍSÍ‡O´AssignmentExpressionÍSÍ†¡=LªIdentifierÍSÍZ§allAxisX®CallExpressionÍ]Í†LªIdentifierÍ]Ín±calcAxisLabelData“LªIdentifierÍoÍv§allAxisLªIdentifierÍxÍ~¦seriesLªIdentifierÍ€Í…¥chartÂN³ExpressionStatementÍ‘Í´O´AssignmentExpressionÍ‘Í³¡=LªIdentifierÍ‘Í˜§allAxisX®CallExpressionÍ›Í³LªIdentifierÍ›Íª¯setAxisPosition‘LªIdentifierÍ«Í²§allAxisÂN³ExpressionStatementÍ¾ÍíO´AssignmentExpressionÍ¾Íì¡=LªIdentifierÍ¾ÍÅ§allAxisX®CallExpressionÍÈÍìLªIdentifierÍÈÍÜ´calcAxisTickPosition’LªIdentifierÍİÍä§allAxisLªIdentifierÍæÍë¥chartÂN³ExpressionStatementÍ÷Í&O´AssignmentExpressionÍ÷Í%¡=LªIdentifierÍ÷Íş§allAxisX®CallExpressionÍÍ%LªIdentifierÍÍ´calcAxisNamePosition’LªIdentifierÍÍ§allAxisLªIdentifierÍÍ$¥chartÂN³ExpressionStatementÍ0Í`O´AssignmentExpressionÍ0Í_¡=LªIdentifierÍ0Í7§allAxisX®CallExpressionÍ:Í_LªIdentifierÍ:ÍOµcalcSplitLinePosition’LªIdentifierÍPÍW§allAxisLªIdentifierÍYÍ^¥chartÂÀN³ExpressionStatementÍmÍúX®CallExpressionÍmÍùLªIdentifierÍmÍu¨doUpdate‘R°ObjectExpressionÍvÍø”ÔrY™¤type¥start£end¦method©shorthand¨computed£key¥value¤kind¨PropertyÍÍÂÂÂÔrZ•¤type¥start£end¥value£raw§LiteralÍÍˆ¥chart§'chart'LªIdentifierÍŠÍ¥chart¤initY¨PropertyÍšÍ«ÂÂÂZ§LiteralÍšÍ¢¦series¨'series'LªIdentifierÍ¤Í«§allAxis¤initY¨PropertyÍ¶ÍÇÂÂÂZ§LiteralÍ¶Í»£key¥'key'Z§LiteralÍ½ÍÇ¨axisLineª'axisLine'¤initY¨PropertyÍÒÍñÂÂÂZ§LiteralÍÒÍâ®getGraphConfig°'getGraphConfig'LªIdentifierÍäÍñ­getLineConfig¤initÂN³ExpressionStatementÍNÍÌX®CallExpressionÍNÍËLªIdentifierÍNÍV¨doUpdate‘R°ObjectExpressionÍWÍÊ”U¨PropertyÍbÍgÂÃÂLªIdentifierÍbÍg¥chart¤initLªIdentifierÍbÍg¥chartY¨PropertyÍrÍÂÂÂLªIdentifierÍrÍx¦seriesLªIdentifierÍzÍ§allAxis¤initY¨PropertyÍŒÍ›ÂÂÂLªIdentifierÍŒÍ£keyZ§LiteralÍ‘Í›¨axisTickª'axisTick'¤initY¨PropertyÍ¦ÍÃÂÂÂLªIdentifierÍ¦Í´®getGraphConfigLªIdentifierÍ¶ÍÃ­getTickConfig¤initÂN³ExpressionStatementÍ Í X®CallExpressionÍ ÍŸLªIdentifierÍ Í(¨doUpdate‘R°ObjectExpressionÍ)Í”U¨PropertyÍ4Í9ÂÃÂLªIdentifierÍ4Í9¥chart¤initLªIdentifierÍ4Í9¥chartY¨PropertyÍDÍSÂÂÂLªIdentifierÍDÍJ¦seriesLªIdentifierÍLÍS§allAxis¤initY¨PropertyÍ^ÍnÂÂÂLªIdentifierÍ^Ía£keyZ§LiteralÍcÍn©axisLabel«'axisLabel'¤initY¨PropertyÍyÍ—ÂÂÂLªIdentifierÍyÍ‡®getGraphConfigLªIdentifierÍ‰Í—®getLabelConfig¤initÂN³ExpressionStatementÍôÍrX®CallExpressionÍôÍqLªIdentifierÍôÍü¨doUpdate‘R°ObjectExpressionÍıÍp”U¨PropertyÍÍÂÃÂLªIdentifierÍÍ¥chart¤initLªIdentifierÍÍ¥chartY¨PropertyÍÍ'ÂÂÂLªIdentifierÍÍ¦seriesLªIdentifierÍ Í'§allAxis¤initY¨PropertyÍ2ÍAÂÂÂLªIdentifierÍ2Í5£keyZ§LiteralÍ7ÍA¨axisNameª'axisName'¤initY¨PropertyÍLÍiÂÂÂLªIdentifierÍLÍZ®getGraphConfigLªIdentifierÍ\Íi­getNameConfig¤initÂN³ExpressionStatementÍÆÍ	JX®CallExpressionÍÆÍ	ILªIdentifierÍÆÍÎ¨doUpdate‘R°ObjectExpressionÍÏÍ	H”U¨PropertyÍÚÍßÂÃÂLªIdentifierÍÚÍß¥chart¤initLªIdentifierÍÚÍß¥chartY¨PropertyÍêÍùÂÂÂLªIdentifierÍêÍğ¦seriesLªIdentifierÍòÍù§allAxis¤initY¨PropertyÍ	Í	ÂÂÂLªIdentifierÍ	Í	£keyZ§LiteralÍ		Í	©splitLine«'splitLine'¤initY¨PropertyÍ	Í	AÂÂÂLªIdentifierÍ	Í	-®getGraphConfigLªIdentifierÍ	/Í	A²getSplitLineConfig¤initÂN³ExpressionStatementÍÍ©O´AssignmentExpressionÍÍ¨¡=Q°MemberExpressionÍÍLªIdentifierÍÍ•¥chartLªIdentifierÍ–Í¨axisDataÂÂLªIdentifierÍ¡Í¨§allAxisÀ•Ôr[•¤type¥start£endªspecifiers¦source±ImportDeclaration 2‘Ôr\•¤type¥start£end¨imported¥local¯ImportSpecifier	LªIdentifier	¨doUpdateLªIdentifier	¨doUpdateZ§Literal1¶../class/updater.class¸'../class/updater.class'[±ImportDeclaration4Ìi’\¯ImportSpecifier=ÌHLªIdentifier=ÌH«xAxisConfigLªIdentifier=ÌH«xAxisConfig\¯ImportSpecifierÌJÌULªIdentifierÌJÌU«yAxisConfigLªIdentifierÌJÌU«yAxisConfigZ§LiteralÌ]Ìh©../config«'../config'[±ImportDeclarationÌkÌá—\¯ImportSpecifierÌtÌƒLªIdentifierÌtÌƒ¯filterNonNumberLªIdentifierÌtÌƒ¯filterNonNumber\¯ImportSpecifierÌ…ÌLªIdentifierÌ…Ì©deepMergeLªIdentifierÌ…Ì©deepMerge\¯ImportSpecifierÌÌ¢LªIdentifierÌÌ¢²mergeSameStackDataLªIdentifierÌÌ¢²mergeSameStackData\¯ImportSpecifierÌ¤Ì­LªIdentifierÌ¤Ì­©drawTextsLªIdentifierÌ¤Ì­©drawTexts\¯ImportSpecifierÌ¯Ì¼LªIdentifierÌ¯Ì¼­drawBreakTextLªIdentifierÌ¯Ì¼­drawBreakText\¯ImportSpecifierÌ¾ÌÈLªIdentifierÌ¾ÌÈªgetIndicesLªIdentifierÌ¾ÌÈªgetIndices\¯ImportSpecifierÌÊÌÏLªIdentifierÌÊÌÏ¥px2vpLªIdentifierÌÊÌÏ¥px2vpZ§LiteralÌ×Ìà§../util©'../util'[±ImportDeclarationÌãÍ’\¯ImportSpecifierÌìÌõLªIdentifierÌìÌõ©deepCloneLªIdentifierÌìÌõ©deepClone\¯ImportSpecifierÌ÷ÍLªIdentifierÌ÷Í¯getFormatterValLªIdentifierÌ÷Í¯getFormatterValZ§LiteralÍÍ®../util/common°'../util/common'[±ImportDeclarationÍ!ÍN‘Ôr]”¤type¥start£end¥local¶ImportDefaultSpecifierÍ(Í/LªIdentifierÍ(Í/§drawingZ§LiteralÍ5ÍM¶@ohos.graphics.drawing¸"@ohos.graphics.drawing"