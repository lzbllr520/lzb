<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS 实时综合视图</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #1e3a5f;
            text-shadow: 1px 1px 2px #ccc;
        }
        .canvas-container {
            background-color: #ffffff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            background-color: #fafafa;
            border: 1px solid #e0e0e0;
        }
        h2 {
            margin-top: 0;
            color: #333;
        }
        #status-panel {
            width: 90%;
            max-width: 880px; /* 匹配Canvas宽度 */
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            border: 1px solid #ddd;
        }
        #status-panel p {
            margin: 5px 0;
            font-size: 14px;
        }
        #status-panel #connection-status {
            font-weight: bold;
        }
        .status-connected { color: #28a745; }
        .status-disconnected { color: #dc3545; }
        .status-connecting { color: #fd7e14; }
    </style>
</head>
<body>

    <h1>ROS 实时综合视图</h1>

    <div id="status-panel">
        <p><b>连接状态:</b> <span id="connection-status" class="status-disconnected">未连接</span></p>
        <p><b>里程计 (/odom):</b> <span id="odom-data">等待数据...</span></p>
        <p><b>地图 (/map):</b> <span id="map-data">等待数据...</span></p>
        <p><b>激光雷达 (/scan):</b> <span id="scan-data">等待数据...</span></p>
    </div>

    <div class="canvas-container">
        <h2>综合视图 (地图, 位置, 激光雷达)</h2>
        <canvas id="mainCanvas" width="900" height="900"></canvas>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- 配置 ---
    const config = {
        websocketUrl: 'ws://192.168.2.19:9090', // <-- 修改为你的 rosbridge WebSocket 地址
        topics: {
            map: { name: '/map', type: 'nav_msgs/OccupancyGrid' },
            odom: { name: '/odom', type: 'nav_msgs/Odometry' },
            scan: { name: '/scan', type: 'sensor_msgs/LaserScan' }
        },
        trajectoryMaxLength: 200, // 轨迹最大长度
        robotSize: 0.25, // 机器人半径 (米)
        arrowLength: 0.5, // 朝向箭头长度 (米)
        lidarPointSize: 0.05, // Lidar点在地图上的半径 (米)
    };

    // --- 获取DOM元素 ---
    const connectionStatusEl = document.getElementById('connection-status');
    const odomDataEl = document.getElementById('odom-data');
    const mapDataEl = document.getElementById('map-data');
    const scanDataEl = document.getElementById('scan-data');

    const mainCanvas = document.getElementById('mainCanvas');
    const ctx = mainCanvas.getContext('2d');

    // --- 状态变量 ---
    let rosSocket = null;
    let mapInfo = null;
    let mapImageData = null;
    let currentOdom = null;
    let currentScan = null;
    const trajectory = [];
    
    // --- WebSocket 连接 ---
    function connect() {
        rosSocket = new WebSocket(config.websocketUrl);

        rosSocket.onopen = () => {
            console.log('成功连接到 rosbridge server。');
            connectionStatusEl.textContent = '已连接';
            connectionStatusEl.className = 'status-connected';
            subscribeToTopics();
        };

        rosSocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            switch (data.topic) {
                case config.topics.map.name:
                    handleMapData(data.msg);
                    break;
                case config.topics.odom.name:
                    handleOdomData(data.msg);
                    break;
                case config.topics.scan.name:
                    handleScanData(data.msg);
                    break;
            }
        };

        rosSocket.onclose = () => {
            console.log('与 rosbridge server 的连接已断开。将在5秒后重试...');
            connectionStatusEl.textContent = '已断开 (5秒后重试)';
            connectionStatusEl.className = 'status-disconnected';
            setTimeout(connect, 5000);
        };

        rosSocket.onerror = (error) => {
            console.error('WebSocket 错误:', error);
            connectionStatusEl.textContent = '连接错误';
            connectionStatusEl.className = 'status-disconnected';
            rosSocket.close();
        };
        
        connectionStatusEl.textContent = '正在连接...';
        connectionStatusEl.className = 'status-connecting';
    }

    function subscribeToTopics() {
        Object.values(config.topics).forEach(topic => {
            const subscribeMsg = {
                op: 'subscribe',
                topic: topic.name,
                type: topic.type
            };
            rosSocket.send(JSON.stringify(subscribeMsg));
            console.log(`已订阅话题: ${topic.name}`);
        });
    }

    // --- 数据处理 ---
    function handleMapData(msg) {
        if (!msg.info || !msg.data) return;
        mapInfo = msg.info;
        
        const { width, height } = mapInfo;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        const imageData = tempCtx.createImageData(width, height);
        
        for (let i = 0; i < msg.data.length; i++) {
            const occupancy = msg.data[i];
            let color;
            if (occupancy === -1) { color = 200; } 
            else { color = 255 - (occupancy * 2.55); }
            const j = i * 4;
            imageData.data[j] = color;
            imageData.data[j + 1] = color;
            imageData.data[j + 2] = color;
            imageData.data[j + 3] = 255;
        }
        tempCtx.putImageData(imageData, 0, 0);
        mapImageData = tempCanvas;

        mapDataEl.textContent = `已接收 ${width}x${height} 地图, 分辨率 ${mapInfo.resolution.toFixed(3)} m/pixel`;
    }

    function handleOdomData(msg) {
        const pose = msg.pose.pose;
        const yaw = Math.atan2(2 * (pose.orientation.w * pose.orientation.z + pose.orientation.x * pose.orientation.y), 1 - 2 * (pose.orientation.y * pose.orientation.y + pose.orientation.z * pose.orientation.z));
        currentOdom = { x: pose.position.x, y: pose.position.y, yaw: yaw };
        trajectory.push({ x: currentOdom.x, y: currentOdom.y });
        if (trajectory.length > config.trajectoryMaxLength) trajectory.shift();
        odomDataEl.textContent = `X: ${pose.position.x.toFixed(2)}m, Y: ${pose.position.y.toFixed(2)}m, θ: ${(yaw * 180 / Math.PI).toFixed(1)}°`;
    }

    function handleScanData(msg) {
        currentScan = msg;
        scanDataEl.textContent = `接收到 ${msg.ranges.length} 个点, 距离范围 [${msg.range_min.toFixed(1)}m, ${msg.range_max.toFixed(2)}m]`;
    }

    // --- 绘图函数 ---
    function draw() {
        // 清空画布
        ctx.fillStyle = '#FAFAFA';
        ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);

        if (!mapInfo && !currentOdom) {
            ctx.fillStyle = '#333';
            ctx.font = "18px sans-serif";
            ctx.textAlign = 'center';
            ctx.fillText("等待数据...", mainCanvas.width / 2, mainCanvas.height / 2);
            requestAnimationFrame(draw);
            return;
        }

        ctx.save();

        // --- 设置坐标系 ---
        const centerX = currentOdom ? currentOdom.x : (mapInfo ? mapInfo.origin.position.x + mapInfo.width * mapInfo.resolution / 2 : 0);
        const centerY = currentOdom ? currentOdom.y : (mapInfo ? mapInfo.origin.position.y + mapInfo.height * mapInfo.resolution / 2 : 0);
        const viewWidthInMeters = 25; 
        const scale = mainCanvas.width / viewWidthInMeters;

        ctx.translate(mainCanvas.width / 2, mainCanvas.height / 2);
        ctx.scale(scale, -scale);
        ctx.translate(-centerX, -centerY);

        // --- 绘制地图 ---
        if (mapInfo && mapImageData) {
            ctx.save();
            ctx.translate(mapInfo.origin.position.x, mapInfo.origin.position.y);
            ctx.scale(mapInfo.resolution, -mapInfo.resolution);
            ctx.imageSmoothingEnabled = false; // 像素艺术风格，防止模糊
            ctx.drawImage(mapImageData, 0, -mapInfo.height);
            ctx.restore();
        }

        // --- 绘制激光雷达点 (在机器人后面绘制) ---
        if (currentScan && currentOdom) {
            ctx.fillStyle = 'rgba(255, 20, 20, 0.7)'; // 鲜艳的红色
            const { ranges, angle_min, angle_increment, range_min, range_max } = currentScan;
            const { x: robotX, y: robotY, yaw: robotYaw } = currentOdom;
            
            ctx.beginPath();
            for (let i = 0; i < ranges.length; i++) {
                const range = ranges[i];
                if (range >= range_min && range <= range_max) {
                    const localAngle = angle_min + i * angle_increment;
                    const worldAngle = robotYaw + localAngle; // 核心转换
                    
                    const pointX = robotX + range * Math.cos(worldAngle);
                    const pointY = robotY + range * Math.sin(worldAngle);
                    
                    ctx.moveTo(pointX, pointY);
                    ctx.arc(pointX, pointY, config.lidarPointSize, 0, 2 * Math.PI);
                }
            }
            ctx.fill();
        }

        // --- 绘制轨迹 ---
        if (trajectory.length > 1) {
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.7)';
            ctx.lineWidth = 0.05;
            ctx.beginPath();
            ctx.moveTo(trajectory[0].x, trajectory[0].y);
            for (let i = 1; i < trajectory.length; i++) {
                ctx.lineTo(trajectory[i].x, trajectory[i].y);
            }
            ctx.stroke();
        }

        // --- 绘制机器人 ---
        if (currentOdom) {
            const { x, y, yaw } = currentOdom;
            ctx.fillStyle = 'rgba(0, 80, 200, 0.9)'; // 深蓝色
            ctx.beginPath();
            ctx.arc(x, y, config.robotSize / 2, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 1)'; // 白色箭头
            ctx.lineWidth = 0.07;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + config.arrowLength * Math.cos(yaw), y + config.arrowLength * Math.sin(yaw));
            ctx.stroke();
        }

        ctx.restore();
        requestAnimationFrame(draw);
    }

    // --- 启动程序 ---
    connect();
    draw();
});
</script>

</body>
</html>